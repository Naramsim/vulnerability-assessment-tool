{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Vulas \u00b6 General What is Vulas? Users Quick start Frequently Asked Questions/Troubleshooting User Manual Get support Admins Operating your own Vulas servers Vulnerabilities Learn about Vulas's vulnerability database","title":"Home"},{"location":"#vulas","text":"General What is Vulas? Users Quick start Frequently Asked Questions/Troubleshooting User Manual Get support Admins Operating your own Vulas servers Vulnerabilities Learn about Vulas's vulnerability database","title":"Vulas"},{"location":"about/","text":"About \u00b6 Vulas analyzes Java and Python applications in order to: detect whether they depend on open-source components with known vulnerabilities, collect evidence of the execution of vulnerable code in a given application context (through a novel combination of static and dynamic analysis), and support developers in the mitigation of such vulnerable dependencies. Vulas addresses the OWASP Top 10 security risk A9, Using Components with Known Vulnerabilities . Differently from other tools that have similar goals, the detection approach of Vulas is code-centric and usage-based , which allows for a more accurate detection and assessment than tools relying on meta-data. Vulas is implemented as a collection of client-side tools (for Java and Python), server-side RESTful services and several Web frontends. Initially developed by SAP Security Research , Vulas was adopted internally by SAP as early as 2015. The tool has been open-sourced in October 2018 under the Apache License v.2.0. The approach implemented in Vulas is described in detail in the the following scientific papers: Serena Ponta, Henrik Plate, Antonino Sabetta, Beyond Metadata: Code-centric and Usage-based Analysis of Known Vulnerabilities in Open-source Software , 34 th International Conference on Software Maintenance and Evolution (ICSME), 2018 (recipient of the IEEE TCSE Distinguished Paper Award) Henrik Plate, Serena Ponta, Antonino Sabetta, Impact Assessment for Vulnerabilities in Open-Source Software Libraries , 31 st International Conference on Software Maintenance and Evolution (ICSME), 2015 The Team \u00b6 Henrik Plate (SAP Security Research) Serena E. Ponta (SAP Security Research) Antonino Sabetta (SAP Security Research) C\u00e9dric Dangremont (SAP Security Testing and Validation) Alessandro Pezz\u00e9 (SAP Security Testing and Validation)","title":"About"},{"location":"about/#about","text":"Vulas analyzes Java and Python applications in order to: detect whether they depend on open-source components with known vulnerabilities, collect evidence of the execution of vulnerable code in a given application context (through a novel combination of static and dynamic analysis), and support developers in the mitigation of such vulnerable dependencies. Vulas addresses the OWASP Top 10 security risk A9, Using Components with Known Vulnerabilities . Differently from other tools that have similar goals, the detection approach of Vulas is code-centric and usage-based , which allows for a more accurate detection and assessment than tools relying on meta-data. Vulas is implemented as a collection of client-side tools (for Java and Python), server-side RESTful services and several Web frontends. Initially developed by SAP Security Research , Vulas was adopted internally by SAP as early as 2015. The tool has been open-sourced in October 2018 under the Apache License v.2.0. The approach implemented in Vulas is described in detail in the the following scientific papers: Serena Ponta, Henrik Plate, Antonino Sabetta, Beyond Metadata: Code-centric and Usage-based Analysis of Known Vulnerabilities in Open-source Software , 34 th International Conference on Software Maintenance and Evolution (ICSME), 2018 (recipient of the IEEE TCSE Distinguished Paper Award) Henrik Plate, Serena Ponta, Antonino Sabetta, Impact Assessment for Vulnerabilities in Open-Source Software Libraries , 31 st International Conference on Software Maintenance and Evolution (ICSME), 2015","title":"About"},{"location":"about/#the-team","text":"Henrik Plate (SAP Security Research) Serena E. Ponta (SAP Security Research) Antonino Sabetta (SAP Security Research) C\u00e9dric Dangremont (SAP Security Testing and Validation) Alessandro Pezz\u00e9 (SAP Security Testing and Validation)","title":"The Team"},{"location":"admin/","text":"DevOps \u00b6 In this tutorial, you will be guided through the necessary steps to set-up the Vulas backend services. Important Remark! The setup obtained following these instructions is meant for demonstration purposes. It shall not be used in productive scenarios (both for security and scalability concerns). Pre-requisites \u00b6 docker git Installation \u00b6 Clone from GitHub \u00b6 git clone https://github.com/SAP/vulnerability-assessment-tool Build Docker images \u00b6 Testing Environment Vulas was successfully built against Ubuntu 16.04 - Docker version 17.03.2-ce, build f5ec1e2 Win10 noWSL - Docker version 18.01.0-ce, build 03596f5 All the following commands are supposed to be executed from the root folder of the project. Before proceeding, be sure to move there with: cd vulnerability-assessment-tool Make a copy of the sample configuration: cp docker/.env.sample docker/.env Edit the file docker/.env to match your needs. Info In docker/.env you must always configure at least POSTGRES_USER= and spring.datasource.username= (with equal values) At this point, you are ready to perform the actual build with the following command: docker build --tag vulas-build-img -f docker/Dockerfile --build-arg http_proxy = --build-arg https_proxy = . docker run -it --rm -v ${ PWD } /docker:/exporter --env-file ./docker/.env -e mvn_flags = -DexcludedGroups = com.sap.psr.vulas.shared.categories.Slow vulas-build-img In case you are running behind a proxy you need to configure it in the --build-arg arguments. As a result, the folders docker/<component-name> will contain compiled JARs (or WARs, depending on the component). Finally, you may want to make all artifacts available to the developers of your organization (e.g., through an internal Nexus or other artifact distribution system). Run \u00b6 You are now ready to run the system: ( cd docker && docker-compose up -d --build ) To check that everything started successfully, check the page http://localhost:8033/haproxy?stats (user/pwd: admin/admin ). All endpoints should appear as green (you may want to replace localhost with the actual hostname of your machine). Populate/maintain the vulnerability database \u00b6 In order for the tool to detect vulnerabilities, you need to analyze them first so that they are available in the tool's vulnerability database. To do so, please follow the instructions mentioned here . Analyze an application \u00b6 Pre-requisite : Please, make sure you take note of the URL of the backend service as well as the URL of the apps Web frontend , you will need these: Apps Web frontend: http://localhost:8033/apps Backend service: http://localhost:8033/backend You may want to replace localhost with the actual hostname of your machine. Get going: Setup your workspace (if you don't have one) Become familiar with the various analysis goals (first time users) Analyze your Java or Python application (on a regular basis) Assess findings using the apps Web frontend (following every analysis) Further links: Configure the client-side analysis Automate with Jenkins Get help if you run into troubles","title":"DevOps"},{"location":"admin/#devops","text":"In this tutorial, you will be guided through the necessary steps to set-up the Vulas backend services. Important Remark! The setup obtained following these instructions is meant for demonstration purposes. It shall not be used in productive scenarios (both for security and scalability concerns).","title":"DevOps"},{"location":"admin/#pre-requisites","text":"docker git","title":"Pre-requisites"},{"location":"admin/#installation","text":"","title":"Installation"},{"location":"admin/#clone-from-github","text":"git clone https://github.com/SAP/vulnerability-assessment-tool","title":"Clone from GitHub"},{"location":"admin/#build-docker-images","text":"Testing Environment Vulas was successfully built against Ubuntu 16.04 - Docker version 17.03.2-ce, build f5ec1e2 Win10 noWSL - Docker version 18.01.0-ce, build 03596f5 All the following commands are supposed to be executed from the root folder of the project. Before proceeding, be sure to move there with: cd vulnerability-assessment-tool Make a copy of the sample configuration: cp docker/.env.sample docker/.env Edit the file docker/.env to match your needs. Info In docker/.env you must always configure at least POSTGRES_USER= and spring.datasource.username= (with equal values) At this point, you are ready to perform the actual build with the following command: docker build --tag vulas-build-img -f docker/Dockerfile --build-arg http_proxy = --build-arg https_proxy = . docker run -it --rm -v ${ PWD } /docker:/exporter --env-file ./docker/.env -e mvn_flags = -DexcludedGroups = com.sap.psr.vulas.shared.categories.Slow vulas-build-img In case you are running behind a proxy you need to configure it in the --build-arg arguments. As a result, the folders docker/<component-name> will contain compiled JARs (or WARs, depending on the component). Finally, you may want to make all artifacts available to the developers of your organization (e.g., through an internal Nexus or other artifact distribution system).","title":"Build Docker images"},{"location":"admin/#run","text":"You are now ready to run the system: ( cd docker && docker-compose up -d --build ) To check that everything started successfully, check the page http://localhost:8033/haproxy?stats (user/pwd: admin/admin ). All endpoints should appear as green (you may want to replace localhost with the actual hostname of your machine).","title":"Run"},{"location":"admin/#populatemaintain-the-vulnerability-database","text":"In order for the tool to detect vulnerabilities, you need to analyze them first so that they are available in the tool's vulnerability database. To do so, please follow the instructions mentioned here .","title":"Populate/maintain the vulnerability database"},{"location":"admin/#analyze-an-application","text":"Pre-requisite : Please, make sure you take note of the URL of the backend service as well as the URL of the apps Web frontend , you will need these: Apps Web frontend: http://localhost:8033/apps Backend service: http://localhost:8033/backend You may want to replace localhost with the actual hostname of your machine. Get going: Setup your workspace (if you don't have one) Become familiar with the various analysis goals (first time users) Analyze your Java or Python application (on a regular basis) Assess findings using the apps Web frontend (following every analysis) Further links: Configure the client-side analysis Automate with Jenkins Get help if you run into troubles","title":"Analyze an application"},{"location":"admin/manuals/","text":"","title":"Home"},{"location":"admin/support/faq/","text":"","title":"Faq"},{"location":"admin/support/faq_sap/","text":"","title":"Faq sap"},{"location":"admin/support/getting_help/","text":"","title":"Getting help"},{"location":"admin/tutorials/","text":"Getting started with Vulas \u00b6 Vulas tutorials landing page","title":"Getting started with Vulas"},{"location":"admin/tutorials/#getting-started-with-vulas","text":"Vulas tutorials landing page","title":"Getting started with Vulas"},{"location":"admin/tutorials/admin_guide/","text":"","title":"Admin guide"},{"location":"admin/tutorials/tutorial_using/","text":"","title":"Tutorial using"},{"location":"admin/tutorials/tutorial_vulndb/","text":"Populating and maintaining the vulnerability database \u00b6 In order for the tool to detect vulnerabilities, you need to analyze them first so that they are available in the tool's vulnerability database. To do so, please follow the instructions mentioned here .","title":"Populating and maintaining the vulnerability database"},{"location":"admin/tutorials/tutorial_vulndb/#populating-and-maintaining-the-vulnerability-database","text":"In order for the tool to detect vulnerabilities, you need to analyze them first so that they are available in the tool's vulnerability database. To do so, please follow the instructions mentioned here .","title":"Populating and maintaining the vulnerability database"},{"location":"blog/2018/","text":"","title":"Home"},{"location":"contributor/","text":"Contribute \u00b6 Our aim is to build a lively community, hence, we welcome any exchange and collaboration with individuals and organizations interested in the use, support and extension of Vulas. To contribute, read on to learn about your options: Help Others on Stack Overflow Report Bugs as GitHub issues Analyze Bugs Contribute Code (fixes and features) Contribute to the Vulnerability Knowledge Base Help Others \u00b6 You can help by helping others who use Vulas and need support. Find them on Stack Overflow . Report Bugs \u00b6 If you find a bug - a behavior of the code contradicting its specification - you are welcome to report it. We can only handle well-reported, actual bugs, so please follow the guidelines below and use forums like Stack Overflow for support questions or when in doubt whether the issue is an actual bug. Once you have familiarized with the guidelines, you can go to the GitHub issue tracker to report the issue. Quick Checklist for Bug Reports \u00b6 Issue report checklist: Real, current bug No duplicate Reproducible Good summary Well-documented Minimal example Use the template Requirements for a bug report \u00b6 These eight requirements are the mandatory base of a good bug report: Only real bugs : please do your best to make sure to only report real bugs! Do not report: issues caused by application code or any code outside Vulas. something that behaves just different from what you expected. A bug is when something behaves different than specified. When in doubt, ask in a forum. something you do not get to work properly. Use a support forum like Stack Overflow to request help. feature requests. Well, this is arguable: critical or easy-to-do enhancement suggestions are welcome, but we do not want to use the issue tracker as wishlist. No duplicate: you have searched the issue tracker to make sure the bug has not yet been reported Good summary: the summary should be specific to the issue Current bug: the bug can be reproduced in the most current version (state the tested version!) Reproducible bug: there are clear steps to reproduce given. This includes, where possible: a URL to access the example any required user/password information (do not reveal any credentials that could be mis-used!) detailed and complete step-by-step instructions to reproduce the bug Precise description: precisely state the expected and the actual behavior give information about the used browser/device and its version, if possible also the behavior in other browsers/devices if the bug is about wrong UI appearance, attach a screenshot and mark what is wrong generally give as much additional information as possible. (But find the right balance: do not invest hours for a very obvious and easy to solve issue. When in doubt, give more information.) Minimal example: it is highly encouraged to provide a minimal example to reproduce in e.g. jsbin: isolate the application code which triggers the issue and strip it down as much as possible as long as the issue still occurs. If several files are required, you can create a gist. This may not always be possible and sometimes be overkill, but it always helps analyzing a bug. Only one bug per report: open different tickets for different issues You are encouraged to use this template . Please report bugs in English, so all users can understand them. If the bug appears to be a regression introduced in a new version of Vulas, try to find the closest versions between which it was introduced. Issue handling process \u00b6 When an issue is reported, a committer will look at it and either confirm it as a real issue (by giving the \"approved\" label), close it if it is not an issue, or ask for more details. Approved issues are then either assigned to a committer in GitHub, reported in our internal issue handling system, or left open as \"contribution welcome\" for easy or not urgent fixes. An issue that is about a real bug is closed as soon as the fix is committed. The closing comment explains which patch version(s) will contain the fix. Usage of Labels \u00b6 Github offers labels to categorize issues. We defined the following labels so far: Labels for issue categories: bug: this issue is a bug in the code documentation: this issue is about wrong documentation enhancement: this is not a bug report, but an enhancement request Status of open issues: unconfirmed: this report needs confirmation whether it is really a bug (no label; this is the default status) approved: this issue is confirmed to be a bug author action: the author is required to provide information contribution welcome: this fix/enhancement is approved and you are invited to contribute it Status/resolution of closed issues: fixed: a fix for the issue was provided duplicate: the issue is also reported in a different ticket and is handled there invalid: for some reason or another this issue report will not be handled further (maybe lack of information or issue does not apply anymore) works: not reproducible or working as expected wontfix: while acknowledged to be an issue, a fix cannot or will not be provided The labels can only be set and modified by committers. Issue Reporting Disclaimer \u00b6 We want to improve the quality of Vulas and good bug reports are welcome! But our capacity is limited, so we cannot handle questions or consultation requests and we cannot afford to ask for required details. So we reserve the right to close or to not process insufficient bug reports in favor of those which are very cleanly documented and easy to reproduce. Even though we would like to solve each well-documented issue, there is always the chance that it won't happen - remember: Vulas is Open Source and comes without warranty. Analyze Bugs \u00b6 Analyzing issue reports can be a lot of effort. Any help is welcome! Go to the Github issue tracker and find an open issue which needs additional work or a bugfix. Additional work may be further information, or a minimized jsbin example or gist, or it might be a hint that helps understanding the issue. Maybe you can even find and contribute a bugfix? Contribute Code \u00b6 You are welcome to contribute code in order to fix bugs or to implement new features. There are three important things to know: You must be aware of the Apache License (which describes contributions) and agree to the Contributors License Agreement . This is common practice in all major Open Source projects. To make this process as simple as possible, we are using CLA assistant for individual contributions. CLA assistant is an open source tool that integrates with GitHub very well and enables a one-click-experience for accepting the CLA. For company contributors special rules apply. See the respective section below for details. There are several requirements regarding code style, quality, and product standards which need to be met (we also have to follow them). The respective section below gives more details on the coding guidelines. Not all proposed contributions can be accepted . Some features may e.g. just fit a third-party add-on better. The code must fit the overall direction of the open-source vulnerability assessment tool and really improve it, so there should be some \"bang for the byte\". For most bug fixes this is a given, but major feature implementation first need to be discussed with one of the Vulas committers , possibly one who touched the related code recently. The more effort you invest, the better you should clarify in advance whether the contribution fits: the best way would be to just open an enhancement ticket in the issue tracker to discuss the feature you plan to implement (make it clear you intend to contribute). We will then forward the proposal to the respective code owner, this avoids disappointment. Contributor License Agreement \u00b6 When you contribute (code, documentation, or anything else), you have to be aware that your contribution is covered by the same Apache 2.0 License that is applied to the open-source vulnerability assessment tool itself. In particular you need to agree to the Individual Contributor License Agreement, which can be found here . (This applies to all contributors, including those contributing on behalf of a company). If you agree to its content, you simply have to click on the link posted by the CLA assistant as a comment to the pull request. Click it to check the CLA, then accept it on the following screen if you agree to it. CLA assistant will save this decision for upcoming contributions and will notify you if there is any change to the CLA in the meantime. Company Contributors If employees of a company contribute code, in addition to the individual agreement above, there needs to be one company agreement submitted. This is mainly for the protection of the contributing employees. A company representative authorized to do so needs to download, fill, and print the Corporate Contributor License Agreement form. Then either: Scan it and e-mail it to opensource@sap.com and henrik.plate@sap.com Fax it to: +49 6227 78-45813 Send it by traditional letter to: Industry Standards & Open Source Team, Dietmar-Hopp-Allee 16, 69190 Walldorf, Germany The form contains a list of employees who are authorized to contribute on behalf of your company. When this list changes, please let us know. Contribution Content Guidelines \u00b6 Contributed content can be accepted if it: is useful to improve Vulas (explained above) follows the applicable guidelines and standards The second requirement could be described in entire books and would still lack a 100%-clear definition, so you will get a committer's feedback if something is not right. These are some of the most important rules to give you an initial impression: Apply a clean coding style adapted to the surrounding code, even though we are aware the existing code is not fully clean Use tabs for indentation (except if the modified file consistently uses spaces) Use variable naming conventions like in the other files you are seeing (e.g. hungarian notation) No System.out.println Only access public APIs of other entities (there are exceptions, but this is the rule) Comment your code where it gets non-trivial Keep an eye on performance and memory consumption Write a unit test Do not do any incompatible changes, especially do not modify the name or behavior of public API methods or properties Always consider the developer who USES your control/code! Think about what code and how much code he/she will need to write to use your feature Think about what she/he expects your control/feature to do If this list sounds lengthy and hard to achieve - well, that's what WE have to comply with as well, and it's by far not complete\u2026 How to contribute - the Process \u00b6 Make sure the change would be welcome (e.g. a bugfix or a useful feature); best do so by proposing it in a GitHub issue Create a branch forking Vulas repository and do your change Commit and push your changes on that branch When you have several commits, squash them into one (see this explanation ) - this also needs to be done when additional changes are required after the code review Provide a meaningful commit message incl. links to the respective issue If your change fixes an issue reported at GitHub, add the following line to the commit message: Fixes https://github.com/SAP/vulnerability-assessment-tool/issues/(issueNumber) Do NOT add a colon after \"Fixes\" - this prevents automatic closing. When your pull request number is known (e.g. because you enhance a pull request after a code review), you can also add the line Closes https://github.com/SAP/vulnerability-assessment-tool/pull/(pullRequestNumber) Create a Pull Request to https://github.com/SAP/vulnerability-assessment-tool Follow the link posted by the CLA assistant to your pull request and accept it, as described in detail above. Wait for our code review and approval, possibly enhancing your change on request Note that Vulas developers also have their regular duties, so depending on the required effort for reviewing, testing and clarification this may take a while Once the change has been approved we will inform you in a comment Your pull request cannot be merged directly into the branch (internal SAP processes), but will be merged internally and immediately appear in the public repository as well. Pull requests for non-code branches (like \"gh-pages\" for the website) can be directly merged. We will close the pull request, feel free to delete the now obsolete branch Contribute to the Vulnerability Knowledge Base \u00b6 https://github.com/SAP/vulnerability-assessment-tool relies on a database with detailed information about vulnerable code (methods, functions, etc.) in open-source software libraries. This information is built by analyzing the source code changes (commits) done by open-source developers to fix a given vulnerability. In order to reflect new vulnerability disclosures, one has to analyze those so-called fix commits and add corresponding entries to the local database. This analysis is done using the PatchAnalyzer , which takes several arguments as input, e.g., the source code repository of the respective component, the commit identifier(s), and a vulnerability identifier. In order to prevent that each and every tool user has to collect this information by himself, we aim at creating a shared knowledge base that can be maintained and used by multiple parties. This knowledge base will be a dedicated GitHub repository, where people can upload new input information for the PatchAnalyzer . This section will be updated once this repository is available and the PatchAnalyzer has been updated to read/write to this GitHub repo.","title":"Contribute"},{"location":"contributor/#contribute","text":"Our aim is to build a lively community, hence, we welcome any exchange and collaboration with individuals and organizations interested in the use, support and extension of Vulas. To contribute, read on to learn about your options: Help Others on Stack Overflow Report Bugs as GitHub issues Analyze Bugs Contribute Code (fixes and features) Contribute to the Vulnerability Knowledge Base","title":"Contribute"},{"location":"contributor/#help-others","text":"You can help by helping others who use Vulas and need support. Find them on Stack Overflow .","title":"Help Others"},{"location":"contributor/#report-bugs","text":"If you find a bug - a behavior of the code contradicting its specification - you are welcome to report it. We can only handle well-reported, actual bugs, so please follow the guidelines below and use forums like Stack Overflow for support questions or when in doubt whether the issue is an actual bug. Once you have familiarized with the guidelines, you can go to the GitHub issue tracker to report the issue.","title":"Report Bugs"},{"location":"contributor/#quick-checklist-for-bug-reports","text":"Issue report checklist: Real, current bug No duplicate Reproducible Good summary Well-documented Minimal example Use the template","title":"Quick Checklist for Bug Reports"},{"location":"contributor/#requirements-for-a-bug-report","text":"These eight requirements are the mandatory base of a good bug report: Only real bugs : please do your best to make sure to only report real bugs! Do not report: issues caused by application code or any code outside Vulas. something that behaves just different from what you expected. A bug is when something behaves different than specified. When in doubt, ask in a forum. something you do not get to work properly. Use a support forum like Stack Overflow to request help. feature requests. Well, this is arguable: critical or easy-to-do enhancement suggestions are welcome, but we do not want to use the issue tracker as wishlist. No duplicate: you have searched the issue tracker to make sure the bug has not yet been reported Good summary: the summary should be specific to the issue Current bug: the bug can be reproduced in the most current version (state the tested version!) Reproducible bug: there are clear steps to reproduce given. This includes, where possible: a URL to access the example any required user/password information (do not reveal any credentials that could be mis-used!) detailed and complete step-by-step instructions to reproduce the bug Precise description: precisely state the expected and the actual behavior give information about the used browser/device and its version, if possible also the behavior in other browsers/devices if the bug is about wrong UI appearance, attach a screenshot and mark what is wrong generally give as much additional information as possible. (But find the right balance: do not invest hours for a very obvious and easy to solve issue. When in doubt, give more information.) Minimal example: it is highly encouraged to provide a minimal example to reproduce in e.g. jsbin: isolate the application code which triggers the issue and strip it down as much as possible as long as the issue still occurs. If several files are required, you can create a gist. This may not always be possible and sometimes be overkill, but it always helps analyzing a bug. Only one bug per report: open different tickets for different issues You are encouraged to use this template . Please report bugs in English, so all users can understand them. If the bug appears to be a regression introduced in a new version of Vulas, try to find the closest versions between which it was introduced.","title":"Requirements for a bug report"},{"location":"contributor/#issue-handling-process","text":"When an issue is reported, a committer will look at it and either confirm it as a real issue (by giving the \"approved\" label), close it if it is not an issue, or ask for more details. Approved issues are then either assigned to a committer in GitHub, reported in our internal issue handling system, or left open as \"contribution welcome\" for easy or not urgent fixes. An issue that is about a real bug is closed as soon as the fix is committed. The closing comment explains which patch version(s) will contain the fix.","title":"Issue handling process"},{"location":"contributor/#usage-of-labels","text":"Github offers labels to categorize issues. We defined the following labels so far: Labels for issue categories: bug: this issue is a bug in the code documentation: this issue is about wrong documentation enhancement: this is not a bug report, but an enhancement request Status of open issues: unconfirmed: this report needs confirmation whether it is really a bug (no label; this is the default status) approved: this issue is confirmed to be a bug author action: the author is required to provide information contribution welcome: this fix/enhancement is approved and you are invited to contribute it Status/resolution of closed issues: fixed: a fix for the issue was provided duplicate: the issue is also reported in a different ticket and is handled there invalid: for some reason or another this issue report will not be handled further (maybe lack of information or issue does not apply anymore) works: not reproducible or working as expected wontfix: while acknowledged to be an issue, a fix cannot or will not be provided The labels can only be set and modified by committers.","title":"Usage of Labels"},{"location":"contributor/#issue-reporting-disclaimer","text":"We want to improve the quality of Vulas and good bug reports are welcome! But our capacity is limited, so we cannot handle questions or consultation requests and we cannot afford to ask for required details. So we reserve the right to close or to not process insufficient bug reports in favor of those which are very cleanly documented and easy to reproduce. Even though we would like to solve each well-documented issue, there is always the chance that it won't happen - remember: Vulas is Open Source and comes without warranty.","title":"Issue Reporting Disclaimer"},{"location":"contributor/#analyze-bugs","text":"Analyzing issue reports can be a lot of effort. Any help is welcome! Go to the Github issue tracker and find an open issue which needs additional work or a bugfix. Additional work may be further information, or a minimized jsbin example or gist, or it might be a hint that helps understanding the issue. Maybe you can even find and contribute a bugfix?","title":"Analyze Bugs"},{"location":"contributor/#contribute-code","text":"You are welcome to contribute code in order to fix bugs or to implement new features. There are three important things to know: You must be aware of the Apache License (which describes contributions) and agree to the Contributors License Agreement . This is common practice in all major Open Source projects. To make this process as simple as possible, we are using CLA assistant for individual contributions. CLA assistant is an open source tool that integrates with GitHub very well and enables a one-click-experience for accepting the CLA. For company contributors special rules apply. See the respective section below for details. There are several requirements regarding code style, quality, and product standards which need to be met (we also have to follow them). The respective section below gives more details on the coding guidelines. Not all proposed contributions can be accepted . Some features may e.g. just fit a third-party add-on better. The code must fit the overall direction of the open-source vulnerability assessment tool and really improve it, so there should be some \"bang for the byte\". For most bug fixes this is a given, but major feature implementation first need to be discussed with one of the Vulas committers , possibly one who touched the related code recently. The more effort you invest, the better you should clarify in advance whether the contribution fits: the best way would be to just open an enhancement ticket in the issue tracker to discuss the feature you plan to implement (make it clear you intend to contribute). We will then forward the proposal to the respective code owner, this avoids disappointment.","title":"Contribute Code"},{"location":"contributor/#contributor-license-agreement","text":"When you contribute (code, documentation, or anything else), you have to be aware that your contribution is covered by the same Apache 2.0 License that is applied to the open-source vulnerability assessment tool itself. In particular you need to agree to the Individual Contributor License Agreement, which can be found here . (This applies to all contributors, including those contributing on behalf of a company). If you agree to its content, you simply have to click on the link posted by the CLA assistant as a comment to the pull request. Click it to check the CLA, then accept it on the following screen if you agree to it. CLA assistant will save this decision for upcoming contributions and will notify you if there is any change to the CLA in the meantime.","title":"Contributor License Agreement"},{"location":"contributor/#contribution-content-guidelines","text":"Contributed content can be accepted if it: is useful to improve Vulas (explained above) follows the applicable guidelines and standards The second requirement could be described in entire books and would still lack a 100%-clear definition, so you will get a committer's feedback if something is not right. These are some of the most important rules to give you an initial impression: Apply a clean coding style adapted to the surrounding code, even though we are aware the existing code is not fully clean Use tabs for indentation (except if the modified file consistently uses spaces) Use variable naming conventions like in the other files you are seeing (e.g. hungarian notation) No System.out.println Only access public APIs of other entities (there are exceptions, but this is the rule) Comment your code where it gets non-trivial Keep an eye on performance and memory consumption Write a unit test Do not do any incompatible changes, especially do not modify the name or behavior of public API methods or properties Always consider the developer who USES your control/code! Think about what code and how much code he/she will need to write to use your feature Think about what she/he expects your control/feature to do If this list sounds lengthy and hard to achieve - well, that's what WE have to comply with as well, and it's by far not complete\u2026","title":"Contribution Content Guidelines"},{"location":"contributor/#how-to-contribute-the-process","text":"Make sure the change would be welcome (e.g. a bugfix or a useful feature); best do so by proposing it in a GitHub issue Create a branch forking Vulas repository and do your change Commit and push your changes on that branch When you have several commits, squash them into one (see this explanation ) - this also needs to be done when additional changes are required after the code review Provide a meaningful commit message incl. links to the respective issue If your change fixes an issue reported at GitHub, add the following line to the commit message: Fixes https://github.com/SAP/vulnerability-assessment-tool/issues/(issueNumber) Do NOT add a colon after \"Fixes\" - this prevents automatic closing. When your pull request number is known (e.g. because you enhance a pull request after a code review), you can also add the line Closes https://github.com/SAP/vulnerability-assessment-tool/pull/(pullRequestNumber) Create a Pull Request to https://github.com/SAP/vulnerability-assessment-tool Follow the link posted by the CLA assistant to your pull request and accept it, as described in detail above. Wait for our code review and approval, possibly enhancing your change on request Note that Vulas developers also have their regular duties, so depending on the required effort for reviewing, testing and clarification this may take a while Once the change has been approved we will inform you in a comment Your pull request cannot be merged directly into the branch (internal SAP processes), but will be merged internally and immediately appear in the public repository as well. Pull requests for non-code branches (like \"gh-pages\" for the website) can be directly merged. We will close the pull request, feel free to delete the now obsolete branch","title":"How to contribute - the Process"},{"location":"contributor/#contribute-to-the-vulnerability-knowledge-base","text":"https://github.com/SAP/vulnerability-assessment-tool relies on a database with detailed information about vulnerable code (methods, functions, etc.) in open-source software libraries. This information is built by analyzing the source code changes (commits) done by open-source developers to fix a given vulnerability. In order to reflect new vulnerability disclosures, one has to analyze those so-called fix commits and add corresponding entries to the local database. This analysis is done using the PatchAnalyzer , which takes several arguments as input, e.g., the source code repository of the respective component, the commit identifier(s), and a vulnerability identifier. In order to prevent that each and every tool user has to collect this information by himself, we aim at creating a shared knowledge base that can be maintained and used by multiple parties. This knowledge base will be a dedicated GitHub repository, where people can upload new input information for the PatchAnalyzer . This section will be updated once this repository is available and the PatchAnalyzer has been updated to read/write to this GitHub repo.","title":"Contribute to the Vulnerability Knowledge Base"},{"location":"contributor/manuals/","text":"","title":"Home"},{"location":"contributor/manuals/languages/","text":"ANTLR grammar \u00b6 Vulas uses ANTLR to parse Java and Python source code. Grammars are downloaded from https://github.com/antlr/grammars-v4 and put into directory src/main/antlr4 (in subdirectories matching the target Java package namespace of the generated parsers, e.g., com/sap/psr/vulas/java/antlr for Java). The actual Java classes are generated by the ANTLR plugin org.antlr:antlr4-maven-plugin . Python \u00b6 Grammars https://github.com/antlr/grammars-v4/tree/master/ ... and https://github.com/antlr/grammars-v4/tree/master/python3 are put into the modules lang-python , folder src/main/antlr4/com/sap/psr/vulas/python/antlr/python3 and python355 . The default parser has been generated from the Python 3.3.5 grammar, including for Python 2 source code. Which parser is taken at runtime depends on the presence of language features specific to Python 2 (e.g., raw_input ) and Python 3.5 (e.g., async ), see Java class PythonFileAnalyzer in module lang-python .","title":"ANTLR grammar"},{"location":"contributor/manuals/languages/#antlr-grammar","text":"Vulas uses ANTLR to parse Java and Python source code. Grammars are downloaded from https://github.com/antlr/grammars-v4 and put into directory src/main/antlr4 (in subdirectories matching the target Java package namespace of the generated parsers, e.g., com/sap/psr/vulas/java/antlr for Java). The actual Java classes are generated by the ANTLR plugin org.antlr:antlr4-maven-plugin .","title":"ANTLR grammar"},{"location":"contributor/manuals/languages/#python","text":"Grammars https://github.com/antlr/grammars-v4/tree/master/ ... and https://github.com/antlr/grammars-v4/tree/master/python3 are put into the modules lang-python , folder src/main/antlr4/com/sap/psr/vulas/python/antlr/python3 and python355 . The default parser has been generated from the Python 3.3.5 grammar, including for Python 2 source code. Which parser is taken at runtime depends on the presence of language features specific to Python 2 (e.g., raw_input ) and Python 3.5 (e.g., async ), see Java class PythonFileAnalyzer in module lang-python .","title":"Python"},{"location":"contributor/support/faq/","text":"","title":"Faq"},{"location":"contributor/support/faq_sap/","text":"","title":"Faq sap"},{"location":"contributor/support/getting_help/","text":"Getting help \u00b6","title":"Getting help"},{"location":"contributor/support/getting_help/#getting-help","text":"","title":"Getting help"},{"location":"contributor/tutorials/new_lang/","text":"Support new language \u00b6 Info This tutorial is under construction, the information provided is expected to be incomplete... Extending Vulas to cover new languages requires the following steps: Extend enumerations comprised in component shared Create a new component lang-xyz that is able to extract all constructs from source and compiled code as well as packages of the respective programming language Add RUNTIME dependencies on lang-xyz to the client-side scan tools and patch-analyzer Extend the enumerations \u00b6 Extend enumeration com.sap.psr.vulas.shared.enums.ProgrammingLanguage to cover the new programming language. Right now, there exist the three values JAVA , PY (Python) and JS (JavaScript). However, even if the enumeration value for JavaScript exists, the other parts have not been implemented yet (see next sections). Create new component lang-xyz \u00b6 Create a new Maven module lang-xyz and add it to the root pom.xml . You can use lang-python as a template. The purpose of the component is to extract all constructs of source and compiled code as well as packaged artifacts (e.g., wheels in Python). ...","title":"Support new language"},{"location":"contributor/tutorials/new_lang/#support-new-language","text":"Info This tutorial is under construction, the information provided is expected to be incomplete... Extending Vulas to cover new languages requires the following steps: Extend enumerations comprised in component shared Create a new component lang-xyz that is able to extract all constructs from source and compiled code as well as packages of the respective programming language Add RUNTIME dependencies on lang-xyz to the client-side scan tools and patch-analyzer","title":"Support new language"},{"location":"contributor/tutorials/new_lang/#extend-the-enumerations","text":"Extend enumeration com.sap.psr.vulas.shared.enums.ProgrammingLanguage to cover the new programming language. Right now, there exist the three values JAVA , PY (Python) and JS (JavaScript). However, even if the enumeration value for JavaScript exists, the other parts have not been implemented yet (see next sections).","title":"Extend the enumerations"},{"location":"contributor/tutorials/new_lang/#create-new-component-lang-xyz","text":"Create a new Maven module lang-xyz and add it to the root pom.xml . You can use lang-python as a template. The purpose of the component is to extract all constructs of source and compiled code as well as packaged artifacts (e.g., wheels in Python). ...","title":"Create new component lang-xyz"},{"location":"contributor/tutorials/project_structure/","text":"Project structure \u00b6 The following picture shows all of the components (modules) of the Maven project hosted at https://github.com/SAP/vulnerability-assessment-tool . Each component visible in the picture corresponds to a module listed in the pom.xml . The component (module) dependencies shown are of three kinds: Dependencies with Maven scopes COMPILE or RUNTIME and REST calls happening at runtime. The project comprises the following client-side tools to scan Java and Python applications. All of those run on a client, typically a Jenkins build server or a developer work station. plugin-maven scans Java applications developed with Java and Maven (based on the application-specific pom.xml ) plugin-gradle scans Java applications developed with Java and Gradle (based on the application-specific build.gradle ) cli-scanner scans both Java and Python applications (based on code present in the file system) plugin-setuptools scans Python applications (based on the application-specific setup.py ). Important : This component is not yet part of the GitHub repo https://github.com/SAP/vulnerability-assessment-tool . Those client-side tools have just one COMPILE dependency on the language-agnostic component lang , which comprises a number of general functionality related to, for instance, backend connectivity or language-agnostic goals such as clean or report . The client-side tools also have RUNTIME dependencies on language-specific components. The motivation to use RUNTIME dependencies is to keep the client-side tools free of language-specific code. The project comprises the following frontends, all of them developed using OpenUI5 : frontend-apps is used by application developers to check scan results or their application frontend-bugs is used by administrators to check and maintain bug information frontend-patch-analyzer is used by administrators to trigger the analysis of fix commits. Important : This component is outdated, the analysis of fix commits is done using the patch-analyzer command-line tool. The language-specific component comprise all the logic to analyze source and compiled code as well as the various package formats of the respective programming language, e.g., JARs and WARs in case of Java. For Java, there also exist several modules related to the static analysis, namely lang-java-reach , lang-java-reach-wala and lang-java-reach-soot . There exist the following two server-side components, both of them exposing a RESTful interface browsable through Swagger: rest-backend is connected to a PostgreSQL database in order to store and join vulnerability information and application analysis results rest-lib-utils analyses Java archives in order to, for instance, obtain Abstract Syntax Trees for Java methods comprises in given Maven artifacts The remaining components are as follows: repo-client supports interactions with Git and SVN repositories patch-lib-analyzer determines whether open source components comprise the affected (vulnerable) or the fixed version of a given methods shared comprises utilities, model classes used for (de)serialization and other general functionality relevant for all other components patch-analyzer examines the fix commit(s) of a given vulnerability in order to understand which methods have been changed in order to fix the vulnerability","title":"Project structure"},{"location":"contributor/tutorials/project_structure/#project-structure","text":"The following picture shows all of the components (modules) of the Maven project hosted at https://github.com/SAP/vulnerability-assessment-tool . Each component visible in the picture corresponds to a module listed in the pom.xml . The component (module) dependencies shown are of three kinds: Dependencies with Maven scopes COMPILE or RUNTIME and REST calls happening at runtime. The project comprises the following client-side tools to scan Java and Python applications. All of those run on a client, typically a Jenkins build server or a developer work station. plugin-maven scans Java applications developed with Java and Maven (based on the application-specific pom.xml ) plugin-gradle scans Java applications developed with Java and Gradle (based on the application-specific build.gradle ) cli-scanner scans both Java and Python applications (based on code present in the file system) plugin-setuptools scans Python applications (based on the application-specific setup.py ). Important : This component is not yet part of the GitHub repo https://github.com/SAP/vulnerability-assessment-tool . Those client-side tools have just one COMPILE dependency on the language-agnostic component lang , which comprises a number of general functionality related to, for instance, backend connectivity or language-agnostic goals such as clean or report . The client-side tools also have RUNTIME dependencies on language-specific components. The motivation to use RUNTIME dependencies is to keep the client-side tools free of language-specific code. The project comprises the following frontends, all of them developed using OpenUI5 : frontend-apps is used by application developers to check scan results or their application frontend-bugs is used by administrators to check and maintain bug information frontend-patch-analyzer is used by administrators to trigger the analysis of fix commits. Important : This component is outdated, the analysis of fix commits is done using the patch-analyzer command-line tool. The language-specific component comprise all the logic to analyze source and compiled code as well as the various package formats of the respective programming language, e.g., JARs and WARs in case of Java. For Java, there also exist several modules related to the static analysis, namely lang-java-reach , lang-java-reach-wala and lang-java-reach-soot . There exist the following two server-side components, both of them exposing a RESTful interface browsable through Swagger: rest-backend is connected to a PostgreSQL database in order to store and join vulnerability information and application analysis results rest-lib-utils analyses Java archives in order to, for instance, obtain Abstract Syntax Trees for Java methods comprises in given Maven artifacts The remaining components are as follows: repo-client supports interactions with Git and SVN repositories patch-lib-analyzer determines whether open source components comprise the affected (vulnerable) or the fixed version of a given methods shared comprises utilities, model classes used for (de)serialization and other general functionality relevant for all other components patch-analyzer examines the fix commit(s) of a given vulnerability in order to understand which methods have been changed in order to fix the vulnerability","title":"Project structure"},{"location":"user/","text":"Docs \u00b6 Step by step tutorials Here you can find detailed, hands-on guidance on how to setup and use Vulas, starting from your very first scan, through the use of the advanced features (such as reachability analysis and mitigation support). We also have tutorials dedicated to automating Vulas scans with Jenkins or other continuous integration systems, and more are coming. Go to the Tutorials page User Manual The manual contains a comprehensive description of all aspects of Vulas from the perspective of users. If you followed the tutorials and still have questions on some specific topic, this is where you will most likely find your answers. Go to the User Manual Getting Help If the tutorials and the manual could not help you with a specific problem you are facing, the support pages are what you should check out next. Go to the User Support page","title":"Docs"},{"location":"user/#docs","text":"Step by step tutorials Here you can find detailed, hands-on guidance on how to setup and use Vulas, starting from your very first scan, through the use of the advanced features (such as reachability analysis and mitigation support). We also have tutorials dedicated to automating Vulas scans with Jenkins or other continuous integration systems, and more are coming. Go to the Tutorials page User Manual The manual contains a comprehensive description of all aspects of Vulas from the perspective of users. If you followed the tutorials and still have questions on some specific topic, this is where you will most likely find your answers. Go to the User Manual Getting Help If the tutorials and the manual could not help you with a specific problem you are facing, the support pages are what you should check out next. Go to the User Support page","title":"Docs"},{"location":"user/manuals/","text":"User Manual \u00b6 Configuration \u00b6 This section of the manual explains in detail how to setup Vulas and how to configure it. Analysis \u00b6 This section covers all the commands (a.k.a, goals ) offered by Vulas, including those related to the analysis ( app , a2c , t2c , instr , test ) and the data management and reporting ( upload , report , clean , cleanspace ) Frontend \u00b6 Here you will find a detailed description (including annotated screenshots) of all the functionality exposed by the different views of the Vulas web frontend. Report \u00b6 Coming soon! Assessment and Mitigation \u00b6 This section explains in detail how to assess the findings of Vulas and how to proceed to mitigate them. Annex: Vulas at SAP Guide \u00b6 This annex covers settings, functionality and practices that are specific to SAP.","title":"Intro"},{"location":"user/manuals/#user-manual","text":"","title":"User Manual"},{"location":"user/manuals/#configuration","text":"This section of the manual explains in detail how to setup Vulas and how to configure it.","title":"Configuration"},{"location":"user/manuals/#analysis","text":"This section covers all the commands (a.k.a, goals ) offered by Vulas, including those related to the analysis ( app , a2c , t2c , instr , test ) and the data management and reporting ( upload , report , clean , cleanspace )","title":"Analysis"},{"location":"user/manuals/#frontend","text":"Here you will find a detailed description (including annotated screenshots) of all the functionality exposed by the different views of the Vulas web frontend.","title":"Frontend"},{"location":"user/manuals/#report","text":"Coming soon!","title":"Report"},{"location":"user/manuals/#assessment-and-mitigation","text":"This section explains in detail how to assess the findings of Vulas and how to proceed to mitigate them.","title":"Assessment and Mitigation"},{"location":"user/manuals/#annex-vulas-at-sap-guide","text":"This annex covers settings, functionality and practices that are specific to SAP.","title":"Annex: Vulas at SAP Guide"},{"location":"user/manuals/analysis/","text":"Analysis Manual \u00b6 Overview \u00b6 The various client-side tools offer so-called goals in order to analyze applications and interact with the backend. The following goals perform some sort of application analysis: app : Creates a method-level bill of material of an application and all its dependencies. a2c : Builds a call graph (starting from app methods) and checks whether vulnerable code is potentially executable (reachable). test : This is not an actual goal implemented by any of the clients, but describes the collection of execution traces by a so-called Java agent that dynamically instruments Java bytecode during JUnit and integration tests. instr : Produces a modified version of Java archives ( static instrumentation ) that can be deployed/executed in order to collect traces of actual method executions. t2c : Builds a call graph (starting from traced methods) and checks whether vulnerable code is potentially reachable from those. The following goals are related to data management and reporting: upload : Uploads analysis data previously written to disk to the backend report : Downloads analysis data from the backend to the client, produces a result report (HTML, XML, JSON), and throws a build exception in order to break Jenkins jobs clean : Cleans the analysis data of a single app in the backend cleanspace : Cleans an entire workspace in the backend Which goals are supported by the different clients, and how-to configure and execute them is explained in the following subsections. Note that all goal executions (including configuration settings and statistics) are shown on the \"History\" tab of the respective applications. Important: Make sure to understand the following before proceeding: app has to be executed before all the other analysis goals in order to detect all application dependencies with vulnerable code. Once it has been run, the assessment of findings can already start, each finding of app shown on the \"Vulnerabilities\" tab corresponds to a dependency of an application on a component with a known security vulnerability. The number of findings will not change when running other analysis goals. Instead, a2c , test and t2c try to collect evidence concerning the potential or actual execution of vulnerable code brought up by app . Assess every finding, no matter whether a2c , test and t2c were able to collect evidence or not. Not finding such evidence does not mean that vulnerabilities cannot be exploited. The absence of proof is not a proof of absence (of exploitable vulnerabilities). Prerequisites: A workspace has been created and its token is known Java 7 or later is installed Maven: The plugin is available in the local .m2 repository or in a Nexus repository configured in settings.xml (see here for more information on how to configure Maven) Limitations : The reachability analysis (goals a2c and t2c ) does not work with Java 9, as the underlying analysis frameworks do not support it. Prerequisites A workspace has been created and its token is known Java 7 or later is installed Maven: The Vulas Maven plugin must be available in the local .m2 repository or in a Nexus repository configured in settings.xml (see here for more information on how to configure Maven) Java 9 support The reachability analysis (goals a2c and t2c ) is not supported with Java 9, due to limitations of the 3 rd -party analysis frameworks that Vulas relies upon. Bill of material analysis (app) \u00b6 Objective Create a complete bill of material (BOM) of the application and of all its dependencies (direct and transitive). Most importantly, the BOM comprises the signatures of all methods of the application and all dependencies, which is compared with a list of methods known to be vulnerable. Moreover, the BOM also comprises meta-info on archive level, e.g., the manifest file entries or the archive's digest (SHA1 in case of Java archives, MD5 in case of Python). Result In the Vulas frontend, the table in tab \"Dependencies\" is populated. In case any of the dependencies has vulnerabilities, they are shown in tab \"Vulnerabilities\". The column \"Inclusion of vulnerable code\" indicates whether the version in use is known to be vulnerable or not (see tooltip for more information). Important By default, the Maven plugin searches for application source and compiled code in the folders src/main/java and target/classes . If source or byte code is generated or modified during the build process, and stored in other folders than the ones mentioned, you need to add those directories using the parameter vulas.core.app.sourceDir . Otherwise, the respective code will not be recognized as application code, hence, ignored when performing the reachability analysis. Example: Suppose source code is generated into the folder target/generated-sources . If this code is compiled into the folder target/classes , you do not need to do anything. If it is compiled into a different folder, you would need to add this folder to entries of vulas.core.app.sourceDir . Run as follows CLI java -jar vulas-cli-3.0.12-jar-with-dependencies.jar -goal app Maven mvn -Dvulas compile vulas:app Gradle ./gradlew assemble vulasApp Configure as follows # Where application source or bytecode and application dependencies (JAR and/or WAR files) are located # Relative or absolute paths, multiple values to be separated by comma vulas.core.app.sourceDir = # Whether or not empty apps (w/o constructs and dependencies) are uploaded to the backend vulas.core.app.uploadEmpty = false # When true, JAR not known to Vulas Maven central and not already available to the backend are posted to the backend vulas.core.app.uploadLibrary = false # Number of worker threads analyzing the JAR files from which classes are loaded vulas.core.jarAnalysis.poolSize = 4 # Package prefix(es) of application code (multiple values to be separated by comma) # Default: # CLI: - # Note: Ignored when running the Maven plugin. In all other cases it avoids the separation of application and dependency JARs into distinct folders vulas.core.app.appPrefixes = # Regex that identifies JARs with application code (multiple values to be separated by comma) # Default: # CLI: - # Note: Ignored when running the Maven plugin. In all other cases it avoids the separation of application and dependency JARs into distinct folders vulas.core.app.appJarNames = Reachable from app (a2c) \u00b6 Objectives Check whether vulnerable methods are reachable, i.e., whether the application can be run in a way that a vulnerable method is executed. Identify all so-called touch points, which are direct calls from an application method to a library method. Collect all reachable methods for every dependency of the application. The first objective supports the risk assessment for a given vulnerability, while the second and third objectives primarily support the mitigation. Depending on the size of the application, the reachability analysis can consume a considerable amount of resources (time and memory). It is not seldom that it runs for several hours. Limitations Python is not supported Java 9 and later versions are not supported by the underlying frameworks Result In the Vulas frontend, tab \"Vulnerabilities\", the column \"Static Analysis\" is populated for all libraries subject to known vulnerabilities. By selecting single row of this table and the one of the detailed page, one can get more information up until the paths of potential executions (if any). How does it work Vulas uses Wala or Soot, both static analysis frameworks for Java, in order to construct a call graph representing all possible program executions starting from application methods. This graph is traversed in order to see whether and from where methods with known vulnerabilities can be reached. Run as follows CLI java -Xmx8g -Xms2g -jar vulas-cli-3.0.12-jar-with-dependencies.jar -goal a2c Maven export MAVEN_OPTS = \"-Xmx8g -Xms2g\" mvn -Dvulas compile vulas:a2c Gradle ./gradlew assemble vulasA2C Configure as follows # Limits the analysis to certain bugs (multiple values separated by comma) # If empty, all relevant bugs retrieved from backend will be considered # Default: empty vulas.reach.bugs = # Analysis framework to be used # Possible values: wala, soot vulas.reach.fwk = wala # Regex to filter entry points (semicolon separated) vulas.reach.constructFilter = # All packages to be excluded from call graph construction, packages # are separated by semicolon e.g. [java/.*;sun/.*]. Defaults for the different # analysis frameworks are provided in the respective configuration files. --> vulas.reach.excludePackages = # All JAR files to be excluded from call graph construction (multiple entries to be separated by comma) # # Default: WebServicesAgent.jar (from Wily Introscope, an app perf monitoring tool that has invalid manifest header fields creating problems for Wala) vulas.reach.excludeJars = WebServicesAgent.jar # Dir to search for app source files (only vulas:a2c) # If empty, they will be fetched from backend vulas.reach.sourceDir = # Timeout for reachability analysis (in mins) # Default: 120 mins vulas.reach.timeout = 120 # Max number of paths uploaded for a reachable change list element vulas.reach.maxPathPerChangeListElement = 10 # Whether or not to collect touch points # Default: true vulas.reach.identifyTouchpoints = true # Whether to search for the shortest path(s) from entry points to vulnerable constructs, or to quit after the first path found # Default: true vulas.reach.searchShortest = true Call graph construction framework Behind the scene, a source code analysis framework is used to construct the call graph, either starting from application methods ( a2c ) or from traced methods ( t2c ). Right now, the two frameworks Wala and Soot are supported and can be configured with vulas.reach.fwk . Both offer several configuration options to influence the accuracy of the call graph and its construction time. Once the call graph has been constructed, its size (in terms of nodes and edges) is printed to the console, which is useful for comparing the impact of the different configuration options, e.g. [vulas-reach-1] INFO com.sap.psr.vulas.cg.wala.WalaCallgraphConstructor - Normalized call graph has [167639 nodes] (with distinct ConstructId) and [1279495 edges] WALA The setting vulas.reach.wala.callgraph.algorithm determines the construction algorithm to be used. From RTA (Rapid Type Analysis) to 0-1-ctn-CFA , the call graph becomes more accurate, but the construction takes more time. A more accurate call graph means that it contains less false-positives, i.e., method invocations that cannot happen during actual program execution. As a rule of thumb, a call graph constructed with RTA contains more nodes and edges than one constructed with 0-1-ctn-CFA . Note the following before choosing a more simple algorithm: The increase of nodes and edges resulting from, for instance, the choice of RTA, has a negative impact on the performance of the later analysis phases. As such, it may be worth to spend more time on the graph construction. See here , there and there for more information regarding the difference of call graph construction algorithms. # Possible values: 0-CFA; 0-ctn-CFA; vanilla-0-1-CFA; 0-1-CFA; 0-1-ctn-CFA # Default algorithm: 0-1-CFA vulas.reach.wala.callgraph.algorithm = 0-1-CFA The setting vulas.reach.wala.callgraph.reflection determines the consideration of reflection, which is commonly used to instantiate and invoke classes and methods. See here for more information. # Reflection option to be used for call graph construction # Possible values: FULL; NO_METHOD_INVOKE; NO_STRING_CONSTANTS; APPLICATION_GET_METHOD # Possible values: NONE; NO_FLOW_TO_CASTS; NO_FLOW_TO_CASTS_NO_METHOD_INVOKE; ONE_FLOW_TO_CASTS_NO_METHOD_INVOKE; NO_FLOW_TO_CASTS_APPLICATION_GET_METHOD; ONE_FLOW_TO_CASTS_APPLICATION_GET_METHOD # Default value: NO_FLOW_TO_CASTS_NO_METHOD_INVOKE vulas.reach.wala.callgraph.reflection = NO_FLOW_TO_CASTS_NO_METHOD_INVOKE Soot TODO Dynamic instrumentation (JUnit) \u00b6 Objective Collect method traces during the execution of JUnit tests. Information about traced methods will be compared with methods subject to known vulnerabilities. Limitations Python is not supported Result In the Vulas frontend, tab \"Vulnerabilities\", the column \"Dynamic Analysis\" is populated for all libraries subject to known vulnerabilities. By selecting single row of this table and the one of the detailed page, one can get more information up until the paths of actual executions (if any). In the Vulas frontend, tab \"Test coverage\", the number of traced vs. the number of total methods is shown per Java package of the application. How does it work Vulas collects runtime information during application execution, most importantly whether a vulnerable method has been called and the corresponding call stack. In order to collect this information, the byte code of the application and all its dependencies has to be changed, which can be achieved either dynamically or statically: In case of dynamic instrumentation , the byte code of a given Java class is changed at the time the class definition is loaded for the first time, e.g., during the execution of JUnit tests or integration tests. Vulas injects statements in order to save the timestamp of every method invocation as well as stack trace information. Per default, this information is saved in folder target/vulas/upload and uploaded using the goal vulas:upload . To that end, Vulas must be registered using the JVM option -javaagent . In case of JUnit tests, the agent is registered by the Maven goal prepare-vulas-agent . In case of static instrumentation , the byte code of classes residing in the file system is changed, e.g., the WAR file of a deployable Web application. This is done with help of the goal vulas:instr (see below). Run as follows Maven mvn -Dvulas vulas:prepare-vulas-agent test vulas:upload Configure as follows # Byte code instrumentor(s) to be used (multiple ones to be separated by comma) # # Possible values: # com.sap.psr.vulas.monitor.trace.SingleTraceInstrumentor: Collects exactly one timestamp for every invoked vulnerable method (no call stack) # com.sap.psr.vulas.monitor.trace.SingleStackTraceInstrumentor: Collects at most \"vulas.core.instr.maxStacktraces\" call stack for every invoked vulnerable method # com.sap.psr.vulas.monitor.trace.StackTraceInstrumentor: Collects all call stacks for every invoked vulnerable method # com.sap.psr.vulas.monitor.touch.TouchPointInstrumentor: Collects so-called touch points, i.e., calls from an app method to a library method # # Default: com.sap.psr.vulas.monitor.trace.SingleTraceInstrumentor # # Note: # The above list of possible values is ordered ascending after performance impact and memory consumption, # i.e., the SingleTraceInstrumentor has the least impact on performance and memory consumption vulas.core.instr.instrumentorsChoosen = com.sap.psr.vulas.monitor.trace.SingleTraceInstrumentor # Max. number of stacktraces collected per instrumented vulnerable method # Default: 10 # Note: Only applies to SingleStackTraceInstrumentor vulas.core.instr.maxStacktraces = 10 # JARs in the following directories (or its subdirs) will not be instrumented #vulas.core.instr.blacklist.dirs = # Constructs of dependencies having one of the following scope(s) will not be instrumented (multiple ones to be separated by comma) # Default: test, provided # Note: Only applies to Vulas Maven plugin; in case of Vulas CLI, all dependencies have scope RUNTIME vulas.core.instr.blacklist.jars.ignoreScopes = test, provided # User-provided blacklist: Constructs of dependencies whose filename matches one of the following regular expressions will not be instrumented (multiple ones to be separated by comma) # Default: - # Note: Those are on top of \"vulas.core.instr.blacklist.jars\" vulas.core.instr.blacklist.jars.custom = # User-provided Java packages whose constructs are not instrumented (multiple ones to be separated by comma) # Default: - # Note: Those are on top of \"vulas.core.instr.blacklist.classes.jre\" and \"vulas.core.instr.blacklist.classes\" vulas.core.instr.blacklist.classes.custom = # If true, bytecode and instrumentation code will be written to tmpDir vulas.core.instr.writeCode = false # JARs for which no traces and no archive information will be uploaded (e.g., from Vulas itself) # Multiple entries are separated by comma, each entry is a regex vulas.core.monitor.blacklist.jars = lang-java-.*\\.jar,vulas-core-.*\\.jar,surefire-.*\\.jar,junit-.*\\.jar,org.jacoco.agent.*\\.jar # Enables or disables the periodic upload of collected traces to the backend # Default: true # Note: Set to FALSE in case of JUnit tests vulas.core.monitor.periodicUpload.enabled = true # Interval (in millisecs) between periodic uploads # Default: 300000 (5 min) vulas.core.monitor.periodicUpload.interval = 300000 # Max. number of traces uploaded by each periodic upload # Default: 1000 vulas.core.monitor.periodicUpload.batchSize = 1000 # Max number of items (traces, paths, touch points, etc.) collected # Default: -1 (no limit) vulas.core.monitor.maxItems = -1 Dynamic instrumentation (JVM) \u00b6 Objective Collect method traces during the actual execution of the application. Information about traced methods will be compared with methods subject to known vulnerabilities. Limitations Python is not supported Result Same as in previous section How does it work By registering a Java agent at JVM startup, Vulas changes the bytecode of every Java class loaded at runtime. For example, it injects Java statements in order to save the timestamp of every method invocation as well as stack trace information. This information is periodically uploaded to the Vulas backend. Run as follows Download the file lang-java-3.0.12-jar-with-dependencies.jar to your computer (CLI users can take it from the folder ./instr ). Add the following arguments to the Java runtime (and replace line breaks by a single space characters). -javaagent:lang-java-3.0.12-jar-with-dependencies.jar -Dvulas.shared.backend.serviceUrl=http://vulas.mo.sap.corp:8080/backend -Dvulas.core.backendConnection=READ_WRITE -Dvulas.core.monitor.periodicUpload.enabled=true -Dvulas.core.appContext.group=<GROUP> -Dvulas.core.appContext.artifact=<ARTIFACT> -Dvulas.core.appContext.version=<VERSION> -Dvulas.core.instr.instrumentorsChoosen=com.sap.psr.vulas.monitor.trace.SingleTraceInstrumentor -Dvulas.core.space.token=<WORKSSPACE-TOKEN> -noverify Start the application and perform some application-specific tests and workflows. Example In case of Tomcat 8.x, one needs to (1) copy lang-java-3.0.12-jar-with-dependencies.jar into the folder ./bin and (2) specify the variable CATALINA_OPTS as follows in the file ./bin/setenv.bat . Do not forget to specify <GROUP> , <ARTIFACT> and <VERSION> for the application under analysis. Note: The use of setenv.bat does not work if Tomcat is run as Windows service. CLI set \"CATALINA_OPTS=-javaagent:lang-java-3.0.12-jar-with-dependencies.jar -Dvulas.shared.backend.serviceUrl=http://vulas.mo.sap.corp:8080/backend -Dvulas.core.backendConnection=READ_WRITE -Dvulas.core.monitor.periodicUpload.enabled=true -Dvulas.core.appContext.group=<GROUP> -Dvulas.core.appContext.artifact=<ARTIFACT> -Dvulas.core.appContext.version=<VERSION> -Dvulas.core.instr.instrumentorsChoosen=com.sap.psr.vulas.monitor.trace.SingleTraceInstrumentor -noverify\" Static instrumentation (instr) \u00b6 Objective Modify an existing JAR (WAR) created by mvn package so that traces will be collected once the JAR is executed (the WAR is deployed in a Web application container such as Tomcat). Note: In contrast to what is described in the previous section \"Integration Tests\", vulas:instr will not result in the collection of traces for Tomcat itself. Prerequisite An application's JAR or WAR, e.g., as created with mvn package in folder target . Limitations Python is not supported Result A new JAR/WAR with suffix -vulas-instr will be created in folder target/vulas/target . How does it work The bytecode of all the Java classes found in the JAR (WAR) will be modified as to collect information about, for instance, method execution and stack traces. This information will be uploaded to the backend if the JAR (WAR) is executed. Note: The modified code in the new JAR with suffix -vulas-instr can be inspected with decompilers such as JD-GUI . Run as follows Maven mvn package mvn -Dvulas vulas:instr Troubleshooting The console shows compilation errors, e.g., cannot find javax.servlet.http.HttpServletRequest . The reason is that all application dependencies are re-compiled, and it can happen that some of the classes do have dependency requirements not met by the application. This can be overcome by identifying the respective JAR file and downloading it to the folder target/vulas/lib . Reachable from traces (t2c) \u00b6 Objective Understand whether vulnerable methods can be potentially reached from traced methods. Prerequisite Traces must have been collected during JUnit or integration tests (see above) Limitations Python is not supported Java 9 and later versions are not supported by the underlying frameworks Result In the Vulas frontend, tab \"Vulnerabilities\", the column \"Static Analysis\" is populated for all libraries subject to known vulnerabilities. By selecting single row of this table and the one of the detailed page, one can get more information up until the paths of potential executions (if any). How does it work In contrast to the goal a2c , the callgraph is built starting from all methods that were previously traced. As such, the call graph construction overcomes weaknesses of static source analysis related to the use of reflection and control inversion. What remains the same is that the resulting graph is traversed in order to see whether and from where methods with known vulnerabilities can be reached. Run as follows CLI java -jar vulas-cli-jar-with-dependencies.jar -goal t2c Maven mvn -Dvulas vulas:t2c Configure as follows # Limits the analysis to certain bugs (multiple values separated by comma) # If empty, all relevant bugs retrieved from backend will be considered # Default: empty vulas.reach.bugs = # Analysis framework to be used # Possible values: wala, soot vulas.reach.fwk = wala # Regex to filter entry points (semicolon separated) vulas.reach.constructFilter = # All packages to be excluded from call graph construction, packages # are separated by semicolon e.g. [java/.*;sun/.*]. Defaults for the different # analysis frameworks are provided in the respective configuration files. --> vulas.reach.excludePackages = # All JAR files to be excluded from call graph construction (multiple entries to be separated by comma) # # Default: WebServicesAgent.jar (from Wily Introscope, an app perf monitoring tool that has invalid manifest header fields creating problems for Wala) vulas.reach.excludeJars = WebServicesAgent.jar # Dir to search for app source files (only vulas:a2c) # If empty, they will be fetched from backend vulas.reach.sourceDir = # Timeout for reachability analysis (in mins) # Default: 120 mins vulas.reach.timeout = 120 # Max number of paths uploaded for a reachable change list element vulas.reach.maxPathPerChangeListElement = 10 # Whether or not to collect touch points # Default: true vulas.reach.identifyTouchpoints = true # Whether to search for the shortest path(s) from entry points to vulnerable constructs, or to quit after the first path found # Default: true vulas.reach.searchShortest = true Upload analysis files (upload) \u00b6 Objective Uploads analysis data in folder vulas.core.uploadDir to the backend. Such data is only written if the parameter vulas.core.backendConnection is set to OFFLINE or READ_ONLY . By default, this is only the case for the instrumentation of JUnit or integration tests. Configure as follows # When true, serialized HTTP requests will be deleted after the upload succeeded (incl. the JSON files) # Default: true vulas.core.upload.deleteAfterSuccess = true Run as follows CLI java -Dvulas.core.appContext.group = <GROUP> -Dvulas.core.appContext.artifact = <ARTIFACT> -Dvulas.core.appContext.version = 3 .0.12 -jar vulas-cli-jar-with-dependencies.jar -goal upload Maven mvn -Dvulas vulas:upload Create result report (report) \u00b6 Objective Creates result reports in HTML, XML and JSON format (on the basis of analysis results downloaded from the Vulas backend). Additionally, the Maven and Gradle plugins can be configured to throw a build exception in order break Jenkins jobs and pipelines in case vulnerable code is present (or reachable/executed). The HTML report can be copied into a Jenkins dashboard using the HTML Publisher Plugin (see automation for a configuration example). Multi-module Maven projects The report goal should be called in a separate build step, e.g., mvn -Dvulas vulas:report . It must NOT be called together with other goals, e.g., mvn -Dvulas compile vulas:app vulas:report , because the build may fail before app and other goals are executed for all the modules. Alternatively, you can use the Maven option --fail-at-end (see here for more info). Result A summary report is written to disk (in HTML, XML and JSON format). For Maven, the target directory of the different files is \"target/vulas/report\", for Gradle it is \"build/vulas/report\". For CLI, the exact location is printed to the console. How does it work Identified vulnerabilities including any information gathered during static and dynamic analysis will be downloaded from the backend. Configure as follows # A vulnerability in blacklisted scopes will not cause an exception (multiple scopes to be separated by comma) # Default: test, provided # Note: For CLI, all dependencies are considered as RUNTIME dependencies vulas.report.exceptionScopeBlacklist = TEST, PROVIDED # Specified vulnerabilities will not cause a build exception (multiple bugs to be separated by comma) # Default: - vulas.report.exceptionExcludeBugs = <vuln-id> # Explanation why the given vulnerability is not relevant/exploitable in the specific application context # Default: - vulas.report.exceptionExcludeBugs.<vuln-id> = Not exploitable because ... # Determines whether un-assessed vulnerabilities (e.g. vulnerabilities marked with an orange hourglass symbol) throw a build exception. Un-assessed vulns are those where # the method signature(s) of a bug appear in an archive, however, it is yet unclear whether the methods # exist in the fixed or vulnerable version. Those findings are marked with a question mark in the frontend. # # Possible values: # all: All un-assessed vulns will be ignored # known: Only un-assessed vulns in archives known to Maven Central will be ignored # off: Never ignore # # Default: all vulas.report.exceptionExcludeUnassessed = all # Specifies whether a build exception is thrown when vulnerable code is included, potentially # reachable, actually reached or not at all # Possible values: noException < dependsOn < potentiallyExecutes < actuallyExecutes # noException : no build exception even if vulnerable code is included # dependsOn : exception raised when vulnerable code is included # potentiallyExecutes : exception raised when vulnerable code is potentially executed (result of static analyse) # actuallyExecutes : exception raised when vulnerable code is executed (result of dynamic analyse) # # Default: actuallyExecutes vulas.report.exceptionThreshold = actuallyExecutes # Directory to where the reports (JSON, XML, HTML) will be written to # Default: # CLI: - # MVN: ${project.build.directory}/vulas/report vulas.report.reportDir = Run as follows CLI java -Dvulas.core.appContext.group = <GROUP> -Dvulas.core.appContext.artifact = <ARTIFACT> -Dvulas.core.appContext.version = 3 .0.12 -jar vulas-cli-jar-with-dependencies.jar -goal report Maven mvn -Dvulas vulas:report Gradle ./gradlew vulasReport Exemptions The settings vulas.report.exceptionExcludeBugs and vulas.report.exceptionExcludeBugs.<vuln-id> can be used to capture the results of an audit or assessment by developers in regards to whether a vulnerability is problematic in a given application context. Exempted bugs do not result in build exceptions and are also shown in the apps Web frontend. Build exceptions Other settings to fine-tune the threshold for build exceptions are as follows: vulas.report.exceptionScopeBlacklist can be used to exclude certain Maven scopes (default: test) vulas.report.exceptionThreshold can be used to specify whether a build exception is thrown when vulnerable code is included, potentially reachable, actually reached or not at all (values: noException , dependsOn , potentiallyExecutes , actuallyExecutes ; default: actuallyExecutes ) Clean and delete apps (clean) \u00b6 Objective Deletes application-specific data in the backend, e.g., traces collected during JUnit tests, or application constructs and dependencies collected through the app goal. Right after executing clean for a given application, the apps Web frontend will be empty for the respective application. Configure as follows # When true, details of past goal executions will be deleted # Default: false vulas.core.clean.goalHistory = false # When true, all but the latest X app versions will be deleted (latest according to the application creation date) # Default: false vulas.core.clean.purgeVersions = false # Specifies X, i.e., the number of application versions to be kept if purgeVersions is set to true (0 will delete all versions) # Default: 3 vulas.core.clean.purgeVersions.keepLast = 3 Run as follows to clean the current version : CLI java -jar vulas-cli-jar-with-dependencies.jar -goal clean Maven mvn -Dvulas vulas:clean Run as follows to delete an application including all its versions : CLI java -Dvulas.core.clean.purgeVersions = true -Dvulas.core.clean.purgeVersions.keepLast = 0 -jar vulas-cli-jar-with-dependencies.jar -goal clean Maven mvn -Dvulas -Dvulas.core.clean.purgeVersions = true -Dvulas.core.clean.purgeVersions.keepLast = 0 vulas:clean Critical Maven will fail to delete an application if a corresponding <module> does not exit any longer in the pom.xml . The CLI must be used in these cases and the Maven coordinates (GAV) of the item to be cleaned shall be provided as system properties when calling the CLI. For example, if you want to delete an application with GAV myGroup:myArtifact:myVersion , the following command line should be used java -Dvulas.core.clean.purgeVersions = true -Dvulas.core.clean.purgeVersions.keepLast = 0 -Dvulas.core.appContext.group = myGroup -Dvulas.core.appContext.artifact = myArtifact -Dvulas.core.appContext.version = myVersion -jar vulas-cli-jar-with-dependencies.jar -goal clean Clean workspaces (cleanspace) \u00b6 Objective Deletes all applications of the given space. Run as follows CLI java -jar vulas-cli-jar-with-dependencies.jar -goal cleanSpace Maven mvn -Dvulas vulas:cleanSpace","title":"Analysis"},{"location":"user/manuals/analysis/#analysis-manual","text":"","title":"Analysis Manual"},{"location":"user/manuals/analysis/#overview","text":"The various client-side tools offer so-called goals in order to analyze applications and interact with the backend. The following goals perform some sort of application analysis: app : Creates a method-level bill of material of an application and all its dependencies. a2c : Builds a call graph (starting from app methods) and checks whether vulnerable code is potentially executable (reachable). test : This is not an actual goal implemented by any of the clients, but describes the collection of execution traces by a so-called Java agent that dynamically instruments Java bytecode during JUnit and integration tests. instr : Produces a modified version of Java archives ( static instrumentation ) that can be deployed/executed in order to collect traces of actual method executions. t2c : Builds a call graph (starting from traced methods) and checks whether vulnerable code is potentially reachable from those. The following goals are related to data management and reporting: upload : Uploads analysis data previously written to disk to the backend report : Downloads analysis data from the backend to the client, produces a result report (HTML, XML, JSON), and throws a build exception in order to break Jenkins jobs clean : Cleans the analysis data of a single app in the backend cleanspace : Cleans an entire workspace in the backend Which goals are supported by the different clients, and how-to configure and execute them is explained in the following subsections. Note that all goal executions (including configuration settings and statistics) are shown on the \"History\" tab of the respective applications. Important: Make sure to understand the following before proceeding: app has to be executed before all the other analysis goals in order to detect all application dependencies with vulnerable code. Once it has been run, the assessment of findings can already start, each finding of app shown on the \"Vulnerabilities\" tab corresponds to a dependency of an application on a component with a known security vulnerability. The number of findings will not change when running other analysis goals. Instead, a2c , test and t2c try to collect evidence concerning the potential or actual execution of vulnerable code brought up by app . Assess every finding, no matter whether a2c , test and t2c were able to collect evidence or not. Not finding such evidence does not mean that vulnerabilities cannot be exploited. The absence of proof is not a proof of absence (of exploitable vulnerabilities). Prerequisites: A workspace has been created and its token is known Java 7 or later is installed Maven: The plugin is available in the local .m2 repository or in a Nexus repository configured in settings.xml (see here for more information on how to configure Maven) Limitations : The reachability analysis (goals a2c and t2c ) does not work with Java 9, as the underlying analysis frameworks do not support it. Prerequisites A workspace has been created and its token is known Java 7 or later is installed Maven: The Vulas Maven plugin must be available in the local .m2 repository or in a Nexus repository configured in settings.xml (see here for more information on how to configure Maven) Java 9 support The reachability analysis (goals a2c and t2c ) is not supported with Java 9, due to limitations of the 3 rd -party analysis frameworks that Vulas relies upon.","title":"Overview"},{"location":"user/manuals/analysis/#bill-of-material-analysis-app","text":"","title":"Bill of material analysis (app)"},{"location":"user/manuals/analysis/#reachable-from-app-a2c","text":"","title":"Reachable from app (a2c)"},{"location":"user/manuals/analysis/#dynamic-instrumentation-junit","text":"","title":"Dynamic instrumentation (JUnit)"},{"location":"user/manuals/analysis/#dynamic-instrumentation-jvm","text":"","title":"Dynamic instrumentation (JVM)"},{"location":"user/manuals/analysis/#static-instrumentation-instr","text":"","title":"Static instrumentation (instr)"},{"location":"user/manuals/analysis/#reachable-from-traces-t2c","text":"","title":"Reachable from traces (t2c)"},{"location":"user/manuals/analysis/#upload-analysis-files-upload","text":"","title":"Upload analysis files (upload)"},{"location":"user/manuals/analysis/#create-result-report-report","text":"","title":"Create result report (report)"},{"location":"user/manuals/analysis/#clean-and-delete-apps-clean","text":"","title":"Clean and delete apps (clean)"},{"location":"user/manuals/analysis/#clean-workspaces-cleanspace","text":"","title":"Clean workspaces (cleanspace)"},{"location":"user/manuals/assess_and_mitigate/","text":"Assessment and Mitigation Manual \u00b6 The presence of vulnerable open-source code must be assessed . If the vulnerability IS NOT considered exploitable, it can be exempted . If it IS considered exploitable, it has to be mitigated . Assess \u00b6 You can start to assess Vulas findings as soon as you ran the app analysis goal. Assessing means to clarify whether the respective vulnerability is exploitable in the given application context. The other analysis goals provide further evidence in regards to whether vulnerable code is executable, which is a prerequisite for being exploitable, but they do not bring up new findings. A finding (table row) in the Vulnerabilities tab represents a tuple (library, vulnerability). Depending on whether the library contains the vulnerable or the fixed code , the column Inclusion of vulnerable code contains one of the following icons: Green exclamation mark : The library version in use contains the fixed code for the respective vulnerability, hence, is not affected. Such historical vulnerabilities do not need to be assessed and mitigated. Red exclamation mark : The library version in use contains the vulnerable code, hence, is affected by the respective vulnerability, and the finding requires assessment. A findings should be mitigated if considered exploitable (see below). A finding can be exempted if it is not considered exploitable. Orange Hourglass : It is unclear whether the library version in use contains the vulnerable or the fixed code. Hourglasses are resolved by the Vulas operations team (automatically or manually) by comparing the source or byte code of the library in question with the vulnerable and fixed code. Depending on whether the source or byte code of the library is available, e.g., in Maven Central or PyPi, this can take more or less time. Static and Dynamic Analysis \u00b6 The columns Static Analysis and Dynamic Analysis provide information whether vulnerable code can be potentially executed (according to static call graph construction and analysis), or whether its execution has been observed during the execution of tests. Warning You cannot simply ignore a vulnerability just because no red icon is shown. In other words: We suggest to always look at all vulnerabilities, regardless of whether there are indicators in those two columns. The main reasons are: Deserialization vulnerabilities , whose exploitation does not require that vulnerable code is executed during normal program execution, and the fact that both static and dynamic analyses can also be subject to false-positives and false-negatives. Dependency scope \u00b6 Make sure to understand this important Maven concept, refer to the official documentation for details. Typically, TEST and PROVIDED dependencies are not bundled with your application. In other words, when you or your customers deploy the application, libraries in scope TEST and PROVIDED are not included, therefore, vulnerabilities in these dependencies are less critical for you than those in other scopes (the party operating the platform should address them). Direct vs. transitive dependencies \u00b6 You need to assess vulnerabilities regardless of whether they concern direct or transitive dependencies. The reason is that the exploitability of a vulnerability is independent of this aspect. CVSS score \u00b6 All vulnerabilities shall be assessed, no matter the CVSS score. The severity of open-source vulnerabilities significantly depends on the application-specific context (in which the open-source component is used). Thus, the actual severity can differ significantly from the (context-independent) CVSS base score provided by 3 rd parties such as the Mitre/NVD. Exempt \u00b6 If vulnerable code is NOT considered exploitable in a given application context, the respective finding (or an entire scope) can be exempted. This can be done by specifying additional configuration settings, preferably in a dedicated properties file (e.g., vulas-exemptions.properties ). Keeping exemptions in a dedicated file avoids the risk of making accidental changes to other settings. Storing such a dedicated file in the source code repository of the application under analysis, thus making the file subject to version control, has the advantage of tracking modifications in terms of date and author. The settings required to create exemptions are described in the section report goal . Mitigate \u00b6 If vulnerable code is considered exploitable in a given application context, there are several ways to fix the dependency on the vulnerable open-source component: Remove dependency (ideal) \u00b6 If possible, removing a dependency from your application is the ideal solution. It will not only avoid the dependency on a given library with known vulnerabilities but also reduce (a) the size of your application's deployable artifact and (b) the application's attack surface. The analysis goals a2c , test and t2c can support you in assessing whether or not the removal is possible at all. Running those goals will populate the 2 right-most columns of the table in the Dependencies tab, hence, you will see whether library constructs are potentially executable or actually executed. Direct dependencies can be removed by deleting the respective <dependency> section. Transitive dependencies can be removed by adding an <exclusions> section to the respective direct <dependency> (s), cf. Dependency Exclusions for more details. Update dependency (default) \u00b6 An update is the default solution for fixing a dependency with known-vulnerabilities. It is possible for the majority of vulnerabilities in the Vulas Vulnerability Database. Direct dependencies can be updated by declaring a non-vulnerable version in the respective <dependency> section. Transitive dependencies can be updated by two means: Preferably, by updating the direct <dependency> that is responsible for pulling the vulnerable transitive dependency into your project. Use mvn dependency:tree or the IDE of your choice to identify this to-be-updated direct dependency (cf. screenshot, where the transitive dependency ognl:3.0.6 is pulled in through the direct dependency struts2-core:2.3.24 into the application vulas-testapp-webapp:2.3.8). If there's no updated version of the direct dependency available that solves the problem, you need to declare a direct <dependency> on a non-vulnerable version. This will override the version resulting from the use of the direct dependency. However, as this solution breaks the transparency of the dependency resolution mechanism, it is advisable to add a corresponding comment to your pom.xml or build.gradle and revisit the dependency every now and then. Sometimes, the vulnerable dependency is pulled into your project through a component developed by colleagues. In this case, please ask your colleagues to provide a fixed version that avoids pulling in vulnerable open-source. Like this, every other user of the respective component will be able to solve the problem by a simple update. Fixing the library (exceptional) \u00b6 Best practice This should only be done if the removal or update of the dependency is not possible. Fixing the library means to create a fix for the vulnerability within the source code of the open-source library, which requires a deep understanding of the respective library and vulnerability. If you take that road, make sure to create a pull request so that the original open-source developers check and integrate the fix in the standard. If not, you will need to maintain your fix in the forked version of the library, and any further enhancements of the library will need to be merged into this fork. Fixing the application (exceptional) \u00b6 Best practice This should only be done if the removal or update of the dependency is not possible. Fixing the applications means to introduce a security control in the application that mitigates a problem in a vulnerable library, which requires a deep understanding of the respective vulnerability. Example: Suppose the library in question is vulnerable to XXE processing . If the developers of the respective library do not (cannot) provide a fix, you could introduce a corresponding sanity check in your application, just before XML documents are handed-over to the library. The analysis goals a2c , test and t2c can support you in identifying the application methods that require a safeguard. Ideally, you can see (a subset of) the execution paths that lead from application code to vulnerable library code. See here to learn about the configuration options of the reachability analyses a2c and t2c .","title":"Assessment and Mitigation"},{"location":"user/manuals/assess_and_mitigate/#assessment-and-mitigation-manual","text":"The presence of vulnerable open-source code must be assessed . If the vulnerability IS NOT considered exploitable, it can be exempted . If it IS considered exploitable, it has to be mitigated .","title":"Assessment and Mitigation Manual"},{"location":"user/manuals/assess_and_mitigate/#assess","text":"You can start to assess Vulas findings as soon as you ran the app analysis goal. Assessing means to clarify whether the respective vulnerability is exploitable in the given application context. The other analysis goals provide further evidence in regards to whether vulnerable code is executable, which is a prerequisite for being exploitable, but they do not bring up new findings. A finding (table row) in the Vulnerabilities tab represents a tuple (library, vulnerability). Depending on whether the library contains the vulnerable or the fixed code , the column Inclusion of vulnerable code contains one of the following icons: Green exclamation mark : The library version in use contains the fixed code for the respective vulnerability, hence, is not affected. Such historical vulnerabilities do not need to be assessed and mitigated. Red exclamation mark : The library version in use contains the vulnerable code, hence, is affected by the respective vulnerability, and the finding requires assessment. A findings should be mitigated if considered exploitable (see below). A finding can be exempted if it is not considered exploitable. Orange Hourglass : It is unclear whether the library version in use contains the vulnerable or the fixed code. Hourglasses are resolved by the Vulas operations team (automatically or manually) by comparing the source or byte code of the library in question with the vulnerable and fixed code. Depending on whether the source or byte code of the library is available, e.g., in Maven Central or PyPi, this can take more or less time.","title":"Assess"},{"location":"user/manuals/assess_and_mitigate/#static-and-dynamic-analysis","text":"The columns Static Analysis and Dynamic Analysis provide information whether vulnerable code can be potentially executed (according to static call graph construction and analysis), or whether its execution has been observed during the execution of tests. Warning You cannot simply ignore a vulnerability just because no red icon is shown. In other words: We suggest to always look at all vulnerabilities, regardless of whether there are indicators in those two columns. The main reasons are: Deserialization vulnerabilities , whose exploitation does not require that vulnerable code is executed during normal program execution, and the fact that both static and dynamic analyses can also be subject to false-positives and false-negatives.","title":"Static and Dynamic Analysis"},{"location":"user/manuals/assess_and_mitigate/#dependency-scope","text":"Make sure to understand this important Maven concept, refer to the official documentation for details. Typically, TEST and PROVIDED dependencies are not bundled with your application. In other words, when you or your customers deploy the application, libraries in scope TEST and PROVIDED are not included, therefore, vulnerabilities in these dependencies are less critical for you than those in other scopes (the party operating the platform should address them).","title":"Dependency scope"},{"location":"user/manuals/assess_and_mitigate/#direct-vs-transitive-dependencies","text":"You need to assess vulnerabilities regardless of whether they concern direct or transitive dependencies. The reason is that the exploitability of a vulnerability is independent of this aspect.","title":"Direct vs. transitive dependencies"},{"location":"user/manuals/assess_and_mitigate/#cvss-score","text":"All vulnerabilities shall be assessed, no matter the CVSS score. The severity of open-source vulnerabilities significantly depends on the application-specific context (in which the open-source component is used). Thus, the actual severity can differ significantly from the (context-independent) CVSS base score provided by 3 rd parties such as the Mitre/NVD.","title":"CVSS score"},{"location":"user/manuals/assess_and_mitigate/#exempt","text":"If vulnerable code is NOT considered exploitable in a given application context, the respective finding (or an entire scope) can be exempted. This can be done by specifying additional configuration settings, preferably in a dedicated properties file (e.g., vulas-exemptions.properties ). Keeping exemptions in a dedicated file avoids the risk of making accidental changes to other settings. Storing such a dedicated file in the source code repository of the application under analysis, thus making the file subject to version control, has the advantage of tracking modifications in terms of date and author. The settings required to create exemptions are described in the section report goal .","title":"Exempt"},{"location":"user/manuals/assess_and_mitigate/#mitigate","text":"If vulnerable code is considered exploitable in a given application context, there are several ways to fix the dependency on the vulnerable open-source component:","title":"Mitigate"},{"location":"user/manuals/assess_and_mitigate/#remove-dependency-ideal","text":"If possible, removing a dependency from your application is the ideal solution. It will not only avoid the dependency on a given library with known vulnerabilities but also reduce (a) the size of your application's deployable artifact and (b) the application's attack surface. The analysis goals a2c , test and t2c can support you in assessing whether or not the removal is possible at all. Running those goals will populate the 2 right-most columns of the table in the Dependencies tab, hence, you will see whether library constructs are potentially executable or actually executed. Direct dependencies can be removed by deleting the respective <dependency> section. Transitive dependencies can be removed by adding an <exclusions> section to the respective direct <dependency> (s), cf. Dependency Exclusions for more details.","title":"Remove dependency (ideal)"},{"location":"user/manuals/assess_and_mitigate/#update-dependency-default","text":"An update is the default solution for fixing a dependency with known-vulnerabilities. It is possible for the majority of vulnerabilities in the Vulas Vulnerability Database. Direct dependencies can be updated by declaring a non-vulnerable version in the respective <dependency> section. Transitive dependencies can be updated by two means: Preferably, by updating the direct <dependency> that is responsible for pulling the vulnerable transitive dependency into your project. Use mvn dependency:tree or the IDE of your choice to identify this to-be-updated direct dependency (cf. screenshot, where the transitive dependency ognl:3.0.6 is pulled in through the direct dependency struts2-core:2.3.24 into the application vulas-testapp-webapp:2.3.8). If there's no updated version of the direct dependency available that solves the problem, you need to declare a direct <dependency> on a non-vulnerable version. This will override the version resulting from the use of the direct dependency. However, as this solution breaks the transparency of the dependency resolution mechanism, it is advisable to add a corresponding comment to your pom.xml or build.gradle and revisit the dependency every now and then. Sometimes, the vulnerable dependency is pulled into your project through a component developed by colleagues. In this case, please ask your colleagues to provide a fixed version that avoids pulling in vulnerable open-source. Like this, every other user of the respective component will be able to solve the problem by a simple update.","title":"Update dependency (default)"},{"location":"user/manuals/assess_and_mitigate/#fixing-the-library-exceptional","text":"Best practice This should only be done if the removal or update of the dependency is not possible. Fixing the library means to create a fix for the vulnerability within the source code of the open-source library, which requires a deep understanding of the respective library and vulnerability. If you take that road, make sure to create a pull request so that the original open-source developers check and integrate the fix in the standard. If not, you will need to maintain your fix in the forked version of the library, and any further enhancements of the library will need to be merged into this fork.","title":"Fixing the library (exceptional)"},{"location":"user/manuals/assess_and_mitigate/#fixing-the-application-exceptional","text":"Best practice This should only be done if the removal or update of the dependency is not possible. Fixing the applications means to introduce a security control in the application that mitigates a problem in a vulnerable library, which requires a deep understanding of the respective vulnerability. Example: Suppose the library in question is vulnerable to XXE processing . If the developers of the respective library do not (cannot) provide a fix, you could introduce a corresponding sanity check in your application, just before XML documents are handed-over to the library. The analysis goals a2c , test and t2c can support you in identifying the application methods that require a safeguard. Ideally, you can see (a subset of) the execution paths that lead from application code to vulnerable library code. See here to learn about the configuration options of the reachability analyses a2c and t2c .","title":"Fixing the application (exceptional)"},{"location":"user/manuals/frontend/","text":"Frontend Manual \u00b6 This guide describe the different views of the apps Web frontend. The sections describing each view can be reached by following the ? icon in the top-right corner of the frontend view itself. Start page \u00b6 The start page is displayed when opening the URL of the Vulas Web Frontend (usually following a link looking like https://vulas.mo.sap.corp/apps ) in the browser: The table displayed on the left contains a subset of the applications analyzed by Vulas. Each application is identified by a triple (group, artifact, version), but only artifact and version are shown in the table. When selecting an application, the analysis results will be displayed on the right. In case your application is not shown, use the search field on top of the table. It can be used for filtering all applications whose group, artifact or version match the provided search string. Other UI controls highlighted in the screenshot are as follows: Control Description 1 Home Reloads the entire application, no application will be shown on the right 2 Redo Search Re-applies the search criterion 3 Workspace Identifier of the current workspace 4 About Provides information about the application such as version, authors, etc. 5 Help Opens this Wiki page 6 Documentation Provides a link to the Documentation 7 Workspace Creation Tools to create a new workspace 8 Settings Provides the possibility to connect to another backend for loading application analyses (expert user only) and to select a workspace to display 9 Reload Reloads all the applications (use if you want to see the analysis results of an application that did not exist before) Vulnerabilities \u00b6 Objective of view: Provide an overview about vulnerable Open-Source dependencies of an application, together with the information whether vulnerable code of such dependencies (e.g. methods) are potentially or actually executable in the context of the application. UI controls highlighted in the screenshot are as follows: 1 Reset table Removes filters and groups from the table 2 Reload data Reloads the app-specific analysis results from the database (use if you executed Vulas goals and want to see its analysis results in the frontend). 3 Toggle historical vulnerabilities Shows and hides the display of historical vulnerabilities, e.g., vulnerabilities that existed in a previous version of the archive. Note: Historical vulnerabilities do not require any action as they do not represent a threat to application security. Note: This option is taken into account after pressing the \"Reload Data\" button (see 2) 4 Toggle unconfirmed vulnerabilities Shows and hides the display of unconfirmed vulnerabilities, i.e. vulnerabilities which have not yet been confirmed by Vulas. Note: This option is taken into account after pressing the \"Reload Data\" button (see 2) 5 Help Link to the frontend vulnerabilities help page (e.g. this page) 6 Reload application data Objective of table: same as objective of view Data shown: Each row corresponds to a vulnerability in a dependency, e.g., multiple vulnerabilities in the same dependency appear in separate table rows. The three columns to the right show whether vulnerable code is included, whether it is potentially reachable or if it was actually reached (executed) at application runtime. Click on a row in order to open the vulnerability details view Data collected by goal(s): vulas:app (to populate the table rows), vulas:a2c and vulas:t2c to populate the column 'Static Analysis', JUnit and Integration tests to populate the column 'Dynamic Analysis' Empty if: An application has no vulnerable dependencies or no dependencies at all Column Description Dependency Scope (Direct / Transitive) When using the Vulas Maven plugin, the scope corresponds to the Maven scope (see here for more information). Dependencies that are declared in the application's POM appear as 'direct' dependency, all others appear as \"transitive\". When using the Vulas CLI, the scope is always 'Runtime' and the dependency always appears as 'direct', since the CLI cannot derive this information from the JARs found in the file system. Archive Filename (SHA1) The filename of the library as found in the file system on which the analysis was run. The SHA1 is the unique identifier of libraries. It can happen that an application has multiple dependencies with the same filename but different SHA1. Vulnerability The identifier of the vulnerability, typically a CVE identifier as used in the NVD. The CVSS score is shown for all vulnerabilities present in the NVD (note that only CVSS v2 is supported), n/a for all others. Inclusion of vulnerable Code Indicates whether the dependency contains vulnerable code. The library version is confirmed to contain vulnerable code The library version is confirmed to contain fixed code (a so-called \"historical vulnerability\") It is unknown whether the library version contains the vulnerable or the fixed code. Note: The Vulas admin team will be automatically notified about such cases in order to take a decision Static Analysis: Potential execution of vulnerable code Indicates whether vulnerable code (e.g., methods) are potentially reachable (executable) according to the results of the static source code analysis (performed during vulas:a2c and vulas:t2c). Vulnerable code is potentially reachable, i.e., the application can be executed in such a way that the vulnerable code is reached. Note: In few cases, the vulnerable code of a given bug is not known. In those cases, this icon appears as soon as any code of the library is found reachable. Library code is reachable, i.e., part of the call graph, but none of the vulnerable code. No library reachable or reachability analysis not performed Dynamic Analysis: Actual execution of vulnerable Code Vulnerable code is executed Note: In few cases, the vulnerable code of a given bug is not known. In those cases, this icon appears as soon as any code of the library is executed. Library code is executed, but none of the vulnerable code No library code executed or no tests have been performed Vulnerabilities Details \u00b6 Objective of Page: Provide detailed information about the vulnerability, the source code repository of the Open-Source project and the constructs (e.g., methods) that have been touched by the Open-Source developers in order to fix the vulnerability. UI controls highlighted in the screenshot are as follows: Control Description 1 Help Link to the documentation page for Vulnerabilities Details (e.g. this page) 2 Exploit database Opens the search page of the Exploit Database in a new browser window, in order to let you search for exploits for the given vulnerability . Note: You need to manually complete the Captcha in order to start the search. 3 NVD (National Vulnerability Database) Opens a link with more vulnerability information in a new browser window. In most of the cases, it is a page from the NVD. 4 Google Trends Shows whether the given vulnerability was a popular Google search term (thus, received a lot of public interest) over the course of the last 30 days (click to see other time ranges). Objective of table: Provide information whether individual vulnerable constructs (methods or constructors) are contained in the respective library, and whether they are potentially or actually reachable. Data shown: All constructs (methods or constructors) that have been added, modified or deleted by the developers of the Open-Source library in order to fix the respective vulnerability. Data collected by goal(s): Table rows are taken from the bug database, which is maintained by the Vulas admin team. The three columns to the right are populated by vulas:app (column 'Contained'), vulas:a2c and vulas:t2c (column 'Reachable'), as well as through the execution of tests (column 'Traced') Empty if: Vulnerabilities that have no known fix or whose fix concerns non-Java files, e.g., XML configuration files. The two right-most columns are empty if the goals vulas:a2c or vulas:t2c have not been executed, or if no tests have been performed Column Description Change Indicates whether the given construct has been ADDed, MODified or DELeted as part of the respective commit (revision) Revision Commit identifier Type Class or Constructor Qualified construct Name (Path) The fully qualified name of the construct, i.e., including package name, class name(s) and parameter types Example: com.acme.Foo$Bar.go(String) , whereby com.acme is a package, Foo and Bar classes and go(String) a method name including a String parameter Contained Indicates whether the respective construct is part of the Java archive or not Note: Very often, the commits of the Open-Source developers also contain changes to their JUnit test classes. Those classes are typically not contained in the released Java archive Reachable Indicates whether the respective construct is part of the call graph built during the Vulas goals a2c and t2c Click on the icon in order to see the actual call graph leading to the respective vulnerable code It is part of the call graph It is not part of the call graph (but others constructs of the archive are) No construct of the respective archive is part of the call graph Traced Indicates whether the respective construct has been executed during JUnit or integration tests Click on the icon in order to see the actual call graph leading to the respective vulnerable code It has been executed. In this case, the tooltip contains information about the timestamp of the execution, the number of calls and the goal identifier It has not been executed (but others constructs of the archive have been) No construct of the respective archive has been executed Vulnerable Code Call Graph \u00b6 Objective of graph: Provide information on paths leading to vulnerable methods Data shown: The vulnerable methods are shown as red nodes, while methods part of the application are shown as green nodes. Black edges result from the static source code analysis, while red edges have been collected during test execution. The fully qualified name of methods and constructors as well as archive information is shown when hovering over nodes. Data collected by goal(s): a2c and t2c (black edges), JUnit and integration tests (red edges) Empty if: No paths to vulnerable methods were found UI controls highlighted in the screenshot are as follows: Control Description 1 Collapse graph on library level Collapses all nodes representing methods of the same library into one node. 2 Collapse graph on package level Collapses all nodes representing methods of the same package into one node. 3 Collapse graph on class level Collapses all nodes representing methods of the same class into one node. 4 Expand all Shows the original graph. 5 Collapse nodes Collapses all nodes 6 Help/Documentation Opens the documentation to this page 7 NVD (National vulnerability Database) Opens the NVD for the respective vulnerability in a new browser window. Dependencies \u00b6 Objective of view: Provide an overview about all dependencies of the application, no matter whether they contain vulnerabilities or not Objective of table: Same as objective of view Data shown: All dependencies of the application. Click on a dependency's filename in order to open the dependencies details view Data collected by goal(s): vulas:app and test Empty if: An application has no dependencies at all The content of the table can be detailed as follow: Details Description Archive Filename (SHA1) The filename of the library as found in the file system on which the analysis was run. The SHA1 is the unique identifier of libraries. It can happen that an application has multiple dependencies with the same filename but different SHA1. Dependency Scope When using the Vulas Maven plugin, the scope corresponds to the Maven scope (see here for more information). When using the Vulas CLI, the scope is always 'Runtime'. Direct / Transitive Direct dependencies are declared/required by the application itself, e.g., because the application makes use of a dependency's API. Transitive dependencies are declared/required not by the application but by its dependencies, e.g., because a dependency makes use of another dependency's API. When using the Vulas Maven plugin, dependencies that are declared in the application's POM appear as 'direct' dependency, all others appear as 'transitive'. When using the Vulas CLI, the dependency always appears as 'direct', since the CLI cannot derive this information from the JARs found in the file system. SHA1 known to Maven Central true if the SHA1 of the JAR is known to Maven Central , false if not. Dependency declared in POM true if the dependency information was read from the application's POM file using the Vulas Maven plugin, false if not. Library constructs potentially executable Number of library constructs potentially reachable (executable), according to the results of the static source code analysis (Vulas goals a2c and t2c). This screen provides several additional controls: Control Description 1 Help/Documentation Opens the documentation to this page 2 Reload App Data Reloads the content of the page The following information are displayed on the top of the main table: Name Description Archives Total The total number of archives/files which are dependencies of the application. Archives Traced The number of archives which were traced during the execution of the test goal Total Number of Traces The total number of traces which were generated during the execution of the test goal Dependencies Details \u00b6 Objective of Page: Provide detailed information about a given dependency, including information about the application-specific use and update possibilities. UI controls highlighted in the screenshot are as follows: Control Description 1 Maven Central Shows all versions of the given artifact in Maven Central Example: If the dependency shown is (commons-collections, commons-collections, 3.2.1), all versions of (commons-collections, commons-collections) known to Maven Central will be shown. 2 Help/Documentation Opens the documentation to this page At the top of the view, the following information are provided: Name Description Digest The unique id of the library (for example its SHA1) Digest verified true if the library id could be verified against the library repository, false if not. Dependency Path The path to the dependency. The view contains the following four section: Calls from application to Archive Library size and application-specific use Finding non-vulnerable library versions Archive Properties Calls from application to Archive \u00b6 This section shows direct call interactions between an application and the dependency (independent of any vulnerabilities). This information is useful when deciding about the update of a dependency, e.g., to a more recent version. It is divided into two parts. On the top, a picture presents an overview of these interactions: Name Description Distinct callers The number of distinct constructs in the application which are calling constructs of the library. Distinct callees The number of distinct constructs of the library which are called by constructs of the application. Calls The number of calls from the application to the library Below this picture, details of these interactions are described in a table. Objective of Table:: Shows the details of the interactions between an application and the dependency. Data shown:: Calls of a library method by an application method or vice versa. Data collected by goal(s):: vulas:a2c , vulas:t2c and test . Empty if: Application and library do not directly interact, e.g., as in case of transitive dependencies. None of the goals have been executed. Column Description Caller Fully-qualified name of the calling construct. Caller type **METH**od or **CONS**tructor. Callee Fully-qualified name the called construct. Potential True if the call has been found by static source analysis, false otherwise. Note: If the call has not been found by static analyses but has been observed during tests, the false is highlighted in red . This can happen if either the static analysis goals vulas:a2c and vulas:2tc were not executed or the analysis failed to identify the call. Traced True if the call has been observed during tests, false otherwise. Library size and application-specific use \u00b6 Objective of Table: Show the degree of actual and potential use that the application makes of the dependency (independent of any vulnerabilities). Data shown: The absolute number of constructs contains in the library (methods, constructors, etc.) and the number of constructs potentially or actually executable. Data collected by goal(s): vulas:a2c , vulas:t2c and test . Empty if: The dependency is not at all used in the scope of an application or none of the goals have been executed. Column Description Construct Type INIT: Static class initializer CONS: Constructor METH: Method CLASS: Class ENUM: Enumeration PACK: Package countExecutable: INIT + CONS + METH Count Total Absolute number contained in the JAR Count Reachable Number of constructs found reachable during static source code analysis. Count Traced Number of observed constructs during tests Finding non-vulnerable library versions \u00b6 Objective of Table: Support the selection of a more recent, non-vulnerable library version. Data shown: All library versions known to Maven Central, together with the number of vulnerabilities known to Vulas. Moreover, the table displays four update metrics computed over the library version currently in use and the respective alternative. Click on a row in order to see details about the removed callees (if any) in the view Calls from application to archive to be modified . Data collected by goal(s): Empty if: Neither the SHA1 nor the Maven identifier (group, artifact, version) of the dependency is known to Maven Central. In this case it is not possible to retrieve alternative versions. Column Description Library Id The Maven identifier in the format group : artifact : version. Count vulnerabilities The number of vulnerabilities known by Vulas. Callee stability The share of library callees that exist with the same signature (cf. table 'Calls from application to archive'). Example: If the application directly calls two methods in the current archive and one of those is not any longer present, the callee stability would be '1 out of 2 ( 50% )'. Note: Can be 0 if there are no direct calls between application and library. Dev. effort (calls to modify) The share of application calls that require a modification due to missing callees (cf. table 'Calls from application to archive'). Example: If the application calls a given library method from two of its methods and the library method is no longer present, the development effort would be '2 out of 2 ( 100% )'. Note: Can be 0 if there are no direct calls between application and library (or the respective goals were not run). Reachable body stability The number of reachable constructs in the current library version that exists as-is, i.e., with identical signature and identical byte code, in the alternative library (cf. table 'Library size and application-specific use'). Note: Can be 0 if none of the library constructs is reachable from the application (or the respective goals were not run). Overall body stability The number of constructs in the current library version that exists as-is, i.e., with identical signature and identical byte code, in the alternative library. Note: This metric is independent of the application-specific use of the library. Archive Properties \u00b6 Objective of Table:: Provide meta-information about the dependency, e.g., its version. Data shown:: All entries of the Manifest file ('META-INF/MANIFEST.MF' in the JAR). Data collected by goal(s):: vulas:app . Empty if: The dependency has no MANIFEST.MF file or it does not contain any entries. Column Description Property Name The name of the Manifest file entry, e.g., 'Built-By'. Property Value The value of the Manifest file entry, e.g., 'Foo'. Callers to be modified \u00b6 Objective of page: Support the developer in updating a dependency to a more recent release by showing him all application methods that require modification. Data shown: All application calls that require a modification because of the fact that a callee method is no more available in the selected library version. Data collected by goal(s): vulas:a2c , vulas:t2c and tests Empty if: Either because there exist no direct method invocations from application to library or all of the callee methods still exist in the selected library version. On the top of the screen some metrics are provided: Name Description Calls to modify The number of calls to be modified in order to use this library version. Distinct callers to modify The number of constructors be modified/updated in the application in order to use this library version. Callees deleted The number of constructs of currently used library (by the application) which no longer exist in this new version of the library. These information are followed by a table providing the details: Name Description Caller the name of the construct of the application calling the library. Callee type The type of the called construct in the library. Callee The name of the called construct in the library. Potential True if the call has been found by static source analysis, false otherwise. Note: If the call has not been found by static analyses but has been observed during tests, the false is highlighted in red . This can happen if either the static analysis goals vulas:a2c and vulas:2tc were not executed or the analysis failed to identify the call. Traced True if the call has been observed during tests, false otherwise. Application Statistics \u00b6 Objective of page: Provide an overview about : the application and its dependencies, the application test coverage. Two tables are presented in this page: Dependencies Objective of table: Show statistics about the constructs of the application and its dependencies (methods, functions, packages, classes...). Please notice that these information are excluding the dependencies in the scopes TEST and PROVIDED . In the header of the table user can see the total number of dependencies which were considered. Column Description Construct Type The Types of analyzed constructs. Application The number of constructs (of type defined in column \"Construct Type\") in the application. Total (App + Dependencies) The total number of constructs (of type defined in column \"Construct Type\") of all the project, e.g. application code + dependencies Percentage (app/total) The percentage of code of the application compared to the total code of the project (application + dependencies). Application The second section of this page presents 2 metrics and a table: Name Description Executable application constructs (total) The total number of executable constructs of the application. Executable application constructs (traced) The number of executable constructs of the application which have been traced. Objective of table: Same as objective of view. Data shown: The number of traced constructs per application package. Data collected by goal(s): JUnit and integration tests. Empty if: No tests have been run. Column Description Application Packages Java package of the application. Constructors (traced / total) Number of constructors of classes in the respective package that were traced during tests. Total number of constructors of classes in the respective package. Note: The application constructs are typically collected from the compiled application code, hence, also comprise default constructors or constructors with synthetic parameters Methods (traced / total) Number of methods of classes in the respective package that were traced during tests. Total number of methods of classes in the respective package. Note: The application constructs are typically collected from the compiled application code, hence, also comprise synthetic methods such as access methods. Functions (traced/total) Number of functions in the respective package that were traced during tests. Total number of functions in the respective package. Note: The application constructs are typically collected from the compiled application code, hence, also comprise synthetic functions such as access functions. Static Initializers (traced/total) Number of static analyzers in the respective package that were traced during tests. Total number of static analyzers in the respective package. Note: The application constructs are typically collected from the compiled application code, hence, also comprise synthetic functions such as access functions. Test Coverage Percentage of traced constructs (methods, constructors, modules, functions, static initializers). History \u00b6 Objective of view: Provide an overview about goal executions for a given application. Objective of table: Same as objective of view. Data shown: Each row corresponds to one Vulas goal execution, click on a row in order to see detailed goal information. Data collected by goal(s): All. Empty if: No goals have been executed. Column Description Status Empty on success, error message in case of failures Goal Goal executed, see here for the list of all goals Started at Start date and time of the goal execution Runtime Total duration of the goal execution in minutes JVM Max.Memory (MB) Max. memory available for the JVM Max. Memory used (MB) Max. memory used by the JVM AVG. Memory used (MB) Average memory used by the JVM Vulas Release Release of Vulas used By clicking on one item of the list, user will then be able to see the details of the goal execution . History Details \u00b6 Objective of view: Provide detailed information about a given Vulas goal execution, mainly for root cause analysis of problems. This view presents the following metrics: Name Description Goal Execution ID Unique ID associated to the goal execution. Started At The date/time when this goal was executed on the client. The view also contains the following three tables: Goal statistics Goal configuration System information Goal statistics Data shown: Statistics collected at goal runtime. Data collected by goal(s): All. Empty if: Should never be empty. Column >Description Property Name Name of the metric. Property Value Value of the metric. Goal configuration Data shown: Configuration settings used for the goal execution. Data collected by goal(s): All. Empty if: Should never be empty. Column Description Property Name Name of the configuration setting. Property Value Value of the configuration setting. System information Data shown: Java system properties and environment variables collected on the client during the goal execution. The configuration settings vulas.shared.sys and vulas.shared.env determine which information is collected: # Comma-separated list of environment variables gathered during goal execution and transferred to the backend # A given environment variable is considered if its name equals one of the values (case-insensitive) # # Default: 18 variables vulas.shared.env = PROCESSOR_IDENTIFIER, NUMBER_OF_PROCESSORS, PROCESSOR_LEVEL, PROCESSOR_ARCHITECTURE, PROCESSOR_REVISION, \\ JAVA_HOME, COMPUTERNAME, \\ MAVEN_PROJECTBASEDIR, MAVEN_HOME, MAVEN_CONFIG, MAVEN_OPTS, \\ BUILD_URL, BUILD_TAG, BUILD_TIMESTAMP, BUILD_DISPLAY_NAME, BUILD_ID, BUILD_NUMBER, BUILD_VERSION # Extension of the above list # Default: - #vulas.shared.env.custom # Comma-separated list of system property namespaces gathered during goal execution and transferred to the backend # A given system property is considered if it starts with one of those namespaces (case-insensitive) # # Default: 6 patterns vulas.shared.sys = user., os., java., runtime., maven., sun. # Extension of the above list # Default: - #vulas.shared.sys.custom Data collected by goal(s): All. Empty if: Should never be empty. Column >Description Property Name Name of the system/environment setting. Property Value Value of the system/environment setting. Search \u00b6 Objective of view: Search for constructs in application dependencies. Objective of table: Same as objective of view. Data shown: Archives that contain one or more constructs (methods, classes, packages, etc.) that match the search expression. Data collected by goal(s): N/a. Empty if: If the search did not yield a result. Mitigation \u00b6 Objective of view: Get an overview about vulnerable archives that require a fix. Objective of table: Same as objective of view. Data shown: Archives that have one or more known vulnerabilities, click on a row in order to see update proposals and metrics in the dependencies details view . Data collected by goal(s): vulas:app . Empty if: An application has no vulnerable dependencies. Column Description Dependency scope (Direct/Transitive) When using the Vulas Maven plugin, the scope corresponds to the Maven scope (see here for more information). Dependencies that are declared in the application's POM appear as 'direct' dependency, all others appear as 'transitive'. When using the Vulas CLI, the scope is always 'Runtime' and the dependency always appears as 'direct', since the CLI cannot derive this information from the JARs found in the file system. Archive Filename (SHA1) The filename of the library as found in the file system on which the analysis was run. The SHA1 is the unique identifier of libraries. It can happen that an application has multiple dependencies with the same filename but different SHA1. Vulnerability # Number of known vulnerabilities of a dependency.","title":"Frontend"},{"location":"user/manuals/frontend/#frontend-manual","text":"This guide describe the different views of the apps Web frontend. The sections describing each view can be reached by following the ? icon in the top-right corner of the frontend view itself.","title":"Frontend Manual"},{"location":"user/manuals/frontend/#start-page","text":"The start page is displayed when opening the URL of the Vulas Web Frontend (usually following a link looking like https://vulas.mo.sap.corp/apps ) in the browser: The table displayed on the left contains a subset of the applications analyzed by Vulas. Each application is identified by a triple (group, artifact, version), but only artifact and version are shown in the table. When selecting an application, the analysis results will be displayed on the right. In case your application is not shown, use the search field on top of the table. It can be used for filtering all applications whose group, artifact or version match the provided search string. Other UI controls highlighted in the screenshot are as follows: Control Description 1 Home Reloads the entire application, no application will be shown on the right 2 Redo Search Re-applies the search criterion 3 Workspace Identifier of the current workspace 4 About Provides information about the application such as version, authors, etc. 5 Help Opens this Wiki page 6 Documentation Provides a link to the Documentation 7 Workspace Creation Tools to create a new workspace 8 Settings Provides the possibility to connect to another backend for loading application analyses (expert user only) and to select a workspace to display 9 Reload Reloads all the applications (use if you want to see the analysis results of an application that did not exist before)","title":"Start page"},{"location":"user/manuals/frontend/#vulnerabilities","text":"Objective of view: Provide an overview about vulnerable Open-Source dependencies of an application, together with the information whether vulnerable code of such dependencies (e.g. methods) are potentially or actually executable in the context of the application. UI controls highlighted in the screenshot are as follows: 1 Reset table Removes filters and groups from the table 2 Reload data Reloads the app-specific analysis results from the database (use if you executed Vulas goals and want to see its analysis results in the frontend). 3 Toggle historical vulnerabilities Shows and hides the display of historical vulnerabilities, e.g., vulnerabilities that existed in a previous version of the archive. Note: Historical vulnerabilities do not require any action as they do not represent a threat to application security. Note: This option is taken into account after pressing the \"Reload Data\" button (see 2) 4 Toggle unconfirmed vulnerabilities Shows and hides the display of unconfirmed vulnerabilities, i.e. vulnerabilities which have not yet been confirmed by Vulas. Note: This option is taken into account after pressing the \"Reload Data\" button (see 2) 5 Help Link to the frontend vulnerabilities help page (e.g. this page) 6 Reload application data Objective of table: same as objective of view Data shown: Each row corresponds to a vulnerability in a dependency, e.g., multiple vulnerabilities in the same dependency appear in separate table rows. The three columns to the right show whether vulnerable code is included, whether it is potentially reachable or if it was actually reached (executed) at application runtime. Click on a row in order to open the vulnerability details view Data collected by goal(s): vulas:app (to populate the table rows), vulas:a2c and vulas:t2c to populate the column 'Static Analysis', JUnit and Integration tests to populate the column 'Dynamic Analysis' Empty if: An application has no vulnerable dependencies or no dependencies at all Column Description Dependency Scope (Direct / Transitive) When using the Vulas Maven plugin, the scope corresponds to the Maven scope (see here for more information). Dependencies that are declared in the application's POM appear as 'direct' dependency, all others appear as \"transitive\". When using the Vulas CLI, the scope is always 'Runtime' and the dependency always appears as 'direct', since the CLI cannot derive this information from the JARs found in the file system. Archive Filename (SHA1) The filename of the library as found in the file system on which the analysis was run. The SHA1 is the unique identifier of libraries. It can happen that an application has multiple dependencies with the same filename but different SHA1. Vulnerability The identifier of the vulnerability, typically a CVE identifier as used in the NVD. The CVSS score is shown for all vulnerabilities present in the NVD (note that only CVSS v2 is supported), n/a for all others. Inclusion of vulnerable Code Indicates whether the dependency contains vulnerable code. The library version is confirmed to contain vulnerable code The library version is confirmed to contain fixed code (a so-called \"historical vulnerability\") It is unknown whether the library version contains the vulnerable or the fixed code. Note: The Vulas admin team will be automatically notified about such cases in order to take a decision Static Analysis: Potential execution of vulnerable code Indicates whether vulnerable code (e.g., methods) are potentially reachable (executable) according to the results of the static source code analysis (performed during vulas:a2c and vulas:t2c). Vulnerable code is potentially reachable, i.e., the application can be executed in such a way that the vulnerable code is reached. Note: In few cases, the vulnerable code of a given bug is not known. In those cases, this icon appears as soon as any code of the library is found reachable. Library code is reachable, i.e., part of the call graph, but none of the vulnerable code. No library reachable or reachability analysis not performed Dynamic Analysis: Actual execution of vulnerable Code Vulnerable code is executed Note: In few cases, the vulnerable code of a given bug is not known. In those cases, this icon appears as soon as any code of the library is executed. Library code is executed, but none of the vulnerable code No library code executed or no tests have been performed","title":"Vulnerabilities"},{"location":"user/manuals/frontend/#vulnerabilities-details","text":"Objective of Page: Provide detailed information about the vulnerability, the source code repository of the Open-Source project and the constructs (e.g., methods) that have been touched by the Open-Source developers in order to fix the vulnerability. UI controls highlighted in the screenshot are as follows: Control Description 1 Help Link to the documentation page for Vulnerabilities Details (e.g. this page) 2 Exploit database Opens the search page of the Exploit Database in a new browser window, in order to let you search for exploits for the given vulnerability . Note: You need to manually complete the Captcha in order to start the search. 3 NVD (National Vulnerability Database) Opens a link with more vulnerability information in a new browser window. In most of the cases, it is a page from the NVD. 4 Google Trends Shows whether the given vulnerability was a popular Google search term (thus, received a lot of public interest) over the course of the last 30 days (click to see other time ranges). Objective of table: Provide information whether individual vulnerable constructs (methods or constructors) are contained in the respective library, and whether they are potentially or actually reachable. Data shown: All constructs (methods or constructors) that have been added, modified or deleted by the developers of the Open-Source library in order to fix the respective vulnerability. Data collected by goal(s): Table rows are taken from the bug database, which is maintained by the Vulas admin team. The three columns to the right are populated by vulas:app (column 'Contained'), vulas:a2c and vulas:t2c (column 'Reachable'), as well as through the execution of tests (column 'Traced') Empty if: Vulnerabilities that have no known fix or whose fix concerns non-Java files, e.g., XML configuration files. The two right-most columns are empty if the goals vulas:a2c or vulas:t2c have not been executed, or if no tests have been performed Column Description Change Indicates whether the given construct has been ADDed, MODified or DELeted as part of the respective commit (revision) Revision Commit identifier Type Class or Constructor Qualified construct Name (Path) The fully qualified name of the construct, i.e., including package name, class name(s) and parameter types Example: com.acme.Foo$Bar.go(String) , whereby com.acme is a package, Foo and Bar classes and go(String) a method name including a String parameter Contained Indicates whether the respective construct is part of the Java archive or not Note: Very often, the commits of the Open-Source developers also contain changes to their JUnit test classes. Those classes are typically not contained in the released Java archive Reachable Indicates whether the respective construct is part of the call graph built during the Vulas goals a2c and t2c Click on the icon in order to see the actual call graph leading to the respective vulnerable code It is part of the call graph It is not part of the call graph (but others constructs of the archive are) No construct of the respective archive is part of the call graph Traced Indicates whether the respective construct has been executed during JUnit or integration tests Click on the icon in order to see the actual call graph leading to the respective vulnerable code It has been executed. In this case, the tooltip contains information about the timestamp of the execution, the number of calls and the goal identifier It has not been executed (but others constructs of the archive have been) No construct of the respective archive has been executed","title":"Vulnerabilities Details"},{"location":"user/manuals/frontend/#vulnerable-code-call-graph","text":"Objective of graph: Provide information on paths leading to vulnerable methods Data shown: The vulnerable methods are shown as red nodes, while methods part of the application are shown as green nodes. Black edges result from the static source code analysis, while red edges have been collected during test execution. The fully qualified name of methods and constructors as well as archive information is shown when hovering over nodes. Data collected by goal(s): a2c and t2c (black edges), JUnit and integration tests (red edges) Empty if: No paths to vulnerable methods were found UI controls highlighted in the screenshot are as follows: Control Description 1 Collapse graph on library level Collapses all nodes representing methods of the same library into one node. 2 Collapse graph on package level Collapses all nodes representing methods of the same package into one node. 3 Collapse graph on class level Collapses all nodes representing methods of the same class into one node. 4 Expand all Shows the original graph. 5 Collapse nodes Collapses all nodes 6 Help/Documentation Opens the documentation to this page 7 NVD (National vulnerability Database) Opens the NVD for the respective vulnerability in a new browser window.","title":"Vulnerable Code Call Graph"},{"location":"user/manuals/frontend/#dependencies","text":"Objective of view: Provide an overview about all dependencies of the application, no matter whether they contain vulnerabilities or not Objective of table: Same as objective of view Data shown: All dependencies of the application. Click on a dependency's filename in order to open the dependencies details view Data collected by goal(s): vulas:app and test Empty if: An application has no dependencies at all The content of the table can be detailed as follow: Details Description Archive Filename (SHA1) The filename of the library as found in the file system on which the analysis was run. The SHA1 is the unique identifier of libraries. It can happen that an application has multiple dependencies with the same filename but different SHA1. Dependency Scope When using the Vulas Maven plugin, the scope corresponds to the Maven scope (see here for more information). When using the Vulas CLI, the scope is always 'Runtime'. Direct / Transitive Direct dependencies are declared/required by the application itself, e.g., because the application makes use of a dependency's API. Transitive dependencies are declared/required not by the application but by its dependencies, e.g., because a dependency makes use of another dependency's API. When using the Vulas Maven plugin, dependencies that are declared in the application's POM appear as 'direct' dependency, all others appear as 'transitive'. When using the Vulas CLI, the dependency always appears as 'direct', since the CLI cannot derive this information from the JARs found in the file system. SHA1 known to Maven Central true if the SHA1 of the JAR is known to Maven Central , false if not. Dependency declared in POM true if the dependency information was read from the application's POM file using the Vulas Maven plugin, false if not. Library constructs potentially executable Number of library constructs potentially reachable (executable), according to the results of the static source code analysis (Vulas goals a2c and t2c). This screen provides several additional controls: Control Description 1 Help/Documentation Opens the documentation to this page 2 Reload App Data Reloads the content of the page The following information are displayed on the top of the main table: Name Description Archives Total The total number of archives/files which are dependencies of the application. Archives Traced The number of archives which were traced during the execution of the test goal Total Number of Traces The total number of traces which were generated during the execution of the test goal","title":"Dependencies"},{"location":"user/manuals/frontend/#dependencies-details","text":"Objective of Page: Provide detailed information about a given dependency, including information about the application-specific use and update possibilities. UI controls highlighted in the screenshot are as follows: Control Description 1 Maven Central Shows all versions of the given artifact in Maven Central Example: If the dependency shown is (commons-collections, commons-collections, 3.2.1), all versions of (commons-collections, commons-collections) known to Maven Central will be shown. 2 Help/Documentation Opens the documentation to this page At the top of the view, the following information are provided: Name Description Digest The unique id of the library (for example its SHA1) Digest verified true if the library id could be verified against the library repository, false if not. Dependency Path The path to the dependency. The view contains the following four section: Calls from application to Archive Library size and application-specific use Finding non-vulnerable library versions Archive Properties","title":"Dependencies Details"},{"location":"user/manuals/frontend/#calls-from-application-to-archive","text":"This section shows direct call interactions between an application and the dependency (independent of any vulnerabilities). This information is useful when deciding about the update of a dependency, e.g., to a more recent version. It is divided into two parts. On the top, a picture presents an overview of these interactions: Name Description Distinct callers The number of distinct constructs in the application which are calling constructs of the library. Distinct callees The number of distinct constructs of the library which are called by constructs of the application. Calls The number of calls from the application to the library Below this picture, details of these interactions are described in a table. Objective of Table:: Shows the details of the interactions between an application and the dependency. Data shown:: Calls of a library method by an application method or vice versa. Data collected by goal(s):: vulas:a2c , vulas:t2c and test . Empty if: Application and library do not directly interact, e.g., as in case of transitive dependencies. None of the goals have been executed. Column Description Caller Fully-qualified name of the calling construct. Caller type **METH**od or **CONS**tructor. Callee Fully-qualified name the called construct. Potential True if the call has been found by static source analysis, false otherwise. Note: If the call has not been found by static analyses but has been observed during tests, the false is highlighted in red . This can happen if either the static analysis goals vulas:a2c and vulas:2tc were not executed or the analysis failed to identify the call. Traced True if the call has been observed during tests, false otherwise.","title":"Calls from application to Archive"},{"location":"user/manuals/frontend/#library-size-and-application-specific-use","text":"Objective of Table: Show the degree of actual and potential use that the application makes of the dependency (independent of any vulnerabilities). Data shown: The absolute number of constructs contains in the library (methods, constructors, etc.) and the number of constructs potentially or actually executable. Data collected by goal(s): vulas:a2c , vulas:t2c and test . Empty if: The dependency is not at all used in the scope of an application or none of the goals have been executed. Column Description Construct Type INIT: Static class initializer CONS: Constructor METH: Method CLASS: Class ENUM: Enumeration PACK: Package countExecutable: INIT + CONS + METH Count Total Absolute number contained in the JAR Count Reachable Number of constructs found reachable during static source code analysis. Count Traced Number of observed constructs during tests","title":"Library size and application-specific use"},{"location":"user/manuals/frontend/#finding-non-vulnerable-library-versions","text":"Objective of Table: Support the selection of a more recent, non-vulnerable library version. Data shown: All library versions known to Maven Central, together with the number of vulnerabilities known to Vulas. Moreover, the table displays four update metrics computed over the library version currently in use and the respective alternative. Click on a row in order to see details about the removed callees (if any) in the view Calls from application to archive to be modified . Data collected by goal(s): Empty if: Neither the SHA1 nor the Maven identifier (group, artifact, version) of the dependency is known to Maven Central. In this case it is not possible to retrieve alternative versions. Column Description Library Id The Maven identifier in the format group : artifact : version. Count vulnerabilities The number of vulnerabilities known by Vulas. Callee stability The share of library callees that exist with the same signature (cf. table 'Calls from application to archive'). Example: If the application directly calls two methods in the current archive and one of those is not any longer present, the callee stability would be '1 out of 2 ( 50% )'. Note: Can be 0 if there are no direct calls between application and library. Dev. effort (calls to modify) The share of application calls that require a modification due to missing callees (cf. table 'Calls from application to archive'). Example: If the application calls a given library method from two of its methods and the library method is no longer present, the development effort would be '2 out of 2 ( 100% )'. Note: Can be 0 if there are no direct calls between application and library (or the respective goals were not run). Reachable body stability The number of reachable constructs in the current library version that exists as-is, i.e., with identical signature and identical byte code, in the alternative library (cf. table 'Library size and application-specific use'). Note: Can be 0 if none of the library constructs is reachable from the application (or the respective goals were not run). Overall body stability The number of constructs in the current library version that exists as-is, i.e., with identical signature and identical byte code, in the alternative library. Note: This metric is independent of the application-specific use of the library.","title":"Finding non-vulnerable library versions"},{"location":"user/manuals/frontend/#archive-properties","text":"Objective of Table:: Provide meta-information about the dependency, e.g., its version. Data shown:: All entries of the Manifest file ('META-INF/MANIFEST.MF' in the JAR). Data collected by goal(s):: vulas:app . Empty if: The dependency has no MANIFEST.MF file or it does not contain any entries. Column Description Property Name The name of the Manifest file entry, e.g., 'Built-By'. Property Value The value of the Manifest file entry, e.g., 'Foo'.","title":"Archive Properties"},{"location":"user/manuals/frontend/#callers-to-be-modified","text":"Objective of page: Support the developer in updating a dependency to a more recent release by showing him all application methods that require modification. Data shown: All application calls that require a modification because of the fact that a callee method is no more available in the selected library version. Data collected by goal(s): vulas:a2c , vulas:t2c and tests Empty if: Either because there exist no direct method invocations from application to library or all of the callee methods still exist in the selected library version. On the top of the screen some metrics are provided: Name Description Calls to modify The number of calls to be modified in order to use this library version. Distinct callers to modify The number of constructors be modified/updated in the application in order to use this library version. Callees deleted The number of constructs of currently used library (by the application) which no longer exist in this new version of the library. These information are followed by a table providing the details: Name Description Caller the name of the construct of the application calling the library. Callee type The type of the called construct in the library. Callee The name of the called construct in the library. Potential True if the call has been found by static source analysis, false otherwise. Note: If the call has not been found by static analyses but has been observed during tests, the false is highlighted in red . This can happen if either the static analysis goals vulas:a2c and vulas:2tc were not executed or the analysis failed to identify the call. Traced True if the call has been observed during tests, false otherwise.","title":"Callers to be modified"},{"location":"user/manuals/frontend/#application-statistics","text":"Objective of page: Provide an overview about : the application and its dependencies, the application test coverage. Two tables are presented in this page:","title":"Application Statistics"},{"location":"user/manuals/frontend/#history","text":"Objective of view: Provide an overview about goal executions for a given application. Objective of table: Same as objective of view. Data shown: Each row corresponds to one Vulas goal execution, click on a row in order to see detailed goal information. Data collected by goal(s): All. Empty if: No goals have been executed. Column Description Status Empty on success, error message in case of failures Goal Goal executed, see here for the list of all goals Started at Start date and time of the goal execution Runtime Total duration of the goal execution in minutes JVM Max.Memory (MB) Max. memory available for the JVM Max. Memory used (MB) Max. memory used by the JVM AVG. Memory used (MB) Average memory used by the JVM Vulas Release Release of Vulas used By clicking on one item of the list, user will then be able to see the details of the goal execution .","title":"History"},{"location":"user/manuals/frontend/#history-details","text":"Objective of view: Provide detailed information about a given Vulas goal execution, mainly for root cause analysis of problems. This view presents the following metrics: Name Description Goal Execution ID Unique ID associated to the goal execution. Started At The date/time when this goal was executed on the client. The view also contains the following three tables: Goal statistics Goal configuration System information","title":"History Details"},{"location":"user/manuals/frontend/#search","text":"Objective of view: Search for constructs in application dependencies. Objective of table: Same as objective of view. Data shown: Archives that contain one or more constructs (methods, classes, packages, etc.) that match the search expression. Data collected by goal(s): N/a. Empty if: If the search did not yield a result.","title":"Search"},{"location":"user/manuals/frontend/#mitigation","text":"Objective of view: Get an overview about vulnerable archives that require a fix. Objective of table: Same as objective of view. Data shown: Archives that have one or more known vulnerabilities, click on a row in order to see update proposals and metrics in the dependencies details view . Data collected by goal(s): vulas:app . Empty if: An application has no vulnerable dependencies. Column Description Dependency scope (Direct/Transitive) When using the Vulas Maven plugin, the scope corresponds to the Maven scope (see here for more information). Dependencies that are declared in the application's POM appear as 'direct' dependency, all others appear as 'transitive'. When using the Vulas CLI, the scope is always 'Runtime' and the dependency always appears as 'direct', since the CLI cannot derive this information from the JARs found in the file system. Archive Filename (SHA1) The filename of the library as found in the file system on which the analysis was run. The SHA1 is the unique identifier of libraries. It can happen that an application has multiple dependencies with the same filename but different SHA1. Vulnerability # Number of known vulnerabilities of a dependency.","title":"Mitigation"},{"location":"user/manuals/report/","text":"Report Manual \u00b6 Work in progress To be written.","title":"Report"},{"location":"user/manuals/report/#report-manual","text":"Work in progress To be written.","title":"Report Manual"},{"location":"user/manuals/setup/","text":"Setup and Configuration Guide \u00b6 Workspace \u00b6 A workspace acts as a container to group the results of several application analyses. In that context, please note that each module of a multi-module Maven project appears as a separate application in the Vulas Web frontend. Before using workspaces, you need to create one using the Vulas Web frontend (see below); you will obtain a token that you will need to pass as a configuration parameter when performing scans. Create workspace(s) (once) \u00b6 You need to create a workspace once using the Vulas Web frontend. Use the \"create workspace\" icon in the lower-left corner toolbar of the apps Web frontend to do so. A workspace has the following properties: Name : Must be provided. Note that the name is not unique, thus, there can be several workspaces having the same name. Description : Must be provided. Contact : Please provide the email address of a distribution list (DL) matching the regex DL_[0-9A-Fa-f]*@exchange.sap.corp . Important : Either contact or PPMS object number must be provided when creating a workspace. Export results : AGGREGATED: Findings are aggregated on workspace-level, one item for the entire workspace will be exported (to Sirius/Security Hub) DETAILED: Findings are aggregated on application-level, one item for every application of the workspace will be exported OFF: No export of findings Public : A public workspace appears in the drop-down box of the apps Web frontend, a private one does not. Important: It will not be possible to retrieve the token of a private space at later points in time, thus, note it down when it is shown right after workspace creation. PPMS Object Number : If possible, provide the object number (not the name) of the PPMS Software Component Version (SCV), Product Version (PV) or Build Version (BV) corresponding to the application(s) scanned in the context of this workspace. No alphanumeric characters are allowed. The provision of the object number makes tool adoption (coverage) at SAP transparent, and allows reaching out to development teams in case of high-profile vulnerabilities (discussed in mainstream media). Example: In order to specify the PPMS object number of SAP NETWEAVER AS JAVA 7.2 (cf. screenshot), one should enter 01200314690900001979 when creating a workspace. Once the fields have been filled, press the \"Save\" button. The system then returns with a pop-up containing the random token generated upon workspace creation. Do not forget to note down this token, it will be needed later on for each scan of your application(s). Use the generated token (during application analysis) \u00b6 The workspace token generated at previous step has to be used as value for the configuration setting vulas.core.space.token . This information is mandatory during the scans as it allows the user's data to be uploaded to the correct place/workspace in the Vulas backend. See here for more information regarding the configuration of Vulas clients. Choose a workspace (in the apps Web frontend) \u00b6 Use the configuration icon in the lower-left corner in order to select a workspace. You can search for public workspaces by typing their name in the \"Space\" field. You can copy&paste the token of a private workspace into the input field in order to select it. Additional fields \"Backend URL\" and \"Artifact Analyzer URL\" can be used to connect the frontend to another backend (than the default running on the same host). Generally, this must not be changed by the users. Once you have selected a workspace, press \"Save\" button. The list of applications of that workspace will be automatically loaded on the left list menu of the frontend. Edit a workspace (in the apps Web frontend) \u00b6 In order to edit a workspace, press the same button as to choose a workspace and perform the following steps: Enter the name/token id of the workspace to edit in the \"Space\" field and eventually select one of the entries provided in the drop down list. press the \"Edit Space\" button at the bottom. Once this button is clicked, all the editable property-fields of the workspace are displayed. update/change the data of your workspace as per your expectations. Press the \"Save\" button to save your modifications, press the \"close\" button to revert your changes. Workspace REST API \u00b6 The REST API can be used to export findings in a machine-readable fashion. Calling HTTP GET on the following URL, for instance, returns all vulnerable dependencies of an aggregated workspace: http://vulas.mo.sap.corp:8080/backend/hubIntegration/apps/<workspace-name>%20(<workspace-token>)/vulndeps The API returns an array of JSON elements having the following data model: Property Description Possible Values projectId Identifies the affected application and dependency ( <app-GAV> > <dep-filename> ) type Identifier of vulnerability in Vulas knowledge base scope Scope of the dependency see official Maven documentation priority Priority of the finding 3 in case of dependencies with scope TEST and PROVIDED, 1 otherwise exemptionReason Assessment description (if any), see report goal for more information on how-to assess and exempt findings state Assessment result (if any) 1 (secure-by-design) in case of dependencies with scope TEST and PROVIDED, 4 (mitigated) in case the bug has been exempted, 2 (true-positive) otherwise status Indicates whether the finding has been assessed 1 (audited) in case state is 1 or 4, -1 (non-audited) otherwise count Number of findings of type type in project Always 1 snapshotDate Date of most recent goal execution of the application (any goal) Setup \u00b6 Maven \u00b6 The plugin for Maven can be used with or without adding a <profile> section to the pom.xml . With profile , the execution of goals is more concise (readable), e.g., mvn -Dvulas compile vulas:app . A sample profile can be found here , just copy&paste it into the <profiles> section of your pom.xml . In case of aggregated, multi-module Maven projects with modules inheriting from their parent, it is sufficient to include the profile in the top-level (parent) pom.xml . If a module does not inherit from the parent, the profile has to be added to its POM file. Without profile , the execution of goals requires the use of the plugin's fully qualified name, e.g., mvn compile com.sap.research.security.vulas:plugin-maven:3.0.12:app . Moreover, you need to specify the following mandatory configuration settings. As described here , there are several ways of doing so, however, a file as follows is very common: vulas-custom.properties vulas.core.space.token = <YOUR WORKSPACE TOKEN> vulas.shared.backend.serviceUrl = http://vulas.mo.sap.corp:8080/backend It is possible to include/exclude modules of a multi-module Maven project using the following configuration parameters: # Options to include and exclude Maven artifacts (modules) during the processing of an aggregator project. # If includes is provided, the other parameters are ignored. In other words, excludes and ignorePoms will # only be evaluated if includes is empty. # # Important: Those options are ignored in case of the report goal, thus, report will be run on all modules. # In particular, running report on a module with packaging POM will create an aggregated report for all its # submodules. # # One has to provide the artifactId (not the module name), and multiple values for includes and excludes must # be separated by comma. # # Defaults: # includes = - # excludes = - # ignorePoms = false vulas.maven.includes = vulas.maven.excludes = vulas.maven.ignorePoms = false Gradle \u00b6 The plugin for Gradle requires changes of the following files: build.gradle buildscript { repositories { maven { url 'http://nexus.wdf.sap.corp:8081/nexus/content/repositories/build.snapshots' } mavenCentral() } dependencies { classpath('com.sap.research.security.vulas:plugin-gradle:3.0.12') { changing = true } } } allprojects { apply plugin: \"vulas\" } gradle.properties // Used to identify the scan in the apps Web frontend group = ### group - EDIT THIS ### version = ### version - EDIT THIS ### // Replace token of test space vulas.core.space.token = ### workspace token - EDIT THIS ### vulas.shared.backend.serviceUrl = http://vulas.mo.sap.corp:8080/backend Note: Rather than adding configuration settings to gradle.properties , they can also be passed as project properties in the command line, e.g., -Pvulas.report.exceptionThreshold=noException . The use of -D system properties for changing configuration settings is discouraged (because of the cache of the Gradle daemon). The configuration is correct if the analysis goals vulasApp , vulasA2C etc. are listed among \"Other tasks\" when running the following command: ./gradlew tasks -all The Gradle plugin only works with later releases of Gradle. How to upgrade is described here . Command-line interface \u00b6 Create a new folder, download the ZIP archive vulas-cli-<VERSION>.zip and extract it into the newly created folder. This folder will then contain the following items: Folder/File Description ./app/ Put the application code (java, class or JAR files) and all application dependencies (JAR files) into this folder. It will be searched recursively, thus, it is possible to just copy the entire installation directory of an application into the folder. Important : (1) Single java and class files are always considered as application code, no matter the package prefix configured with vulas.core.app.appPrefixes . (2) JARs are always considered as application dependency unless they only contain methods starting with the configured package prefix. (3) Nested JARs must be extracted, WARs can stay as-is. ./vulas-cli-<version>-jar-with-dependencies.jar An executable JAR used to run the different Vulas goals. ./instr/lang-java-<version>-jar-with-dependencies.jar Used to instrument Java runtimes. ./vulas-custom.properties.sample Configuration settings for Vulas. Important : (1) Rename the file to vulas-custom.properties . (2) Specify <GROUP> , <ARTIFACT> and <VERSION> of the application to be analyzed. (3) Specify how Vulas identifies your application code (either using vulas.core.app.appPrefixes or vulas.core.app.appJarNames , see below for more information). (4) Specify the workspace token vulas.core.space.token . Identification of application code : You can use vulas.core.app.appPrefixes or vulas.core.app.appJarNames to tell Vulas how to identify the code of your application, which is important for the call graph construction during the a2c reachability analysis. This analysis is not complete if not all the relevant application methods are used as entry points for the call graph construction. As such, the potential execution of vulnerable open-source methods may be missed. A good indicator to see whether specification is correct is to see whether there are items in the Dependencies tab that are created by you (or your organization), or whether there are open-source packages mentioned in the table on the Statistics tab. # Package prefix(es) of application code (multiple values to be separated by comma), only relevant for CLI vulas.core.app.appPrefixes = # Regex that identifies JARs with application code (multiple values to be separated by comma), only relevant for CLI vulas.core.app.appJarNames = Configuration \u00b6 Layered configuration principle \u00b6 The client-side analysis tools can be configured in different ways. At runtime, the following layers are combined in order to establish the effective configuration (which is printed to console upon goal execution). Java system properties : Can be specified when running java or mvn , each setting must be prefixed with -D Property files in file system : Can be specified by adding property file(s) in the folder where Vulas is executed (or any of its subfolders). The file name must adhere to the format vulas-*.properties , and its entries must be specified according to the Java spec Plugin configuration : Maven: Can be specified in the <layeredConfiguration> section of the Maven plugin Gradle: todo Environment variables : Can be specified using export (nix) and set (Windows) Property files in JAR files : Default values for many settings are set within Vulas JAR files General settings \u00b6 The following settings, however, have to be present for every goal execution: vulas.core.space.token : The token of the workspace to be used for the analysis vulas.core.appContext.group , vulas.core.appContext.artifact and vulas.core.appContext.version : Altogether, they uniquely identify an application within a space. Depending on the client used, one or more of them are automatically inferred, e.g., using data from pom.xml or build.gradle . vulas.shared.backend.serviceUrl : The URL of the backend service to which clients upload analysis results. Check setup \u00b6 Proceed as follows to check whether the Vulas setup and goal execution works: On the client , after executing a specific Vulas goal on your application, a log entry similar to the one below should be printed to the console. It is used to upload goal-related information to the Vulas backend, e.g., the Vulas version used or the average memory consumption. In this example, information related to a goal execution for an application with GAV com.acme.foo:vulas-testapp-webapp:3.0.9-MVN was uploaded to http://vulas.mo.sap.corp:8080/backend , workspace 123456789 . The successful upload is indicated by the HTTP response code 201 . [main] INFO com.sap.psr.vulas.backend.requests.BasicHttpRequest - HTTP POST [uri=http://vulas.mo.sap.corp:8080/backend/apps/com.acme.foo/vulas-testapp-webapp/3.0.9-MVN/goals, size=23,50 KB, tenant=123456789, space=123456789] [main] INFO com.sap.psr.vulas.backend.requests.BasicHttpRequest - HTTP POST completed with response code [201] in [03.019 ms] (proxy=false) In the apps Web frontend at https://vulas.mo.sap.corp/apps , there are several tabs to be checked: On the Dependencies tab, one should see all application dependencies. In particular, there should be no archives belonging to the application under analysis (which can happen if the CLI is not configured to properly separate application code and dependency code, see here for more information). On the Statistics tab, one should see all packages belonging to the application. In particular, there should be no packages belonging to 3 rd party / open-source libraries (which can happen if the CLI is not configured to properly separate application code and dependency code, see here for more information). On the History tab, one should see table entries for all goal executions that happened on the client.","title":"Configuration"},{"location":"user/manuals/setup/#setup-and-configuration-guide","text":"","title":"Setup and Configuration Guide"},{"location":"user/manuals/setup/#workspace","text":"A workspace acts as a container to group the results of several application analyses. In that context, please note that each module of a multi-module Maven project appears as a separate application in the Vulas Web frontend. Before using workspaces, you need to create one using the Vulas Web frontend (see below); you will obtain a token that you will need to pass as a configuration parameter when performing scans.","title":"Workspace"},{"location":"user/manuals/setup/#create-workspaces-once","text":"You need to create a workspace once using the Vulas Web frontend. Use the \"create workspace\" icon in the lower-left corner toolbar of the apps Web frontend to do so. A workspace has the following properties: Name : Must be provided. Note that the name is not unique, thus, there can be several workspaces having the same name. Description : Must be provided. Contact : Please provide the email address of a distribution list (DL) matching the regex DL_[0-9A-Fa-f]*@exchange.sap.corp . Important : Either contact or PPMS object number must be provided when creating a workspace. Export results : AGGREGATED: Findings are aggregated on workspace-level, one item for the entire workspace will be exported (to Sirius/Security Hub) DETAILED: Findings are aggregated on application-level, one item for every application of the workspace will be exported OFF: No export of findings Public : A public workspace appears in the drop-down box of the apps Web frontend, a private one does not. Important: It will not be possible to retrieve the token of a private space at later points in time, thus, note it down when it is shown right after workspace creation. PPMS Object Number : If possible, provide the object number (not the name) of the PPMS Software Component Version (SCV), Product Version (PV) or Build Version (BV) corresponding to the application(s) scanned in the context of this workspace. No alphanumeric characters are allowed. The provision of the object number makes tool adoption (coverage) at SAP transparent, and allows reaching out to development teams in case of high-profile vulnerabilities (discussed in mainstream media). Example: In order to specify the PPMS object number of SAP NETWEAVER AS JAVA 7.2 (cf. screenshot), one should enter 01200314690900001979 when creating a workspace. Once the fields have been filled, press the \"Save\" button. The system then returns with a pop-up containing the random token generated upon workspace creation. Do not forget to note down this token, it will be needed later on for each scan of your application(s).","title":"Create workspace(s) (once)"},{"location":"user/manuals/setup/#use-the-generated-token-during-application-analysis","text":"The workspace token generated at previous step has to be used as value for the configuration setting vulas.core.space.token . This information is mandatory during the scans as it allows the user's data to be uploaded to the correct place/workspace in the Vulas backend. See here for more information regarding the configuration of Vulas clients.","title":"Use the generated token (during application analysis)"},{"location":"user/manuals/setup/#choose-a-workspace-in-the-apps-web-frontend","text":"Use the configuration icon in the lower-left corner in order to select a workspace. You can search for public workspaces by typing their name in the \"Space\" field. You can copy&paste the token of a private workspace into the input field in order to select it. Additional fields \"Backend URL\" and \"Artifact Analyzer URL\" can be used to connect the frontend to another backend (than the default running on the same host). Generally, this must not be changed by the users. Once you have selected a workspace, press \"Save\" button. The list of applications of that workspace will be automatically loaded on the left list menu of the frontend.","title":"Choose a workspace (in the apps Web frontend)"},{"location":"user/manuals/setup/#edit-a-workspace-in-the-apps-web-frontend","text":"In order to edit a workspace, press the same button as to choose a workspace and perform the following steps: Enter the name/token id of the workspace to edit in the \"Space\" field and eventually select one of the entries provided in the drop down list. press the \"Edit Space\" button at the bottom. Once this button is clicked, all the editable property-fields of the workspace are displayed. update/change the data of your workspace as per your expectations. Press the \"Save\" button to save your modifications, press the \"close\" button to revert your changes.","title":"Edit a workspace (in the apps Web frontend)"},{"location":"user/manuals/setup/#workspace-rest-api","text":"The REST API can be used to export findings in a machine-readable fashion. Calling HTTP GET on the following URL, for instance, returns all vulnerable dependencies of an aggregated workspace: http://vulas.mo.sap.corp:8080/backend/hubIntegration/apps/<workspace-name>%20(<workspace-token>)/vulndeps The API returns an array of JSON elements having the following data model: Property Description Possible Values projectId Identifies the affected application and dependency ( <app-GAV> > <dep-filename> ) type Identifier of vulnerability in Vulas knowledge base scope Scope of the dependency see official Maven documentation priority Priority of the finding 3 in case of dependencies with scope TEST and PROVIDED, 1 otherwise exemptionReason Assessment description (if any), see report goal for more information on how-to assess and exempt findings state Assessment result (if any) 1 (secure-by-design) in case of dependencies with scope TEST and PROVIDED, 4 (mitigated) in case the bug has been exempted, 2 (true-positive) otherwise status Indicates whether the finding has been assessed 1 (audited) in case state is 1 or 4, -1 (non-audited) otherwise count Number of findings of type type in project Always 1 snapshotDate Date of most recent goal execution of the application (any goal)","title":"Workspace REST API"},{"location":"user/manuals/setup/#setup","text":"","title":"Setup"},{"location":"user/manuals/setup/#maven","text":"The plugin for Maven can be used with or without adding a <profile> section to the pom.xml . With profile , the execution of goals is more concise (readable), e.g., mvn -Dvulas compile vulas:app . A sample profile can be found here , just copy&paste it into the <profiles> section of your pom.xml . In case of aggregated, multi-module Maven projects with modules inheriting from their parent, it is sufficient to include the profile in the top-level (parent) pom.xml . If a module does not inherit from the parent, the profile has to be added to its POM file. Without profile , the execution of goals requires the use of the plugin's fully qualified name, e.g., mvn compile com.sap.research.security.vulas:plugin-maven:3.0.12:app . Moreover, you need to specify the following mandatory configuration settings. As described here , there are several ways of doing so, however, a file as follows is very common: vulas-custom.properties vulas.core.space.token = <YOUR WORKSPACE TOKEN> vulas.shared.backend.serviceUrl = http://vulas.mo.sap.corp:8080/backend It is possible to include/exclude modules of a multi-module Maven project using the following configuration parameters: # Options to include and exclude Maven artifacts (modules) during the processing of an aggregator project. # If includes is provided, the other parameters are ignored. In other words, excludes and ignorePoms will # only be evaluated if includes is empty. # # Important: Those options are ignored in case of the report goal, thus, report will be run on all modules. # In particular, running report on a module with packaging POM will create an aggregated report for all its # submodules. # # One has to provide the artifactId (not the module name), and multiple values for includes and excludes must # be separated by comma. # # Defaults: # includes = - # excludes = - # ignorePoms = false vulas.maven.includes = vulas.maven.excludes = vulas.maven.ignorePoms = false","title":"Maven"},{"location":"user/manuals/setup/#gradle","text":"The plugin for Gradle requires changes of the following files: build.gradle buildscript { repositories { maven { url 'http://nexus.wdf.sap.corp:8081/nexus/content/repositories/build.snapshots' } mavenCentral() } dependencies { classpath('com.sap.research.security.vulas:plugin-gradle:3.0.12') { changing = true } } } allprojects { apply plugin: \"vulas\" } gradle.properties // Used to identify the scan in the apps Web frontend group = ### group - EDIT THIS ### version = ### version - EDIT THIS ### // Replace token of test space vulas.core.space.token = ### workspace token - EDIT THIS ### vulas.shared.backend.serviceUrl = http://vulas.mo.sap.corp:8080/backend Note: Rather than adding configuration settings to gradle.properties , they can also be passed as project properties in the command line, e.g., -Pvulas.report.exceptionThreshold=noException . The use of -D system properties for changing configuration settings is discouraged (because of the cache of the Gradle daemon). The configuration is correct if the analysis goals vulasApp , vulasA2C etc. are listed among \"Other tasks\" when running the following command: ./gradlew tasks -all The Gradle plugin only works with later releases of Gradle. How to upgrade is described here .","title":"Gradle"},{"location":"user/manuals/setup/#command-line-interface","text":"Create a new folder, download the ZIP archive vulas-cli-<VERSION>.zip and extract it into the newly created folder. This folder will then contain the following items: Folder/File Description ./app/ Put the application code (java, class or JAR files) and all application dependencies (JAR files) into this folder. It will be searched recursively, thus, it is possible to just copy the entire installation directory of an application into the folder. Important : (1) Single java and class files are always considered as application code, no matter the package prefix configured with vulas.core.app.appPrefixes . (2) JARs are always considered as application dependency unless they only contain methods starting with the configured package prefix. (3) Nested JARs must be extracted, WARs can stay as-is. ./vulas-cli-<version>-jar-with-dependencies.jar An executable JAR used to run the different Vulas goals. ./instr/lang-java-<version>-jar-with-dependencies.jar Used to instrument Java runtimes. ./vulas-custom.properties.sample Configuration settings for Vulas. Important : (1) Rename the file to vulas-custom.properties . (2) Specify <GROUP> , <ARTIFACT> and <VERSION> of the application to be analyzed. (3) Specify how Vulas identifies your application code (either using vulas.core.app.appPrefixes or vulas.core.app.appJarNames , see below for more information). (4) Specify the workspace token vulas.core.space.token . Identification of application code : You can use vulas.core.app.appPrefixes or vulas.core.app.appJarNames to tell Vulas how to identify the code of your application, which is important for the call graph construction during the a2c reachability analysis. This analysis is not complete if not all the relevant application methods are used as entry points for the call graph construction. As such, the potential execution of vulnerable open-source methods may be missed. A good indicator to see whether specification is correct is to see whether there are items in the Dependencies tab that are created by you (or your organization), or whether there are open-source packages mentioned in the table on the Statistics tab. # Package prefix(es) of application code (multiple values to be separated by comma), only relevant for CLI vulas.core.app.appPrefixes = # Regex that identifies JARs with application code (multiple values to be separated by comma), only relevant for CLI vulas.core.app.appJarNames =","title":"Command-line interface"},{"location":"user/manuals/setup/#configuration","text":"","title":"Configuration"},{"location":"user/manuals/setup/#layered-configuration-principle","text":"The client-side analysis tools can be configured in different ways. At runtime, the following layers are combined in order to establish the effective configuration (which is printed to console upon goal execution). Java system properties : Can be specified when running java or mvn , each setting must be prefixed with -D Property files in file system : Can be specified by adding property file(s) in the folder where Vulas is executed (or any of its subfolders). The file name must adhere to the format vulas-*.properties , and its entries must be specified according to the Java spec Plugin configuration : Maven: Can be specified in the <layeredConfiguration> section of the Maven plugin Gradle: todo Environment variables : Can be specified using export (nix) and set (Windows) Property files in JAR files : Default values for many settings are set within Vulas JAR files","title":"Layered configuration principle"},{"location":"user/manuals/setup/#general-settings","text":"The following settings, however, have to be present for every goal execution: vulas.core.space.token : The token of the workspace to be used for the analysis vulas.core.appContext.group , vulas.core.appContext.artifact and vulas.core.appContext.version : Altogether, they uniquely identify an application within a space. Depending on the client used, one or more of them are automatically inferred, e.g., using data from pom.xml or build.gradle . vulas.shared.backend.serviceUrl : The URL of the backend service to which clients upload analysis results.","title":"General settings"},{"location":"user/manuals/setup/#check-setup","text":"Proceed as follows to check whether the Vulas setup and goal execution works: On the client , after executing a specific Vulas goal on your application, a log entry similar to the one below should be printed to the console. It is used to upload goal-related information to the Vulas backend, e.g., the Vulas version used or the average memory consumption. In this example, information related to a goal execution for an application with GAV com.acme.foo:vulas-testapp-webapp:3.0.9-MVN was uploaded to http://vulas.mo.sap.corp:8080/backend , workspace 123456789 . The successful upload is indicated by the HTTP response code 201 . [main] INFO com.sap.psr.vulas.backend.requests.BasicHttpRequest - HTTP POST [uri=http://vulas.mo.sap.corp:8080/backend/apps/com.acme.foo/vulas-testapp-webapp/3.0.9-MVN/goals, size=23,50 KB, tenant=123456789, space=123456789] [main] INFO com.sap.psr.vulas.backend.requests.BasicHttpRequest - HTTP POST completed with response code [201] in [03.019 ms] (proxy=false) In the apps Web frontend at https://vulas.mo.sap.corp/apps , there are several tabs to be checked: On the Dependencies tab, one should see all application dependencies. In particular, there should be no archives belonging to the application under analysis (which can happen if the CLI is not configured to properly separate application code and dependency code, see here for more information). On the Statistics tab, one should see all packages belonging to the application. In particular, there should be no packages belonging to 3 rd party / open-source libraries (which can happen if the CLI is not configured to properly separate application code and dependency code, see here for more information). On the History tab, one should see table entries for all goal executions that happened on the client.","title":"Check setup"},{"location":"user/manuals/setup_setuptools_sap/","text":"Setuptools \u00b6 Prerequisites : - The Python packages pip and virtualenv are installed - The token of a Vulas workspace is known - setup.py is present - Java is installed Setup : 1. Create a file vulas-python.cfg in the root directory of the Python project. It should contain at least the following configuration settings: vulas.core.space.token = <YOUR WORKSPACE TOKEN> vulas.shared.backend.serviceUrl = http://vulas.mo.sap.corp:8080/backend vulas.core.backendConnection = READ_WRITE Install the plugin: pip install --upgrade vulas-plugin-setuptools . See here in case the command cannot be correctly executed.","title":"Setup setuptools sap"},{"location":"user/manuals/setup_setuptools_sap/#setuptools","text":"Prerequisites : - The Python packages pip and virtualenv are installed - The token of a Vulas workspace is known - setup.py is present - Java is installed Setup : 1. Create a file vulas-python.cfg in the root directory of the Python project. It should contain at least the following configuration settings: vulas.core.space.token = <YOUR WORKSPACE TOKEN> vulas.shared.backend.serviceUrl = http://vulas.mo.sap.corp:8080/backend vulas.core.backendConnection = READ_WRITE Install the plugin: pip install --upgrade vulas-plugin-setuptools . See here in case the command cannot be correctly executed.","title":"Setuptools"},{"location":"user/manuals/user_manual_annex_sap/","text":"SAP-specific Annex \u00b6 SAP-specific content This section complements the public official documentation of Vulas available at SAP/vulnerability-assessment-tool covering SAP-specific aspects of working with Vulas. Please check the other parts of the Vulas manual in case you are looking for some topic that is not SAP-specific. Special workspaces \u00b6 In the SAP installation of Vulas, the following two workspaces exist by default: public : This exists for backward compatibility with Vulas releases before version 3.x. Important: This workspace will made read-only in Q1 2019, thus, it is recommended that you do create a dedicated workspace for your applications. test (token BA0A5620222605DE6728594CDA4F4391): This is meant to be used for demo and training purposes, but not for productive use. The contents of this space are deleted on a regular basis without notice. Vulnerabilities in SAP proprietary libraries \u00b6 Vulas can also handle undisclosed vulnerabilities and proprietary components. This allows to make company-internal users of proprietary libraries aware and update to non-vulnerable versions. Send an email to DL VULAS in order to request the addition of such vulnerabilities to the database, and include the following info: Brief description of the vulnerability (max 2-3 lines) using the NVD vulnerability description style and phrasing (e.g., including the type of vulnerability, the affected software component). URL of the code repository of the affected component. Commit(s) used to the fix the vulnerability in the component. Links with additional information about the vulnerability (if available). Once this information is received by the Vulas team, an ID will be attributed to the vulnerability and a new entry will be created in the Vulas Database. All company-internal users will be notified in the same way as for publicly disclosed vulnerabilities in open-source components. Software Vulnerability Monitor (SVM) \u00b6 Vulas analysis results are replicated to the SVM once every night. TO_BE_DONE","title":"SAP-specific Annex"},{"location":"user/manuals/user_manual_annex_sap/#sap-specific-annex","text":"SAP-specific content This section complements the public official documentation of Vulas available at SAP/vulnerability-assessment-tool covering SAP-specific aspects of working with Vulas. Please check the other parts of the Vulas manual in case you are looking for some topic that is not SAP-specific.","title":"SAP-specific Annex"},{"location":"user/manuals/user_manual_annex_sap/#special-workspaces","text":"In the SAP installation of Vulas, the following two workspaces exist by default: public : This exists for backward compatibility with Vulas releases before version 3.x. Important: This workspace will made read-only in Q1 2019, thus, it is recommended that you do create a dedicated workspace for your applications. test (token BA0A5620222605DE6728594CDA4F4391): This is meant to be used for demo and training purposes, but not for productive use. The contents of this space are deleted on a regular basis without notice.","title":"Special workspaces"},{"location":"user/manuals/user_manual_annex_sap/#vulnerabilities-in-sap-proprietary-libraries","text":"Vulas can also handle undisclosed vulnerabilities and proprietary components. This allows to make company-internal users of proprietary libraries aware and update to non-vulnerable versions. Send an email to DL VULAS in order to request the addition of such vulnerabilities to the database, and include the following info: Brief description of the vulnerability (max 2-3 lines) using the NVD vulnerability description style and phrasing (e.g., including the type of vulnerability, the affected software component). URL of the code repository of the affected component. Commit(s) used to the fix the vulnerability in the component. Links with additional information about the vulnerability (if available). Once this information is received by the Vulas team, an ID will be attributed to the vulnerability and a new entry will be created in the Vulas Database. All company-internal users will be notified in the same way as for publicly disclosed vulnerabilities in open-source components.","title":"Vulnerabilities in SAP proprietary libraries"},{"location":"user/manuals/user_manual_annex_sap/#software-vulnerability-monitor-svm","text":"Vulas analysis results are replicated to the SVM once every night. TO_BE_DONE","title":"Software Vulnerability Monitor (SVM)"},{"location":"user/support/","text":"Getting help \u00b6 User support \u00b6 If you would like to try Vulas and you do not know where to start, our Tutorials provides a gentle, step-by-step walkthrough of your first scan. Also, an extensive documentation of all features, options and configuration settings can be found in User Manual . If you run into trouble, please take a look at: the list of general Frequently Asked Questions , and the list of SAP-specific Frequently Asked Questions . Bug reports \u00b6 If you encounter a bug while using Vulas, you are welcome to open an issue on Jira giving a detailed description of what happened so that we can diagnose and resolve the problem (please, do search among the currently open issues to check if someone else has already reported the same problem). Receive news \u00b6 You can subscribe to our newsletter in case you want to receive updates by email.","title":"Getting help"},{"location":"user/support/#getting-help","text":"","title":"Getting help"},{"location":"user/support/#user-support","text":"If you would like to try Vulas and you do not know where to start, our Tutorials provides a gentle, step-by-step walkthrough of your first scan. Also, an extensive documentation of all features, options and configuration settings can be found in User Manual . If you run into trouble, please take a look at: the list of general Frequently Asked Questions , and the list of SAP-specific Frequently Asked Questions .","title":"User support"},{"location":"user/support/#bug-reports","text":"If you encounter a bug while using Vulas, you are welcome to open an issue on Jira giving a detailed description of what happened so that we can diagnose and resolve the problem (please, do search among the currently open issues to check if someone else has already reported the same problem).","title":"Bug reports"},{"location":"user/support/#receive-news","text":"You can subscribe to our newsletter in case you want to receive updates by email.","title":"Receive news"},{"location":"user/support/faq/","text":"Warning This page provides answers and solutions to frequent questions and problems of Vulas end-users. Please review this material carefully before asking support, filing bug reports, or requesting new features. Only if you cannot find an answer to your questions in this page, please see the help to learn how to get support. LIST OF QUESTIONS General questions Why can't I compile my Maven project anymore after I activate the Vulas profile? Why does Vulas backend refuse HTTP connections established by Vulas Maven plugin? Why do all HTTP connections fail from the Vulas Maven plugin? Why does my workspace stay empty? What is the cause of the following ERROR: vulas-maven-plugin:3.x.x or one of its dependencies could not be resolved? Why do I get the following message: WARN: App does not exist in backend, goal upload skipped? Understanding the results produced by Vulas Vulas reported vulnerabilities for which I found no data in NVD. What should I do about them? Why is Vulas is not detecting all vulnerabilities of my project? Method-level bill of material (goal app) app : NotFoundException when analyzing JAR files? app : The goal execution takes very long app : The goal execution breaks with a 5xx response code received from the backend Reachability Analysis (goals a2c and t2c) a2c : java.lang.OutOfMemoryError a2c : Timeout during reachability analysis a2c : java.io.FileNotFoundException? a2c : Invalid byte code in method? Instrumentation and trace collection (goals test and instr) TEST : java.lang.NoSuchMethodError? TEST : Not all Vulas analysis results are uploaded to the backend TEST : How to run -Dvulas test in projects using Mockito? TEST : Byte code instrumentation fails TEST : The forked VM terminated TEST : Incomplete app context JUnit tests using Powermock fail when using Vulas Python app goal is slow virtualenv problems Other topics report: The HTML result report is not properly rendered inside Jenkins No log messages of the Vulas Maven plugin appear on the console. Why? OutOfMemoryError: GC overhead limit exceeded? I get an error saying VerifyError: Inconsistent stackmap frames at branch target. What should I do? General questions \u00b6 Why can't I compile my Maven project anymore after I activate the Vulas profile? \u00b6 You may want to check whether there are other <profile> sections that declare dependencies. If so, one of those is probably activated by default. In this case, when using the Vulas profile, those other profiles will not be active, hence, there are dependencies missing, which can lead to compile exceptions. To fix, you should activate multiple profiles at once using the -P option, see here for more information. Why does Vulas backend refuse HTTP connections established by Vulas Maven plugin? \u00b6 The Vulas plugins gathers very detailed information about all Java archives required by an application. For example, it collects the method signatures of all methods contained in every JAR. For every archive, identified by its SHA1, this information must be uploaded to and stored by the Vulas backend in case it is not yet known. This requirement will cause a lot of uploads when an application is first analyzed, because a lot of dependencies may not be known. Problem: As a result of the above, it can happen that several HTTP POST connection requests are refused by the Vulas backend during the Vulas Maven plugin execution, which will result in error messages as follows. Copy&paste from console Solution Vulas plugin users can simply re-run the Vulas goal \"app\" multiple times up until the information for all archives has been uploaded. With each run, more and more archives will be successfully uploaded, up until a point where every archive is known. According to our experience, this is the case after a few runs only ( <5 ). Why do all HTTP connections fail from the Vulas Maven plugin? \u00b6 Problem Not a single HTTP connection can be established, which becomes obvious if even the first connection request hangs for several minutes and eventually fails as follows: [INFO] ------------------------------------------------------------------------ [INFO] Building com.at.example.spring-01 0.0.1-SNAPSHOT [INFO] ------------------------------------------------------------------------ [INFO] [INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ com.at.example.spring-01 --- [INFO] Deleting C:\\My Documents\\com.at.example.spring-01\\target [INFO] [INFO] --- maven-dependency-plugin:2.10:copy (copy-vulas) @ com.at.example.spring-01 --- [INFO] Configured Artifact: com.sap.research.security.vulas:vulas-core:jar-with-dependencies:1.1.0-SNAPSHOT:jar [INFO] Configured Artifact: com.sap.research.security.vulas:vulas-core:jar-with-dependencies:1.1.0-SNAPSHOT:jar [INFO] Copying vulas-core-1.1.0-SNAPSHOT-jar-with-dependencies.jar to C:\\My Documents\\com.at.example.spring-01\\target\\vulas\\lib\\vulas-core-1.1.0-SNAPSHOT-jar-with-dependencies.jar [INFO] Copying vulas-core-1.1.0-SNAPSHOT-jar-with-dependencies.jar to C:\\My Documents\\com.at.example.spring-01\\target\\vulas\\include\\vulas-core-1.1.0-SNAPSHOT-jar-with-dependencies.jar [INFO] [INFO] --- vulas-maven-plugin:1.1.0-SNAPSHOT:clean (vulas-clean) @ com.at.example.spring-01 --- [main] INFO com.sap.psr.vulas.GoalExecution - Vulas goal execution started [id=CLEAN-1448374577441-14554386, goal=CLEAN, app=(com.at.example:com.at.example.spring-01:jar:0.0.1-SNAPSHOT)] [main] INFO com.sap.psr.vulas.backend.Collector - HTTP request started [url=, user=] [vulas-memo] INFO com.sap.psr.vulas.GoalExecution - Memory consumption (used/avg): [57.75 MB/57.75 MB], JVM (free/total/max): [183.75 MB/241.50 MB/3559.50 MB] [main] ERROR com.sap.psr.vulas.backend.Collector - HTTP request error while calling [], HTTP response written to [C:\\Users\\iXXXXXX\\AppData\\Local\\Temp\\vulas-tmp-8966348801119324800.html] Solution Run the Vulas Maven plugin with a different proxy than the default proxy specified in the configuration ( proxy.wdf.sap.corp ). You need to change 2 settings: On the command line, run Maven as follows, whereby <proxy> can be proxy.par.sap.corp or simply proxy mvn -Dhttp.proxyHost = <proxy> -Dvulas vulas:app In the Maven Surefire plugin, include the -Dhttp.proxyHost system property for the JVM spawned for JUnit tests: <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-surefire-plugin </artifactId> <version> 2.14 </version> <configuration> <argLine> ... -Dhttp.proxyHost=proxy.par.sap.corp ... </argLine> </configuration> </plugin> Why does my workspace stay empty? \u00b6 When executing a vulas goal, your workspace is not filled with the results of the scan. Instead of this your results are usually uploaded to the PUBLIC workspace of the Vulas Frontend. You first need to insure that you are using at least version 3.0 of Vulas. The workspace feature was introduced with Vulas 3. By default, if you are running Vulas 2.x (and you should not!) all the data are stored in the \"PUBLIC\" workspace in the Vulas Frontend. Please notice that the Vulas plugin name was changed with Vulas 3: it was changed from vulas-maven-plugin to plugin-maven (click here for more details). It is quite usual that developers working with Jenkins/Piper are pointing to an old version of Vulas (2.x) because their Jenkins/Piper platform itself points to the old Vulas plugin name. A simple update there usually solves the issue. You need to insure that you have correctly indicated to Vulas where to upload the results of your scans (e.g. in your workspace). Please click here and here for details about workspaces and how to use them. What is the cause of the following ERROR: vulas-maven-plugin:3.x.x or one of its dependencies could not be resolved ? \u00b6 You are running the execution of a maven goal and are facing an error similar to the following one: [ERROR] Plugin com.sap.research.security.vulas:vulas-maven-plugin:3.0.8 or one of its dependencies could not be resolved: Could not find artifact com.sap.research.security.vulas:vulas-maven-plugin:jar:3.0.8 in mirror1 (url) -> [Help 1] You most probably updated your settings to use Maven 3.x instead of Maven 2.x. The Vulas plugin was renamed with Vulas 3.x: it was changed from vulas-maven-plugin to plugin-maven . You may need to update your settings accordingly (click here for more details on how to update your settings). Why do I get the following message: WARN: App does not exist in backend, goal upload skipped ? \u00b6 Symptom : The console contains a log message as follows: WARN com.sap.psr.vulas.backend.BackendConnector - App [group=com.acme, artifact=parent, version=1-SNAPSHOT, packaging=pom] does not exist in backend, goal upload skipped Explanation : Information related to the execution of a goal, e.g., execution time or memory consumption, cannot be uploaded as the respective application does not exist in the backend. This is not necessarily a problem, hence, the message is issued as warning. Examples where an application does not exist in the backend are as follows: If an application does neither have any dependencies nor source code, e.g., in folder src/main/java , it will not be uploaded to the backend (depending on configuration parameter vulas.core.app.uploadEmpty , which defaults to false ). In this case, the execution of goal execution information cannot be uploaded. Typical examples of empty applications are Maven aggregator projects ( <packaging>pom</packaging> ). If an application version is analyzed for the first time, the initial execution of the clean goal will also result in this warning message. Understanding the results produced by Vulas \u00b6 Vulas reported vulnerabilities for which I found no data in NVD. What should I do about them? \u00b6 For vulnerabilities that do not come from the NVD we do provide reference links. They are listed in the vulnerability details page accessible clicking on the different rows of the vulnerability main table (see example below). Why is Vulas is not detecting all vulnerabilities of my project? \u00b6 If the vulnerability is included in our knowledge base but it is not detected for your application, you can select the checkbox \u201cInclude historical vulnerabilities\u201d in the Vulas frontend and hit \u201cReload\u201d button: you will see all CVEs that applied to previous versions of your dependencies. The indicates that a given CVE did apply to earlier versions, but you are currently using a non-vulnerable one. Despite our best efforts to keep the Vulas vulnerability knowledge base continuously updated, it is possible that a particular vulnerability is not yet covered. See here to check if a vulnerability is covered or not. In case it is not covered, please contact the Vulas team which will react accordingly. Method-level bill of material (goal app) \u00b6 app : NotFoundException when analyzing JAR files? \u00b6 Problem: When analyzing JAR files, error messages similar to the following are printed: ERROR com.sap.psr.vulas.JarAnalyzer - JarAnalyzer[jar/war=org.apache.servicemix.bundles.jaxb-xjc-2.2.4_1.jar, mavenId=(org.apache.servicemix.bundles:org.apache.servicemix.bundles.jaxb-xjc:2.2.4_1), instr=false, instrCtx=(com.acme:foo:pom:1.0-SNAPSHOT)]: NotFoundException while analyzing class [1.0.com.sun.xml.xsom.parser.JAXPParser]: 1.0.com.sun.xml.xsom.parser.JAXPParser Explanation: This can be due to the use of Java identifiers that do not confirm with the Java language specification . In this example, the actual package name of \"1.0.com.sun.xml.xsom.parser.JAXPParser\", as seen in the JAR file, is \"1.0\". Vulas, however, uses dots for separating package identifiers. Note: As of Java 9, multi-release archives can contain class files in subdirectories. They are not yet supported by Vulas. Solution: Not yet known. For the time being, clarify who produced the respective JAR file. app : The goal execution takes very long \u00b6 Problem: The execution of the APP goal takes very long. Explanation: Whenever a JAR, identified by its SHA1, is unknown to the backend, all its method signatures are gathered and uploaded. As a result, the first execution(s) of vulas:app can take some time, as any yet unknown JAR need to be covered. Future executions will be significantly faster. app : The goal execution breaks with a 5xx response code received from the backend \u00b6 Problem: The goal execution breaks with a 5xx response code received from the backend. Explanation: This can happen if multiple processes (on the same computer or remotely) try to upload the same method signature to the backend. In such cases, one can simply restart at a later time to avoid the clash. Reachability Analysis (goals a2c and t2c) \u00b6 a2c : java.lang.OutOfMemoryError \u00b6 Solutions: Increase the maximum and minimum JVM heap space with -Xmx and -Xms . Prior to Java8, also add -XX:MaxPermSize=2g -XX:+CMSClassUnloadingEnabled . a2c : Timeout during reachability analysis \u00b6 Problem: The execution of the reachability analysis causes a timeout, e.g., [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - [vulas-reach-7] reached timeout and will be interrupted [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.util.intset.BitVectorIntSet.<init>(BitVectorIntSet.java:45) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.util.intset.BitVectorIntSet.addAllOblivious(BitVectorIntSet.java:126) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.util.intset.MutableSharedBitVectorIntSet.makeDenseCopy(MutableSharedBitVectorIntSet.java:984) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.util.intset.MutableSharedBitVectorIntSet.addAll(MutableSharedBitVectorIntSet.java:752) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.util.intset.MutableSharedBitVectorIntSet.addAllInIntersectionInternal(MutableSharedBitVectorIntSet.java:1067) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.util.intset.MutableSharedBitVectorIntSet.addAllInIntersection(MutableSharedBitVectorIntSet.java:1032) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.fixpoint.IntSetVariable.addAllInIntersection(IntSetVariable.java:175) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.fixpoint.IntSetVariable.addAllInIntersection(IntSetVariable.java:158) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.ipa.callgraph.propagation.FilteredPointerKey$SingleClassFilter.addFiltered(FilteredPointerKey.java:65) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.ipa.callgraph.propagation.PropagationCallGraphBuilder$FilterOperator.evaluate(PropagationCallGraphBuilder.java:623) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.ipa.callgraph.propagation.PropagationCallGraphBuilder$FilterOperator.evaluate(PropagationCallGraphBuilder.java:1) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.fixpoint.UnaryStatement.evaluate(UnaryStatement.java:36) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.fixedpoint.impl.AbstractFixedPointSolver.solve(AbstractFixedPointSolver.java:150) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.ipa.callgraph.propagation.StandardSolver.solve(StandardSolver.java:40) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.ipa.callgraph.propagation.PropagationCallGraphBuilder.makeCallGraph(PropagationCallGraphBuilder.java:269) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.sap.psr.vulas.cg.wala.WalaCallgraphConstructor.buildCallgraph(WalaCallgraphConstructor.java:308) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.sap.psr.vulas.cg.ReachabilityAnalyzer.run(ReachabilityAnalyzer.java:265) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - java.lang.Thread.run(Thread.java:745) [main] ERROR com.sap.psr.vulas.cg.ReachabilityAnalyzer - [vulas-reach-7] terminated w/o success after [ 15,0 min] Solution(s): Increase the timeout by changing the configuration setting vulas.reach.timeout , e.g., mvn -Dvulas.reach.timeout=600 -Dvulas compile vulas:a2c Decrease the precision of the call graph construction, e.g., by changing the system property vulas.reach.wala.callgraph.reflection . For instance, run the reachability analysis as follows: mvn -Dvulas vulas:a2c -Dcallgraph.reflection=NONE . See manual/analysis#a2c for more configuration options. a2c : java.io.FileNotFoundException? \u00b6 Problem: During a2c , a given JAR cannot be found by Wala, which produces an error message as following: Exception in thread \"vulas-reach-1\" com.ibm.wala.util.debug.UnimplementedError: java.io.FileNotFoundException: .\\InfoView\\dep\\BOE\\WEB-INF\\eclipse\\plugins\\axis2\\lib\\jaxb-api.jar (The system cannot find the file specified) Solution(s): Set the configuration parameter vulas.reach.preprocessDependencies to true Explanation: The problem occurs if the MANIFEST file of a JAR refers to other dependencies using the Class-Path entry. Wala, for instance, will try to resolve those dependencies. The pre-processing will remove the corresponding manifest file entries. a2c : Invalid byte code in method? \u00b6 Problem: During a2c or t2c , the call graph construction by Wala fails with an error message as follows: error: invalid byte code in method org.springframework.asm.ClassReader.readConst(I[C)Ljava/lang/Object; Exception in thread \"vulas-reach-1\" com.ibm.wala.util.debug.UnimplementedError at com.ibm.wala.util.debug.Assertions.UNREACHABLE(Assertions.java:46) at com.ibm.wala.classLoader.ShrikeCTMethod.makeDecoder(ShrikeCTMethod.java:107) Solution: Append the respective package to the configuration setting vulas.reach.wala.callgraph.exclusions , which lists all the Java packages to be ignored by Wala. Note that dots (.) separating package names are replaced by slash (/). Example: In case of the above error message, one has to add the string org/springframework/asm/.* in order to ignore all classes of package asm . The new value of the configuration setting looks as follows: vulas.reach.wala.callgraph.exclusions = java/awt/.*;javax/swing/.*;sun/awt/.*;sun/swing/.*;org/netbeans/.*;com/sun/.*;org/openide/.*;com/ibm/crypto/.*;com/ibm/security/.*;org/apache/xerces/.*;org/springframework/asm/.* Instrumentation and trace collection (goals test and instr) \u00b6 TEST : java.lang.NoSuchMethodError? \u00b6 Problem: The execution of the test phase throws a NoSuchMethodError exception. This can happen if an application makes use (directly or transitively) of an older release of a library that is also required by Vulas. In the below example, an application used commons-collections v3.0.0, while Vulas needs commons-collections v3.2.2 (whose classes are actually included in the vulas-with-dependencies.jar). ------------------------------------------------------- T E S T S ------------------------------------------------------- java.lang.reflect.InvocationTargetException at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:497) at sun.instrument.InstrumentationImpl.loadClassAndStartAgent(InstrumentationImpl.java:386) at sun.instrument.InstrumentationImpl.loadClassAndCallPremain(InstrumentationImpl.java:401) Caused by: java.lang.NoSuchMethodError: org.apache.commons.collections.CollectionUtils.isEmpty(Ljava/util/Collection;)Z at org.apache.commons.configuration.XMLConfiguration.constructHierarchy(XMLConfiguration.java:640) at org.apache.commons.configuration.XMLConfiguration.initProperties(XMLConfiguration.java:596) at org.apache.commons.configuration.XMLConfiguration.load(XMLConfiguration.java:1009) at org.apache.commons.configuration.XMLConfiguration.load(XMLConfiguration.java:972) at org.apache.commons.configuration.XMLConfiguration$XMLFileConfigurationDelegate.load(XMLConfiguration.java:1647) at org.apache.commons.configuration.AbstractFileConfiguration.load(AbstractFileConfiguration.java:324) at org.apache.commons.configuration.AbstractFileConfiguration.load(AbstractFileConfiguration.java:261) at org.apache.commons.configuration.AbstractFileConfiguration.load(AbstractFileConfiguration.java:238) at org.apache.commons.configuration.AbstractHierarchicalFileConfiguration.load(AbstractHierarchicalFileConfiguration.java:184) at org.apache.commons.configuration.DefaultConfigurationBuilder.getConfiguration(DefaultConfigurationBuilder.java:608) at org.apache.commons.configuration.DefaultConfigurationBuilder.getConfiguration(DefaultConfigurationBuilder.java:587) at com.sap.psr.vulas.monitor.DynamicTransformer.<init>(DynamicTransformer.java:81) at com.sap.psr.vulas.monitor.DynamicTransformer.getInstance(DynamicTransformer.java:304) at com.sap.psr.vulas.monitor.DynamicTransformer.premain(DynamicTransformer.java:320) ... 6 more FATAL ERROR in native method: processing of -javaagent failed Exception in thread \"main\" Solution: Change the dependency of your application to a more recent release. In the above example, the following XML snippet was added to the application's POM (which transitively depended on it): <dependency> <groupId> commons-collections </groupId> <artifactId> commons-collections </artifactId> <version> 3.2.2 </version> </dependency> TEST : Not all Vulas analysis results are uploaded to the backend \u00b6 Problem: At the end of the JUnit test case execution ( mvn -Dvulas test ), not all the Vulas analysis results are uploaded to the the Vulas backend. The reason is that the Maven Surefire Plugin kills the JVM before Vulas' shutdown hook uploaded all the data. Solution: Disable the upload by changing the Surefire configuration in the POM file as follows. The analysis results will then be written in the folder target/vulas/upload . Afterwards, run the Vulas plugin goal \"upload\" in order to upload the JSON analysis results to the backend ( mvn -Dvulas vulas:upload ). <argLine> -Dvulas.upload=false TEST : How to run -Dvulas test in projects using Mockito? \u00b6 Problem : when running mvn -Dvulas test , tests fail with an error such as org.mockito.exceptions.misusing.MissingMethodInvocationException Solution : Run your tests as usual: mvn test Then run them again with Vulas enabled to perform reachability analysis: mvn -Dmaven.test.failure.ignore = true -Dvulas test vulas:upload Alternative solutions (when running mvn -Dvulas test ) : disable selectively the failing tests ignore selected jars TEST : Byte code instrumentation fails \u00b6 Problem No traces are collected during the execution of JUnit tests, no matter which instrumentor is used. Moreover, no corresponding error messages or exceptions are printed to the console. A possible indicator of that problem is the appearance of the log message \"Completed instantiation of trace collector\" after the log message \"Tests run: XXX, Failures: XXX, Errors: XXX, Skipped: XXX, Time elapsed: XXX sec\", which signals the termination of the actual JUnit tests. Example: [main] INFO com.sap.psr.vulas.monitor.InstrumentationControl - JAR [C:\\Users\\XXXXXX\\.m2\\repository\\org\\apache\\commons\\commons-lang3\\3.2\\commons-lang3-3.2.jar] is blacklisted: [false] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.141 sec - in code.MainTest [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.backend.requests.BasicHttpRequest - HTTP GET [uri=http://vulas.mo.sap.corp:8080/backend/apps/XXXXXX/XXXXXX/XXXXXX/bugs?historical=false, proxy=false] [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.backend.requests.BasicHttpRequest - HTTP GET completed with response code [200] in [0,0573 min] [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.backend.BackendConnector - [53] constructs for [7] bugs received from backend [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.monitor.trace.TraceCollector - Completed instantiation of trace collector [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.monitor.trace.TraceCollector - No paths collected [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.monitor.trace.TraceCollector - No traces collected [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.GoalExecution - Vulas goal execution finished [id=TEST-1487175325075-7552264, goal=TEST, app=(XXXXXX:XXXXXX:XXXXXX)] in [0,0877 min] Solution Similar to the above problem, it can happen that an application depends on a previous release of Javassist. As such, methods required by Vulas are not present at the time Vulas tries to change the byte code of loaded classes. As for the previous problem, you can add an explicit dependency to the application under test in order to let Maven resolve to a recent release of Javassist. TEST : The forked VM terminated \u00b6 Problem: Tests terminate with a log message as follows: The forked VM terminated without properly saying goodbye. VM crash or System.exit called? Solutions: Increase JVM heap space by adding -Xmx4096M -Xms2048M (or more if possible) to the <argLine> argument of the Maven Surefire plugin Select an instrumentor that consumes less memory by adding, for instance, -Dvulas.core.instr.instrumentorsChoosen=com.sap.psr.vulas.monitor.trace.SingleTraceInstrumentor . TEST : Incomplete app context \u00b6 Problem: Tests terminate with the error message App context incomplete: [group=, artifact=, version=] and there exists a white space in any of the parent directories of the Maven project (e.g., C:\\My Documents\\projects\\foo ). Solutions: Move the Maven project to a location without whitespaces in the names of any of the parent directories. Open the pom.xml and replace the Maven variable ${project.build.directory} in the <argLine> configuration setting of the maven-surefire-plugi n by the relative path of the respective directory, typically target . Open the POM file and remove the -Dvulas.core.uploadDir and -Dvulas.shared.tmpDir system properties in the <argLine> configuration setting of the maven-surefire-plugin . Create two new system property variables in the configuration section of the maven-surefire-plugin as follows (see here for more information). <systemPropertyVariables> <vulas.core.uploadDir> ${project.build.directory}/vulas/upload </vulas.core.uploadDir> <vulas.shared.tmpDir> ${project.build.directory}/vulas/tmp </vulas.shared.tmpDir> </systemPropertyVariables> JUnit tests using Powermock fail when using Vulas \u00b6 Problem JUnit tests making use of Powermock fail when activating the Vulas profile. Explanation In order to collect execution traces during test execution, the Vulas agent has to be registered at the JVM. This is done in the configuration section of the surefire plugin inside the Vulas profile. The parallel use of Powermock and the Vulas agent, which modifies all the bytecode of every class loaded by the JVM, fails in certain cases. Solution(s) This problem can be solved in several ways: Ignore all test failures by adding -Dmaven.test.failure.ignore=true (also see other options of the maven-surefire-plugin ) In case of multi-module projects, continue the build of later modules using the options --fail-never or --fail-at-end (see here for more information) Exclude problematic classes from being instrumented by adding their prefixes via -Dvulas.core.instr.blacklist.classes.custom=foo.bar,bar.baz.Class,... Exclude single problematic tests by modifying the <excludes> section of the surefire configuration in the Vulas profile: <excludes> <exclude> **/doesnotexist.java </exclude> </excludes> Python \u00b6 app goal is slow \u00b6 Dependencies are analyzed by setting up a virtual environment for the respective application. The setup of such a virtualenv can take some time (no matter whether it is done in the context of Vulas or not). Moreover, whenever a Python library is found that is not yet known to the backend, its bill of material needs to be uploaded. The delay caused by this initial upload will not occur for subsequent scans. virtualenv problems \u00b6 Run virtualenv from the command line to see whether it is properly installed and working. Other topics \u00b6 report: The HTML result report is not properly rendered inside Jenkins \u00b6 Symptom : The HTML report is not properly rendered inside Jenkins (e.g., no images, no color-coding, no JavaScript, see the example screenshot below). Solution : Either (a) download a ZIP of the Vulas report (the link can be found in the upper-right corner), or (b) adjust the content security policy (CSP) of Jenkins as described here . In the latter case, you should execute the following command in the Jenkins script console (on a single line ): System . setProperty ( \"hudson.model.DirectoryBrowserSupport.CSP\" , \"sandbox allow-scripts; default-src 'none'; img-src 'self' data:; style-src 'self' 'unsafe-inline'; script-src 'unsafe-inline'\" ) No log messages of the Vulas Maven plugin appear on the console. Why? \u00b6 Symptom Vulas log messages are not printed to the console (e.g., during the execution of the Maven lifecycle phase \"test\"). Instead, the following error message is printed. ERROR StatusLogger No log4j2 configuration file found. Using default configuration: logging only errors to the console. Explanation The Vulas Maven plugin makes use of log4j version 1, a corresponding configuration file is included in its JAR file. If, however, the project under analysis makes use of log4j version 2, but does not have a log4j2.xml file in folder src/main/resources , no log message of Vulas but the above error message is printed. Still, the traces are actually collected and uploaded to the central engine. Solution Create a file src/main/resources/log4j2.xml with the following sample content (copied from here ) and adapt as needed. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <Configuration> <Appenders> <Console name= \"STDOUT\" target= \"SYSTEM_OUT\" > <PatternLayout pattern= \"%d %-5p [%t] %C{2} (%F:%L) - %m%n\" /> </Console> </Appenders> <Loggers> <Logger name= \"org.apache.log4j.xml\" level= \"info\" /> <Root level= \"info\" > <AppenderRef ref= \"STDOUT\" /> </Root> </Loggers> </Configuration> OutOfMemoryError: GC overhead limit exceeded? \u00b6 Use the command line options -Xms and -Xmx to adjust the heap memory available to the JVM. Chose a value for -Xmx that is close to your machine's physical memory. In case of Maven, use the statement export MAVEN_OPTS=\"-Xms4g -Xmx8g\" . For versions before Java 8, you should also add the options -XX:MaxPermSize=2024M -XX:+CMSClassUnloadingEnabled . Notes: See here for problems related to the heap space allocations on 32bit Java versions See here for background information on Java memory management I get an error saying VerifyError: Inconsistent stackmap frames at branch target . What should I do? \u00b6 If the execution of the Maven Surefire Plugin during the Maven lifecycle phase test fails with a java.lang.VerifyError similar to the following: [ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.16:test (default-test) on project foo-bar: Execution default-test of goal org.apache.maven.plugins:maven-surefire-plugin:2.16:test failed: There was an error in the forked process [ERROR] java.lang.VerifyError: Inconsistent stackmap frames at branch target 54 [ERROR] Exception Details: [ERROR] Location: [ERROR] com/acme/FooTest.<init>()V @54: aconst_null [ERROR] Reason: [ERROR] Type uninitializedThis (current frame, locals[0]) is not assignable to 'com/acme/FooTest' (stack map, locals[0]) [ERROR] Current Frame: [ERROR] bci: @16 [ERROR] flags: { flagThisUninit } [ERROR] locals: { uninitializedThis, null, 'java/lang/ClassLoader' } [ERROR] stack: { 'java/lang/ClassLoader', null } [ERROR] Stackmap Frame: [ERROR] bci: @54 [ERROR] flags: { } [ERROR] locals: { 'com/acme/FooTest', 'java/net/URL', 'java/lang/ClassLoader' } [ERROR] stack: { } [ERROR] Bytecode: [ERROR] 0000000: b200 bd9a 0047 014c 1235 b600 914d 2c01 [ERROR] 0000010: a500 262c bb00 9359 b700 9412 35b6 0098 [ERROR] 0000020: 102e 102f b600 9cb6 00a0 12a2 b600 a0b6 [ERROR] 0000030: 00a5 b600 ab4c 014e 12bf 2c2b 0101 0101 [ERROR] 0000040: 2d03 0304 b800 c2b3 00bd 2ab7 0001 b800 [ERROR] 0000050: 022a b600 0312 04b6 0005 4c2a 2bb8 0006 [ERROR] 0000060: b500 07b1 [ERROR] Stackmap Table: [ERROR] full_frame(@54,{Object[#53],Object[#181],Object[#167]},{}) [ERROR] full_frame(@74,{UninitializedThis},{}) [ERROR] [ERROR] at java.lang.Class.getDeclaredMethods0(Native Method) then you should include the Java option noverify in the Surefire configuration as follows: <argLine> -javaagent:target/vulas/lib/vulas-core-${vulas.version}-jar-with-dependencies.jar -DperiodicUpload.enabled=false -DappContext.fixed.groupId=${project.groupId} -DappContext.fixed.artifactId=${project.artifactId} -DappContext.fixed.version=${project.version} -noverify <!-- Uncomment to debug the test execution or the Vulas plugin --> <!-- -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000 --> </argLine> See here for more information on the noverify option: Stackoverflow Chrononsystems Informit","title":"General FAQ"},{"location":"user/support/faq/#general-questions","text":"","title":"General questions"},{"location":"user/support/faq/#why-cant-i-compile-my-maven-project-anymore-after-i-activate-the-vulas-profile","text":"You may want to check whether there are other <profile> sections that declare dependencies. If so, one of those is probably activated by default. In this case, when using the Vulas profile, those other profiles will not be active, hence, there are dependencies missing, which can lead to compile exceptions. To fix, you should activate multiple profiles at once using the -P option, see here for more information.","title":"Why can't I compile my Maven project anymore after I activate the Vulas profile?"},{"location":"user/support/faq/#why-does-vulas-backend-refuse-http-connections-established-by-vulas-maven-plugin","text":"The Vulas plugins gathers very detailed information about all Java archives required by an application. For example, it collects the method signatures of all methods contained in every JAR. For every archive, identified by its SHA1, this information must be uploaded to and stored by the Vulas backend in case it is not yet known. This requirement will cause a lot of uploads when an application is first analyzed, because a lot of dependencies may not be known. Problem: As a result of the above, it can happen that several HTTP POST connection requests are refused by the Vulas backend during the Vulas Maven plugin execution, which will result in error messages as follows. Copy&paste from console Solution Vulas plugin users can simply re-run the Vulas goal \"app\" multiple times up until the information for all archives has been uploaded. With each run, more and more archives will be successfully uploaded, up until a point where every archive is known. According to our experience, this is the case after a few runs only ( <5 ).","title":"Why does Vulas backend refuse HTTP connections established by Vulas Maven plugin?"},{"location":"user/support/faq/#why-do-all-http-connections-fail-from-the-vulas-maven-plugin","text":"Problem Not a single HTTP connection can be established, which becomes obvious if even the first connection request hangs for several minutes and eventually fails as follows: [INFO] ------------------------------------------------------------------------ [INFO] Building com.at.example.spring-01 0.0.1-SNAPSHOT [INFO] ------------------------------------------------------------------------ [INFO] [INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ com.at.example.spring-01 --- [INFO] Deleting C:\\My Documents\\com.at.example.spring-01\\target [INFO] [INFO] --- maven-dependency-plugin:2.10:copy (copy-vulas) @ com.at.example.spring-01 --- [INFO] Configured Artifact: com.sap.research.security.vulas:vulas-core:jar-with-dependencies:1.1.0-SNAPSHOT:jar [INFO] Configured Artifact: com.sap.research.security.vulas:vulas-core:jar-with-dependencies:1.1.0-SNAPSHOT:jar [INFO] Copying vulas-core-1.1.0-SNAPSHOT-jar-with-dependencies.jar to C:\\My Documents\\com.at.example.spring-01\\target\\vulas\\lib\\vulas-core-1.1.0-SNAPSHOT-jar-with-dependencies.jar [INFO] Copying vulas-core-1.1.0-SNAPSHOT-jar-with-dependencies.jar to C:\\My Documents\\com.at.example.spring-01\\target\\vulas\\include\\vulas-core-1.1.0-SNAPSHOT-jar-with-dependencies.jar [INFO] [INFO] --- vulas-maven-plugin:1.1.0-SNAPSHOT:clean (vulas-clean) @ com.at.example.spring-01 --- [main] INFO com.sap.psr.vulas.GoalExecution - Vulas goal execution started [id=CLEAN-1448374577441-14554386, goal=CLEAN, app=(com.at.example:com.at.example.spring-01:jar:0.0.1-SNAPSHOT)] [main] INFO com.sap.psr.vulas.backend.Collector - HTTP request started [url=, user=] [vulas-memo] INFO com.sap.psr.vulas.GoalExecution - Memory consumption (used/avg): [57.75 MB/57.75 MB], JVM (free/total/max): [183.75 MB/241.50 MB/3559.50 MB] [main] ERROR com.sap.psr.vulas.backend.Collector - HTTP request error while calling [], HTTP response written to [C:\\Users\\iXXXXXX\\AppData\\Local\\Temp\\vulas-tmp-8966348801119324800.html] Solution Run the Vulas Maven plugin with a different proxy than the default proxy specified in the configuration ( proxy.wdf.sap.corp ). You need to change 2 settings: On the command line, run Maven as follows, whereby <proxy> can be proxy.par.sap.corp or simply proxy mvn -Dhttp.proxyHost = <proxy> -Dvulas vulas:app In the Maven Surefire plugin, include the -Dhttp.proxyHost system property for the JVM spawned for JUnit tests: <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-surefire-plugin </artifactId> <version> 2.14 </version> <configuration> <argLine> ... -Dhttp.proxyHost=proxy.par.sap.corp ... </argLine> </configuration> </plugin>","title":"Why do all HTTP connections fail from the Vulas Maven plugin?"},{"location":"user/support/faq/#why-does-my-workspace-stay-empty","text":"When executing a vulas goal, your workspace is not filled with the results of the scan. Instead of this your results are usually uploaded to the PUBLIC workspace of the Vulas Frontend. You first need to insure that you are using at least version 3.0 of Vulas. The workspace feature was introduced with Vulas 3. By default, if you are running Vulas 2.x (and you should not!) all the data are stored in the \"PUBLIC\" workspace in the Vulas Frontend. Please notice that the Vulas plugin name was changed with Vulas 3: it was changed from vulas-maven-plugin to plugin-maven (click here for more details). It is quite usual that developers working with Jenkins/Piper are pointing to an old version of Vulas (2.x) because their Jenkins/Piper platform itself points to the old Vulas plugin name. A simple update there usually solves the issue. You need to insure that you have correctly indicated to Vulas where to upload the results of your scans (e.g. in your workspace). Please click here and here for details about workspaces and how to use them.","title":"Why does my workspace stay empty?"},{"location":"user/support/faq/#what-is-the-cause-of-the-following-error-vulas-maven-plugin3xx-or-one-of-its-dependencies-could-not-be-resolved","text":"You are running the execution of a maven goal and are facing an error similar to the following one: [ERROR] Plugin com.sap.research.security.vulas:vulas-maven-plugin:3.0.8 or one of its dependencies could not be resolved: Could not find artifact com.sap.research.security.vulas:vulas-maven-plugin:jar:3.0.8 in mirror1 (url) -> [Help 1] You most probably updated your settings to use Maven 3.x instead of Maven 2.x. The Vulas plugin was renamed with Vulas 3.x: it was changed from vulas-maven-plugin to plugin-maven . You may need to update your settings accordingly (click here for more details on how to update your settings).","title":"What is the cause of the following ERROR: vulas-maven-plugin:3.x.x or one of its dependencies could not be resolved?"},{"location":"user/support/faq/#why-do-i-get-the-following-message-warn-app-does-not-exist-in-backend-goal-upload-skipped","text":"Symptom : The console contains a log message as follows: WARN com.sap.psr.vulas.backend.BackendConnector - App [group=com.acme, artifact=parent, version=1-SNAPSHOT, packaging=pom] does not exist in backend, goal upload skipped Explanation : Information related to the execution of a goal, e.g., execution time or memory consumption, cannot be uploaded as the respective application does not exist in the backend. This is not necessarily a problem, hence, the message is issued as warning. Examples where an application does not exist in the backend are as follows: If an application does neither have any dependencies nor source code, e.g., in folder src/main/java , it will not be uploaded to the backend (depending on configuration parameter vulas.core.app.uploadEmpty , which defaults to false ). In this case, the execution of goal execution information cannot be uploaded. Typical examples of empty applications are Maven aggregator projects ( <packaging>pom</packaging> ). If an application version is analyzed for the first time, the initial execution of the clean goal will also result in this warning message.","title":"Why do I get the following message: WARN: App does not exist in backend, goal upload skipped?"},{"location":"user/support/faq/#understanding-the-results-produced-by-vulas","text":"","title":"Understanding the results produced by Vulas"},{"location":"user/support/faq/#vulas-reported-vulnerabilities-for-which-i-found-no-data-in-nvd-what-should-i-do-about-them","text":"For vulnerabilities that do not come from the NVD we do provide reference links. They are listed in the vulnerability details page accessible clicking on the different rows of the vulnerability main table (see example below).","title":"Vulas reported vulnerabilities for which I found no data in NVD. What should I do about them?"},{"location":"user/support/faq/#why-is-vulas-is-not-detecting-all-vulnerabilities-of-my-project","text":"If the vulnerability is included in our knowledge base but it is not detected for your application, you can select the checkbox \u201cInclude historical vulnerabilities\u201d in the Vulas frontend and hit \u201cReload\u201d button: you will see all CVEs that applied to previous versions of your dependencies. The indicates that a given CVE did apply to earlier versions, but you are currently using a non-vulnerable one. Despite our best efforts to keep the Vulas vulnerability knowledge base continuously updated, it is possible that a particular vulnerability is not yet covered. See here to check if a vulnerability is covered or not. In case it is not covered, please contact the Vulas team which will react accordingly.","title":"Why is Vulas is not detecting all vulnerabilities of my project?"},{"location":"user/support/faq/#method-level-bill-of-material-goal-app","text":"","title":"Method-level bill of material (goal app)"},{"location":"user/support/faq/#app-notfoundexception-when-analyzing-jar-files","text":"Problem: When analyzing JAR files, error messages similar to the following are printed: ERROR com.sap.psr.vulas.JarAnalyzer - JarAnalyzer[jar/war=org.apache.servicemix.bundles.jaxb-xjc-2.2.4_1.jar, mavenId=(org.apache.servicemix.bundles:org.apache.servicemix.bundles.jaxb-xjc:2.2.4_1), instr=false, instrCtx=(com.acme:foo:pom:1.0-SNAPSHOT)]: NotFoundException while analyzing class [1.0.com.sun.xml.xsom.parser.JAXPParser]: 1.0.com.sun.xml.xsom.parser.JAXPParser Explanation: This can be due to the use of Java identifiers that do not confirm with the Java language specification . In this example, the actual package name of \"1.0.com.sun.xml.xsom.parser.JAXPParser\", as seen in the JAR file, is \"1.0\". Vulas, however, uses dots for separating package identifiers. Note: As of Java 9, multi-release archives can contain class files in subdirectories. They are not yet supported by Vulas. Solution: Not yet known. For the time being, clarify who produced the respective JAR file.","title":"app : NotFoundException when analyzing JAR files?"},{"location":"user/support/faq/#app-the-goal-execution-takes-very-long","text":"Problem: The execution of the APP goal takes very long. Explanation: Whenever a JAR, identified by its SHA1, is unknown to the backend, all its method signatures are gathered and uploaded. As a result, the first execution(s) of vulas:app can take some time, as any yet unknown JAR need to be covered. Future executions will be significantly faster.","title":"app : The goal execution takes very long"},{"location":"user/support/faq/#app-the-goal-execution-breaks-with-a-5xx-response-code-received-from-the-backend","text":"Problem: The goal execution breaks with a 5xx response code received from the backend. Explanation: This can happen if multiple processes (on the same computer or remotely) try to upload the same method signature to the backend. In such cases, one can simply restart at a later time to avoid the clash.","title":"app : The goal execution breaks with a 5xx response code received from the backend"},{"location":"user/support/faq/#reachability-analysis-goals-a2c-and-t2c","text":"","title":"Reachability Analysis (goals a2c and t2c)"},{"location":"user/support/faq/#a2c-javalangoutofmemoryerror","text":"Solutions: Increase the maximum and minimum JVM heap space with -Xmx and -Xms . Prior to Java8, also add -XX:MaxPermSize=2g -XX:+CMSClassUnloadingEnabled .","title":"a2c : java.lang.OutOfMemoryError"},{"location":"user/support/faq/#a2c-timeout-during-reachability-analysis","text":"Problem: The execution of the reachability analysis causes a timeout, e.g., [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - [vulas-reach-7] reached timeout and will be interrupted [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.util.intset.BitVectorIntSet.<init>(BitVectorIntSet.java:45) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.util.intset.BitVectorIntSet.addAllOblivious(BitVectorIntSet.java:126) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.util.intset.MutableSharedBitVectorIntSet.makeDenseCopy(MutableSharedBitVectorIntSet.java:984) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.util.intset.MutableSharedBitVectorIntSet.addAll(MutableSharedBitVectorIntSet.java:752) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.util.intset.MutableSharedBitVectorIntSet.addAllInIntersectionInternal(MutableSharedBitVectorIntSet.java:1067) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.util.intset.MutableSharedBitVectorIntSet.addAllInIntersection(MutableSharedBitVectorIntSet.java:1032) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.fixpoint.IntSetVariable.addAllInIntersection(IntSetVariable.java:175) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.fixpoint.IntSetVariable.addAllInIntersection(IntSetVariable.java:158) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.ipa.callgraph.propagation.FilteredPointerKey$SingleClassFilter.addFiltered(FilteredPointerKey.java:65) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.ipa.callgraph.propagation.PropagationCallGraphBuilder$FilterOperator.evaluate(PropagationCallGraphBuilder.java:623) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.ipa.callgraph.propagation.PropagationCallGraphBuilder$FilterOperator.evaluate(PropagationCallGraphBuilder.java:1) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.fixpoint.UnaryStatement.evaluate(UnaryStatement.java:36) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.fixedpoint.impl.AbstractFixedPointSolver.solve(AbstractFixedPointSolver.java:150) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.ipa.callgraph.propagation.StandardSolver.solve(StandardSolver.java:40) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.ipa.callgraph.propagation.PropagationCallGraphBuilder.makeCallGraph(PropagationCallGraphBuilder.java:269) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.sap.psr.vulas.cg.wala.WalaCallgraphConstructor.buildCallgraph(WalaCallgraphConstructor.java:308) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.sap.psr.vulas.cg.ReachabilityAnalyzer.run(ReachabilityAnalyzer.java:265) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - java.lang.Thread.run(Thread.java:745) [main] ERROR com.sap.psr.vulas.cg.ReachabilityAnalyzer - [vulas-reach-7] terminated w/o success after [ 15,0 min] Solution(s): Increase the timeout by changing the configuration setting vulas.reach.timeout , e.g., mvn -Dvulas.reach.timeout=600 -Dvulas compile vulas:a2c Decrease the precision of the call graph construction, e.g., by changing the system property vulas.reach.wala.callgraph.reflection . For instance, run the reachability analysis as follows: mvn -Dvulas vulas:a2c -Dcallgraph.reflection=NONE . See manual/analysis#a2c for more configuration options.","title":"a2c : Timeout during reachability analysis"},{"location":"user/support/faq/#a2c-javaiofilenotfoundexception","text":"Problem: During a2c , a given JAR cannot be found by Wala, which produces an error message as following: Exception in thread \"vulas-reach-1\" com.ibm.wala.util.debug.UnimplementedError: java.io.FileNotFoundException: .\\InfoView\\dep\\BOE\\WEB-INF\\eclipse\\plugins\\axis2\\lib\\jaxb-api.jar (The system cannot find the file specified) Solution(s): Set the configuration parameter vulas.reach.preprocessDependencies to true Explanation: The problem occurs if the MANIFEST file of a JAR refers to other dependencies using the Class-Path entry. Wala, for instance, will try to resolve those dependencies. The pre-processing will remove the corresponding manifest file entries.","title":"a2c : java.io.FileNotFoundException?"},{"location":"user/support/faq/#a2c-invalid-byte-code-in-method","text":"Problem: During a2c or t2c , the call graph construction by Wala fails with an error message as follows: error: invalid byte code in method org.springframework.asm.ClassReader.readConst(I[C)Ljava/lang/Object; Exception in thread \"vulas-reach-1\" com.ibm.wala.util.debug.UnimplementedError at com.ibm.wala.util.debug.Assertions.UNREACHABLE(Assertions.java:46) at com.ibm.wala.classLoader.ShrikeCTMethod.makeDecoder(ShrikeCTMethod.java:107) Solution: Append the respective package to the configuration setting vulas.reach.wala.callgraph.exclusions , which lists all the Java packages to be ignored by Wala. Note that dots (.) separating package names are replaced by slash (/). Example: In case of the above error message, one has to add the string org/springframework/asm/.* in order to ignore all classes of package asm . The new value of the configuration setting looks as follows: vulas.reach.wala.callgraph.exclusions = java/awt/.*;javax/swing/.*;sun/awt/.*;sun/swing/.*;org/netbeans/.*;com/sun/.*;org/openide/.*;com/ibm/crypto/.*;com/ibm/security/.*;org/apache/xerces/.*;org/springframework/asm/.*","title":"a2c : Invalid byte code in method?"},{"location":"user/support/faq/#instrumentation-and-trace-collection-goals-test-and-instr","text":"","title":"Instrumentation and trace collection (goals test and instr)"},{"location":"user/support/faq/#test-javalangnosuchmethoderror","text":"Problem: The execution of the test phase throws a NoSuchMethodError exception. This can happen if an application makes use (directly or transitively) of an older release of a library that is also required by Vulas. In the below example, an application used commons-collections v3.0.0, while Vulas needs commons-collections v3.2.2 (whose classes are actually included in the vulas-with-dependencies.jar). ------------------------------------------------------- T E S T S ------------------------------------------------------- java.lang.reflect.InvocationTargetException at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:497) at sun.instrument.InstrumentationImpl.loadClassAndStartAgent(InstrumentationImpl.java:386) at sun.instrument.InstrumentationImpl.loadClassAndCallPremain(InstrumentationImpl.java:401) Caused by: java.lang.NoSuchMethodError: org.apache.commons.collections.CollectionUtils.isEmpty(Ljava/util/Collection;)Z at org.apache.commons.configuration.XMLConfiguration.constructHierarchy(XMLConfiguration.java:640) at org.apache.commons.configuration.XMLConfiguration.initProperties(XMLConfiguration.java:596) at org.apache.commons.configuration.XMLConfiguration.load(XMLConfiguration.java:1009) at org.apache.commons.configuration.XMLConfiguration.load(XMLConfiguration.java:972) at org.apache.commons.configuration.XMLConfiguration$XMLFileConfigurationDelegate.load(XMLConfiguration.java:1647) at org.apache.commons.configuration.AbstractFileConfiguration.load(AbstractFileConfiguration.java:324) at org.apache.commons.configuration.AbstractFileConfiguration.load(AbstractFileConfiguration.java:261) at org.apache.commons.configuration.AbstractFileConfiguration.load(AbstractFileConfiguration.java:238) at org.apache.commons.configuration.AbstractHierarchicalFileConfiguration.load(AbstractHierarchicalFileConfiguration.java:184) at org.apache.commons.configuration.DefaultConfigurationBuilder.getConfiguration(DefaultConfigurationBuilder.java:608) at org.apache.commons.configuration.DefaultConfigurationBuilder.getConfiguration(DefaultConfigurationBuilder.java:587) at com.sap.psr.vulas.monitor.DynamicTransformer.<init>(DynamicTransformer.java:81) at com.sap.psr.vulas.monitor.DynamicTransformer.getInstance(DynamicTransformer.java:304) at com.sap.psr.vulas.monitor.DynamicTransformer.premain(DynamicTransformer.java:320) ... 6 more FATAL ERROR in native method: processing of -javaagent failed Exception in thread \"main\" Solution: Change the dependency of your application to a more recent release. In the above example, the following XML snippet was added to the application's POM (which transitively depended on it): <dependency> <groupId> commons-collections </groupId> <artifactId> commons-collections </artifactId> <version> 3.2.2 </version> </dependency>","title":"TEST : java.lang.NoSuchMethodError?"},{"location":"user/support/faq/#test-not-all-vulas-analysis-results-are-uploaded-to-the-backend","text":"Problem: At the end of the JUnit test case execution ( mvn -Dvulas test ), not all the Vulas analysis results are uploaded to the the Vulas backend. The reason is that the Maven Surefire Plugin kills the JVM before Vulas' shutdown hook uploaded all the data. Solution: Disable the upload by changing the Surefire configuration in the POM file as follows. The analysis results will then be written in the folder target/vulas/upload . Afterwards, run the Vulas plugin goal \"upload\" in order to upload the JSON analysis results to the backend ( mvn -Dvulas vulas:upload ). <argLine> -Dvulas.upload=false","title":"TEST : Not all Vulas analysis results are uploaded to the backend"},{"location":"user/support/faq/#test-how-to-run-dvulas-test-in-projects-using-mockito","text":"Problem : when running mvn -Dvulas test , tests fail with an error such as org.mockito.exceptions.misusing.MissingMethodInvocationException Solution : Run your tests as usual: mvn test Then run them again with Vulas enabled to perform reachability analysis: mvn -Dmaven.test.failure.ignore = true -Dvulas test vulas:upload Alternative solutions (when running mvn -Dvulas test ) : disable selectively the failing tests ignore selected jars","title":"TEST : How to run -Dvulas test in projects using Mockito?"},{"location":"user/support/faq/#test-byte-code-instrumentation-fails","text":"Problem No traces are collected during the execution of JUnit tests, no matter which instrumentor is used. Moreover, no corresponding error messages or exceptions are printed to the console. A possible indicator of that problem is the appearance of the log message \"Completed instantiation of trace collector\" after the log message \"Tests run: XXX, Failures: XXX, Errors: XXX, Skipped: XXX, Time elapsed: XXX sec\", which signals the termination of the actual JUnit tests. Example: [main] INFO com.sap.psr.vulas.monitor.InstrumentationControl - JAR [C:\\Users\\XXXXXX\\.m2\\repository\\org\\apache\\commons\\commons-lang3\\3.2\\commons-lang3-3.2.jar] is blacklisted: [false] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.141 sec - in code.MainTest [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.backend.requests.BasicHttpRequest - HTTP GET [uri=http://vulas.mo.sap.corp:8080/backend/apps/XXXXXX/XXXXXX/XXXXXX/bugs?historical=false, proxy=false] [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.backend.requests.BasicHttpRequest - HTTP GET completed with response code [200] in [0,0573 min] [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.backend.BackendConnector - [53] constructs for [7] bugs received from backend [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.monitor.trace.TraceCollector - Completed instantiation of trace collector [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.monitor.trace.TraceCollector - No paths collected [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.monitor.trace.TraceCollector - No traces collected [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.GoalExecution - Vulas goal execution finished [id=TEST-1487175325075-7552264, goal=TEST, app=(XXXXXX:XXXXXX:XXXXXX)] in [0,0877 min] Solution Similar to the above problem, it can happen that an application depends on a previous release of Javassist. As such, methods required by Vulas are not present at the time Vulas tries to change the byte code of loaded classes. As for the previous problem, you can add an explicit dependency to the application under test in order to let Maven resolve to a recent release of Javassist.","title":"TEST : Byte code instrumentation fails"},{"location":"user/support/faq/#test-the-forked-vm-terminated","text":"Problem: Tests terminate with a log message as follows: The forked VM terminated without properly saying goodbye. VM crash or System.exit called? Solutions: Increase JVM heap space by adding -Xmx4096M -Xms2048M (or more if possible) to the <argLine> argument of the Maven Surefire plugin Select an instrumentor that consumes less memory by adding, for instance, -Dvulas.core.instr.instrumentorsChoosen=com.sap.psr.vulas.monitor.trace.SingleTraceInstrumentor .","title":"TEST : The forked VM terminated"},{"location":"user/support/faq/#test-incomplete-app-context","text":"Problem: Tests terminate with the error message App context incomplete: [group=, artifact=, version=] and there exists a white space in any of the parent directories of the Maven project (e.g., C:\\My Documents\\projects\\foo ). Solutions: Move the Maven project to a location without whitespaces in the names of any of the parent directories. Open the pom.xml and replace the Maven variable ${project.build.directory} in the <argLine> configuration setting of the maven-surefire-plugi n by the relative path of the respective directory, typically target . Open the POM file and remove the -Dvulas.core.uploadDir and -Dvulas.shared.tmpDir system properties in the <argLine> configuration setting of the maven-surefire-plugin . Create two new system property variables in the configuration section of the maven-surefire-plugin as follows (see here for more information). <systemPropertyVariables> <vulas.core.uploadDir> ${project.build.directory}/vulas/upload </vulas.core.uploadDir> <vulas.shared.tmpDir> ${project.build.directory}/vulas/tmp </vulas.shared.tmpDir> </systemPropertyVariables>","title":"TEST : Incomplete app context"},{"location":"user/support/faq/#junit-tests-using-powermock-fail-when-using-vulas","text":"Problem JUnit tests making use of Powermock fail when activating the Vulas profile. Explanation In order to collect execution traces during test execution, the Vulas agent has to be registered at the JVM. This is done in the configuration section of the surefire plugin inside the Vulas profile. The parallel use of Powermock and the Vulas agent, which modifies all the bytecode of every class loaded by the JVM, fails in certain cases. Solution(s) This problem can be solved in several ways: Ignore all test failures by adding -Dmaven.test.failure.ignore=true (also see other options of the maven-surefire-plugin ) In case of multi-module projects, continue the build of later modules using the options --fail-never or --fail-at-end (see here for more information) Exclude problematic classes from being instrumented by adding their prefixes via -Dvulas.core.instr.blacklist.classes.custom=foo.bar,bar.baz.Class,... Exclude single problematic tests by modifying the <excludes> section of the surefire configuration in the Vulas profile: <excludes> <exclude> **/doesnotexist.java </exclude> </excludes>","title":"JUnit tests using Powermock fail when using Vulas"},{"location":"user/support/faq/#python","text":"","title":"Python"},{"location":"user/support/faq/#app-goal-is-slow","text":"Dependencies are analyzed by setting up a virtual environment for the respective application. The setup of such a virtualenv can take some time (no matter whether it is done in the context of Vulas or not). Moreover, whenever a Python library is found that is not yet known to the backend, its bill of material needs to be uploaded. The delay caused by this initial upload will not occur for subsequent scans.","title":"app goal is slow"},{"location":"user/support/faq/#virtualenv-problems","text":"Run virtualenv from the command line to see whether it is properly installed and working.","title":"virtualenv problems"},{"location":"user/support/faq/#other-topics","text":"","title":"Other topics"},{"location":"user/support/faq/#report-the-html-result-report-is-not-properly-rendered-inside-jenkins","text":"Symptom : The HTML report is not properly rendered inside Jenkins (e.g., no images, no color-coding, no JavaScript, see the example screenshot below). Solution : Either (a) download a ZIP of the Vulas report (the link can be found in the upper-right corner), or (b) adjust the content security policy (CSP) of Jenkins as described here . In the latter case, you should execute the following command in the Jenkins script console (on a single line ): System . setProperty ( \"hudson.model.DirectoryBrowserSupport.CSP\" , \"sandbox allow-scripts; default-src 'none'; img-src 'self' data:; style-src 'self' 'unsafe-inline'; script-src 'unsafe-inline'\" )","title":"report: The HTML result report is not properly rendered inside Jenkins"},{"location":"user/support/faq/#no-log-messages-of-the-vulas-maven-plugin-appear-on-the-console-why","text":"Symptom Vulas log messages are not printed to the console (e.g., during the execution of the Maven lifecycle phase \"test\"). Instead, the following error message is printed. ERROR StatusLogger No log4j2 configuration file found. Using default configuration: logging only errors to the console. Explanation The Vulas Maven plugin makes use of log4j version 1, a corresponding configuration file is included in its JAR file. If, however, the project under analysis makes use of log4j version 2, but does not have a log4j2.xml file in folder src/main/resources , no log message of Vulas but the above error message is printed. Still, the traces are actually collected and uploaded to the central engine. Solution Create a file src/main/resources/log4j2.xml with the following sample content (copied from here ) and adapt as needed. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <Configuration> <Appenders> <Console name= \"STDOUT\" target= \"SYSTEM_OUT\" > <PatternLayout pattern= \"%d %-5p [%t] %C{2} (%F:%L) - %m%n\" /> </Console> </Appenders> <Loggers> <Logger name= \"org.apache.log4j.xml\" level= \"info\" /> <Root level= \"info\" > <AppenderRef ref= \"STDOUT\" /> </Root> </Loggers> </Configuration>","title":"No log messages of the Vulas Maven plugin appear on the console. Why?"},{"location":"user/support/faq/#outofmemoryerror-gc-overhead-limit-exceeded","text":"Use the command line options -Xms and -Xmx to adjust the heap memory available to the JVM. Chose a value for -Xmx that is close to your machine's physical memory. In case of Maven, use the statement export MAVEN_OPTS=\"-Xms4g -Xmx8g\" . For versions before Java 8, you should also add the options -XX:MaxPermSize=2024M -XX:+CMSClassUnloadingEnabled . Notes: See here for problems related to the heap space allocations on 32bit Java versions See here for background information on Java memory management","title":"OutOfMemoryError: GC overhead limit exceeded?"},{"location":"user/support/faq/#i-get-an-error-saying-verifyerror-inconsistent-stackmap-frames-at-branch-target-what-should-i-do","text":"If the execution of the Maven Surefire Plugin during the Maven lifecycle phase test fails with a java.lang.VerifyError similar to the following: [ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.16:test (default-test) on project foo-bar: Execution default-test of goal org.apache.maven.plugins:maven-surefire-plugin:2.16:test failed: There was an error in the forked process [ERROR] java.lang.VerifyError: Inconsistent stackmap frames at branch target 54 [ERROR] Exception Details: [ERROR] Location: [ERROR] com/acme/FooTest.<init>()V @54: aconst_null [ERROR] Reason: [ERROR] Type uninitializedThis (current frame, locals[0]) is not assignable to 'com/acme/FooTest' (stack map, locals[0]) [ERROR] Current Frame: [ERROR] bci: @16 [ERROR] flags: { flagThisUninit } [ERROR] locals: { uninitializedThis, null, 'java/lang/ClassLoader' } [ERROR] stack: { 'java/lang/ClassLoader', null } [ERROR] Stackmap Frame: [ERROR] bci: @54 [ERROR] flags: { } [ERROR] locals: { 'com/acme/FooTest', 'java/net/URL', 'java/lang/ClassLoader' } [ERROR] stack: { } [ERROR] Bytecode: [ERROR] 0000000: b200 bd9a 0047 014c 1235 b600 914d 2c01 [ERROR] 0000010: a500 262c bb00 9359 b700 9412 35b6 0098 [ERROR] 0000020: 102e 102f b600 9cb6 00a0 12a2 b600 a0b6 [ERROR] 0000030: 00a5 b600 ab4c 014e 12bf 2c2b 0101 0101 [ERROR] 0000040: 2d03 0304 b800 c2b3 00bd 2ab7 0001 b800 [ERROR] 0000050: 022a b600 0312 04b6 0005 4c2a 2bb8 0006 [ERROR] 0000060: b500 07b1 [ERROR] Stackmap Table: [ERROR] full_frame(@54,{Object[#53],Object[#181],Object[#167]},{}) [ERROR] full_frame(@74,{UninitializedThis},{}) [ERROR] [ERROR] at java.lang.Class.getDeclaredMethods0(Native Method) then you should include the Java option noverify in the Surefire configuration as follows: <argLine> -javaagent:target/vulas/lib/vulas-core-${vulas.version}-jar-with-dependencies.jar -DperiodicUpload.enabled=false -DappContext.fixed.groupId=${project.groupId} -DappContext.fixed.artifactId=${project.artifactId} -DappContext.fixed.version=${project.version} -noverify <!-- Uncomment to debug the test execution or the Vulas plugin --> <!-- -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000 --> </argLine> See here for more information on the noverify option: Stackoverflow Chrononsystems Informit","title":"I get an error saying VerifyError: Inconsistent stackmap frames at branch target. What should I do?"},{"location":"user/support/faq_sap/","text":"Sap This page provides answers and solutions to frequent questions and problems of Vulas end-users at SAP . Please review this material carefully before asking support, filing bug reports, or requesting new features. If your question is not SAP-specific, you might want to check out the general FAQ page too . Only if you cannot find an answer to your questions in this page, please see the help to learn how to get support. LIST OF QUESTIONS Vulas and SVM What is the difference between Vulas and SVM? Why does Vulas failed to identify a vulnerability that SVM did report? Vulas and PPMS I set the PPMS Object Number for my application but the scan results are not visible in PPMS, why? Why do I get an error with vulas.report.sap.scv? Vulas and WhiteSource Why should I use Vulas to scan Java instead of WhiteSource? Vulas and SourceClear What is the difference between Vulas and SourceClear? Vulas and Piper Why does Piper complain that the URL for service [backend] is not configured? Vulas-Maven command not working within Piper Python Why does pip install vulas-plugin-setuptools not work as expected? Error related to WssPythonPlugin when scanning with vulas-plugin-setuptools Security Concept How-to secure the HTTP connection between the backend and scan clients? Vulas and SVM \u00b6 What is the difference between Vulas and SVM? \u00b6 SVM and Vulas are not interchangeable and most likely you will need both. It's true that they both look for vulnerabilities in application dependencies but they do it at very different level of granularity and with completely different approaches. Vulas has a restricted scope (only Java or Python open-source components) but is very precise because of its advanced analysis capabilities, whereas SVM has a broader scope (any language, even proprietary components) but is less precise . More details Vulas is a language-specific tool that goes on code level and reports known (OSS) vulnerabilities for an application only in case vulnerable code is found in any of its direct/transitive dependencies. Moreover it offers advanced static and dynamic analysis techniques to assess whether the vulnerable code is reachable/executable. In summary it performs an application-specific assessment of the vulnerable code to support the developers in the assessment and remediation activities. The current implementation supports the analysis of Java application; Python and JavaScript are in the roadmap. The SVM is a language independent tool that sends email notifications about vulnerabilities for the software component versions (SCV) maintained in PPMS for an application. The source of vulnerabilities is the National Vulnerability DataBase (NVD) that also provides the list of affected products for each vulnerability. What the SVM does is to match the products listed by the NVD against the SCV in PPMS. It is thus a generic solution that can be used for any application but it may be subject to both false positives and false negatives. Why does Vulas failed to identify a vulnerability that SVM did report? \u00b6 To be answered. Vulas and PPMS \u00b6 I set the PPMS Object Number for my application but the scan results are not visible in PPMS, why? \u00b6 Vulas does not export findings to PPMS - the reason why you are asked for the PPMS object number when configuring Vulas is because we need to measure and report on the adoption of our tool (how many projects use open-source scanners). SVM, however, does act as a central data collector for all scan tools, including Vulas. Why do I get an error with vulas.report.sap.scv ? \u00b6 You face the following error when you run a Vulas goal: [main] ERROR com.sap.psr.vulas.shared.util.VulasConfiguration - Setting [vulas.report.sap.scv], value [xxxxxxxxxxx] does not comply with the required format [\\d+] [main] ERROR com.sap.psr.vulas.shared.util.StopWatch - [361652] [02.880 ms] Failed: org.apache.commons.configuration.ConfigurationException: The following mandatory settings are not specified: [], the following settings do not comply with the required format: [vulas.report.sap.scv] You have probably provided the wrong information for the \"vulas.report.sap.scv\" property (see xxxxxxxxxxx in previous code section). Information to be provided to Vulas for this property should be the \"PPMS object number\" and not the \"Product Version\", the \"Official Name\" nor any other value. See here for more details. Vulas and WhiteSource \u00b6 Why should I use Vulas to scan Java instead of WhiteSource? \u00b6 Because WhiteSource is based on an approach that is inherently more imprecise than Vulas, which causes more false-positives as well as more false-negatives. To be completed. Vulas and SourceClear \u00b6 What is the difference between Vulas and SourceClear? \u00b6 This question is not relevant any longer, since SourceClear is no longer available at SAP. Vulas and Piper \u00b6 Why does Piper complain that the URL for service [backend] is not configured ? \u00b6 If you are trying to run a Vulas scan in a Piper context and you see the following error: [ERROR] Failed to execute goal com.sap.research.security.vulas:vulas-maven-plugin:2.5.2:clean (default-cli) on project emAppServer: java.lang.IllegalStateException: URL for service [backend] is not configured -> [Help 1] It could be that the Vulas plugin you have defined in your pom.xml is referring to the new maven plugin plugin-maven : <!-- Vulas plugin --> <plugin> <groupId> com.sap.research.security.vulas </groupId> <artifactId> plugin-maven </artifactId> <version> ${vulas.version} </version> <configuration> <layeredConfiguration> <vulas.shared.backend.serviceUrl> ${vulas.shared.backend.serviceUrl} </vulas.shared.backend.serviceUrl> <vulas.core.space.token> ${vulas.core.space.token} </vulas.core.space.token> <vulas.core.appContext.group> ${vulas.core.appContext.group} </vulas.core.appContext.group> <vulas.core.appContext.artifact> ${vulas.core.appContext.artifact} </vulas.core.appContext.artifact> <vulas.core.appContext.version> ${vulas.core.appContext.version} </vulas.core.appContext.version> ... </layeredConfiguration> </configuration> </plugin> In this case, when running Vulas scan in Piper, Piper is referencing the old plugin name vulas-maven-plugin and does not consider the data in the pom.xml file (as it is referenced as plugin-maven ). In order to have Piper use the latest version of Vulas, please update the following Piper property: executeVulasScan script: this, vulasPlugin: 'com.sap.research.security.vulas:plugin-maven' Vulas-Maven command not working within Piper \u00b6 You can run a Vulas scan using a maven command locally on your machine (in your local shell), but the very same command does not work properly when executed in Piper environment via the executeVulasScan command. As an example the following command: mvn --batch-mode --file ./pom.xml -DskipTests -Dvulas com.sap.research.security.vulas:plugin-maven:clean compile com.sap.research.security.vulas:plugin-maven:app install successfully runs locally on your machine but if set into your Piper file, the build fails. The following points should be checked: In Piper, the default template contains a stashFiles( script: this) {} which must be kept in the node where the checkout happens, otherwise all subsequent steps will have a \"somehow\" initialized workspace. Try to avoid version rewriting for your project as described in piper documentation . Setting the vulasVersionRewrite = false, should resolve the executeVulasScan issue. Python \u00b6 Why does pip install vulas-plugin-setuptools not work as expected? \u00b6 Make sure that you have configured pip to obtain packages from the SAP repository (Nexus), which you can do by typing the following in the pip.conf file (in Linux, it is in ~/.pip/pip.conf ; create this file/directory if it does not exist): index_url = http://nexus.wdf.sap.corp:8081/nexus/content/groups/build.snapshots.pypi/simple/ trusted-host = nexus.wdf.sap.corp Error related to WssPythonPlugin when scanning with vulas-plugin-setuptools \u00b6 You are using WhiteSource in your environment and your setup.py has been modified accordingly. Your file looks like the following #!/usr/bin/env python3 # coding=utf-8 __requires__ = [ 'requests == 2.18.3' ] import pkg_resources from setuptools import setup , find_packages from plugin import WssPythonPlugin setup ( name = \"My_Project_Name\" , version = \"1.0.0\" , entry_points = { \"distutils.commands\" : [ \"whitesource_update = plugin.WssPythonPlugin:SetupToolsCommand\" ]}, install_requires = [ 'numpy==1.14.0' , 'scikit-learn==0.18.2' , 'pandas==0.20.2' , 'requests==2.18.3' , 'boto3==1.7.10' , 'rpy2==2.9.1' , 'pika==0.11.0' , 'scipy==1.0.0' ], packages = find_packages (), author = \"My_name\" , author_email = \"xxx.yyy@sap.com\" , description = \"My_Project_Description\" , ) When running the command python setup.py report you receive an error which looks like the following: Traceback (most recent call last): File \"setup.py\", line 8, in <module> from plugin import WssPythonPlugin ImportError: No module named plugin The problem is that your setup.py has been modified in order to use WhiteSource. The lines referencing WssPythonPlugin are problematic when running the Vulas scan. The following command should be used instead: grep -v \"WssPythonPlugin\" setup.py > temp && cp setup.py setup.py.backup && mv temp setup.py && python setup.py app && mv setup.py.backup setup.py This command will basically filter out of the setup.py all the references to WssPythonPlugin and then process to the standard exection. The initial setup.py file will be restored at the end of the process. Security Concept \u00b6 How-to secure the HTTP connection between the backend and scan clients? \u00b6 In order to secure connections between the backend and scan clients such as the Maven plugin, you need to add a SAP-specific X.509 certificate to the Java truststore as follows: Open the apps frontend in a browser Open the certification path of the X.509 certificate used to secure the connection to the frontend Export the X.509 certificate of SAPNetCA_G2 as .CER (base-64 encoded) and save it on your disk in folder $JAVA_HOME/jre/lib/security/ Run the following command to import this certificate to the Java truststore: keytool -import -alias SAPNetCA_G2 -file $JAVA_HOME/jre/lib/security/SAPNetCA_G2.cer -keystore $JAVA_HOME/jre/lib/security/cacerts Change the value of configuration setting vulas.shared.backend.serviceUrl to https://vulas.mo.sap.corp/backend In case of problems, use the system property -Djavax.net.debug=all in order to print debug information, or open the Java Secure Socket Extension (JSSE) Reference Guide for more information.","title":"SAP-specific FAQ"},{"location":"user/support/faq_sap/#vulas-and-svm","text":"","title":"Vulas and SVM"},{"location":"user/support/faq_sap/#what-is-the-difference-between-vulas-and-svm","text":"SVM and Vulas are not interchangeable and most likely you will need both. It's true that they both look for vulnerabilities in application dependencies but they do it at very different level of granularity and with completely different approaches. Vulas has a restricted scope (only Java or Python open-source components) but is very precise because of its advanced analysis capabilities, whereas SVM has a broader scope (any language, even proprietary components) but is less precise . More details Vulas is a language-specific tool that goes on code level and reports known (OSS) vulnerabilities for an application only in case vulnerable code is found in any of its direct/transitive dependencies. Moreover it offers advanced static and dynamic analysis techniques to assess whether the vulnerable code is reachable/executable. In summary it performs an application-specific assessment of the vulnerable code to support the developers in the assessment and remediation activities. The current implementation supports the analysis of Java application; Python and JavaScript are in the roadmap. The SVM is a language independent tool that sends email notifications about vulnerabilities for the software component versions (SCV) maintained in PPMS for an application. The source of vulnerabilities is the National Vulnerability DataBase (NVD) that also provides the list of affected products for each vulnerability. What the SVM does is to match the products listed by the NVD against the SCV in PPMS. It is thus a generic solution that can be used for any application but it may be subject to both false positives and false negatives.","title":"What is the difference between  Vulas and SVM?"},{"location":"user/support/faq_sap/#why-does-vulas-failed-to-identify-a-vulnerability-that-svm-did-report","text":"To be answered.","title":"Why does Vulas failed to identify a vulnerability that SVM did report?"},{"location":"user/support/faq_sap/#vulas-and-ppms","text":"","title":"Vulas and PPMS"},{"location":"user/support/faq_sap/#i-set-the-ppms-object-number-for-my-application-but-the-scan-results-are-not-visible-in-ppms-why","text":"Vulas does not export findings to PPMS - the reason why you are asked for the PPMS object number when configuring Vulas is because we need to measure and report on the adoption of our tool (how many projects use open-source scanners). SVM, however, does act as a central data collector for all scan tools, including Vulas.","title":"I set the PPMS Object Number for my application but the scan results are not visible in PPMS, why?"},{"location":"user/support/faq_sap/#why-do-i-get-an-error-with-vulasreportsapscv","text":"You face the following error when you run a Vulas goal: [main] ERROR com.sap.psr.vulas.shared.util.VulasConfiguration - Setting [vulas.report.sap.scv], value [xxxxxxxxxxx] does not comply with the required format [\\d+] [main] ERROR com.sap.psr.vulas.shared.util.StopWatch - [361652] [02.880 ms] Failed: org.apache.commons.configuration.ConfigurationException: The following mandatory settings are not specified: [], the following settings do not comply with the required format: [vulas.report.sap.scv] You have probably provided the wrong information for the \"vulas.report.sap.scv\" property (see xxxxxxxxxxx in previous code section). Information to be provided to Vulas for this property should be the \"PPMS object number\" and not the \"Product Version\", the \"Official Name\" nor any other value. See here for more details.","title":"Why do I get an error with vulas.report.sap.scv?"},{"location":"user/support/faq_sap/#vulas-and-whitesource","text":"","title":"Vulas and WhiteSource"},{"location":"user/support/faq_sap/#why-should-i-use-vulas-to-scan-java-instead-of-whitesource","text":"Because WhiteSource is based on an approach that is inherently more imprecise than Vulas, which causes more false-positives as well as more false-negatives. To be completed.","title":"Why should I use  Vulas to scan Java instead of WhiteSource?"},{"location":"user/support/faq_sap/#vulas-and-sourceclear","text":"","title":"Vulas and SourceClear"},{"location":"user/support/faq_sap/#what-is-the-difference-between-vulas-and-sourceclear","text":"This question is not relevant any longer, since SourceClear is no longer available at SAP.","title":"What is the difference between  Vulas and SourceClear?"},{"location":"user/support/faq_sap/#vulas-and-piper","text":"","title":"Vulas and Piper"},{"location":"user/support/faq_sap/#why-does-piper-complain-that-the-url-for-service-backend-is-not-configured","text":"If you are trying to run a Vulas scan in a Piper context and you see the following error: [ERROR] Failed to execute goal com.sap.research.security.vulas:vulas-maven-plugin:2.5.2:clean (default-cli) on project emAppServer: java.lang.IllegalStateException: URL for service [backend] is not configured -> [Help 1] It could be that the Vulas plugin you have defined in your pom.xml is referring to the new maven plugin plugin-maven : <!-- Vulas plugin --> <plugin> <groupId> com.sap.research.security.vulas </groupId> <artifactId> plugin-maven </artifactId> <version> ${vulas.version} </version> <configuration> <layeredConfiguration> <vulas.shared.backend.serviceUrl> ${vulas.shared.backend.serviceUrl} </vulas.shared.backend.serviceUrl> <vulas.core.space.token> ${vulas.core.space.token} </vulas.core.space.token> <vulas.core.appContext.group> ${vulas.core.appContext.group} </vulas.core.appContext.group> <vulas.core.appContext.artifact> ${vulas.core.appContext.artifact} </vulas.core.appContext.artifact> <vulas.core.appContext.version> ${vulas.core.appContext.version} </vulas.core.appContext.version> ... </layeredConfiguration> </configuration> </plugin> In this case, when running Vulas scan in Piper, Piper is referencing the old plugin name vulas-maven-plugin and does not consider the data in the pom.xml file (as it is referenced as plugin-maven ). In order to have Piper use the latest version of Vulas, please update the following Piper property: executeVulasScan script: this, vulasPlugin: 'com.sap.research.security.vulas:plugin-maven'","title":"Why does Piper complain that the URL for service [backend] is not configured?"},{"location":"user/support/faq_sap/#vulas-maven-command-not-working-within-piper","text":"You can run a Vulas scan using a maven command locally on your machine (in your local shell), but the very same command does not work properly when executed in Piper environment via the executeVulasScan command. As an example the following command: mvn --batch-mode --file ./pom.xml -DskipTests -Dvulas com.sap.research.security.vulas:plugin-maven:clean compile com.sap.research.security.vulas:plugin-maven:app install successfully runs locally on your machine but if set into your Piper file, the build fails. The following points should be checked: In Piper, the default template contains a stashFiles( script: this) {} which must be kept in the node where the checkout happens, otherwise all subsequent steps will have a \"somehow\" initialized workspace. Try to avoid version rewriting for your project as described in piper documentation . Setting the vulasVersionRewrite = false, should resolve the executeVulasScan issue.","title":"Vulas-Maven command not working within Piper"},{"location":"user/support/faq_sap/#python","text":"","title":"Python"},{"location":"user/support/faq_sap/#why-does-pip-install-vulas-plugin-setuptools-not-work-as-expected","text":"Make sure that you have configured pip to obtain packages from the SAP repository (Nexus), which you can do by typing the following in the pip.conf file (in Linux, it is in ~/.pip/pip.conf ; create this file/directory if it does not exist): index_url = http://nexus.wdf.sap.corp:8081/nexus/content/groups/build.snapshots.pypi/simple/ trusted-host = nexus.wdf.sap.corp","title":"Why does pip install vulas-plugin-setuptools not work as expected?"},{"location":"user/support/faq_sap/#error-related-to-wsspythonplugin-when-scanning-with-vulas-plugin-setuptools","text":"You are using WhiteSource in your environment and your setup.py has been modified accordingly. Your file looks like the following #!/usr/bin/env python3 # coding=utf-8 __requires__ = [ 'requests == 2.18.3' ] import pkg_resources from setuptools import setup , find_packages from plugin import WssPythonPlugin setup ( name = \"My_Project_Name\" , version = \"1.0.0\" , entry_points = { \"distutils.commands\" : [ \"whitesource_update = plugin.WssPythonPlugin:SetupToolsCommand\" ]}, install_requires = [ 'numpy==1.14.0' , 'scikit-learn==0.18.2' , 'pandas==0.20.2' , 'requests==2.18.3' , 'boto3==1.7.10' , 'rpy2==2.9.1' , 'pika==0.11.0' , 'scipy==1.0.0' ], packages = find_packages (), author = \"My_name\" , author_email = \"xxx.yyy@sap.com\" , description = \"My_Project_Description\" , ) When running the command python setup.py report you receive an error which looks like the following: Traceback (most recent call last): File \"setup.py\", line 8, in <module> from plugin import WssPythonPlugin ImportError: No module named plugin The problem is that your setup.py has been modified in order to use WhiteSource. The lines referencing WssPythonPlugin are problematic when running the Vulas scan. The following command should be used instead: grep -v \"WssPythonPlugin\" setup.py > temp && cp setup.py setup.py.backup && mv temp setup.py && python setup.py app && mv setup.py.backup setup.py This command will basically filter out of the setup.py all the references to WssPythonPlugin and then process to the standard exection. The initial setup.py file will be restored at the end of the process.","title":"Error related to WssPythonPlugin when scanning with vulas-plugin-setuptools"},{"location":"user/support/faq_sap/#security-concept","text":"","title":"Security Concept"},{"location":"user/support/faq_sap/#how-to-secure-the-http-connection-between-the-backend-and-scan-clients","text":"In order to secure connections between the backend and scan clients such as the Maven plugin, you need to add a SAP-specific X.509 certificate to the Java truststore as follows: Open the apps frontend in a browser Open the certification path of the X.509 certificate used to secure the connection to the frontend Export the X.509 certificate of SAPNetCA_G2 as .CER (base-64 encoded) and save it on your disk in folder $JAVA_HOME/jre/lib/security/ Run the following command to import this certificate to the Java truststore: keytool -import -alias SAPNetCA_G2 -file $JAVA_HOME/jre/lib/security/SAPNetCA_G2.cer -keystore $JAVA_HOME/jre/lib/security/cacerts Change the value of configuration setting vulas.shared.backend.serviceUrl to https://vulas.mo.sap.corp/backend In case of problems, use the system property -Djavax.net.debug=all in order to print debug information, or open the Java Secure Socket Extension (JSSE) Reference Guide for more information.","title":"How-to secure the HTTP connection between the backend and scan clients?"},{"location":"user/tutorials/","text":"Getting started \u00b6 Welcome to the Vulas tutorials. Here you can find a set of step-by-step tutorials on how to perform the most common operations with Vulas. If you are new to Vulas this is the right place to start. For detailed, extensive documentation, you may want to refer to the Vulas Manual . Workspace \u00b6 Create a workspace with PPMS information (Beginner) Workspaces for multiple releases/branches (Advanced) Java \u00b6 Scanning Java apps built with Maven (Beginner) Scanning Java apps built with Gradle (Beginner) Scanning Java apps (no/other build system) (Beginner) - please follow this tutorial if your project neither uses Maven nor Gradle. Reachability analysis (Java/Maven) (Advanced) Migrating from Vulas 2 to 3 (Java/Maven) (Beginner) Python \u00b6 Scanning Python apps built with Setuptools (Beginner) Scanning Python apps (no/other build system) (Beginner) Other topics \u00b6 CD/CI automation of Vulas scans with Jenkins Vulas reports demistyfied ( coming soon )","title":"Getting started"},{"location":"user/tutorials/#getting-started","text":"Welcome to the Vulas tutorials. Here you can find a set of step-by-step tutorials on how to perform the most common operations with Vulas. If you are new to Vulas this is the right place to start. For detailed, extensive documentation, you may want to refer to the Vulas Manual .","title":"Getting started"},{"location":"user/tutorials/#workspace","text":"Create a workspace with PPMS information (Beginner) Workspaces for multiple releases/branches (Advanced)","title":"Workspace"},{"location":"user/tutorials/#java","text":"Scanning Java apps built with Maven (Beginner) Scanning Java apps built with Gradle (Beginner) Scanning Java apps (no/other build system) (Beginner) - please follow this tutorial if your project neither uses Maven nor Gradle. Reachability analysis (Java/Maven) (Advanced) Migrating from Vulas 2 to 3 (Java/Maven) (Beginner)","title":"Java"},{"location":"user/tutorials/#python","text":"Scanning Python apps built with Setuptools (Beginner) Scanning Python apps (no/other build system) (Beginner)","title":"Python"},{"location":"user/tutorials/#other-topics","text":"CD/CI automation of Vulas scans with Jenkins Vulas reports demistyfied ( coming soon )","title":"Other topics"},{"location":"user/tutorials/java_cli/","text":"Scanning Java apps with the CLI \u00b6 This tutorial will walk you through the steps needed to setup and use Vulas to scan a Java application that is not built with tools such as Maven or Gradle . Terminology: 'Goals' For consistency with the terminology used in Maven, the different \"commands\" available in Vulas are referred to as \" goals \". Prerequisites \u00b6 JDK 7 or later URLs of the backend service and apps Web frontend Apps Web frontend: http://vulas.mo.sap.corp:8080/apps Backend service: http://vulas.mo.sap.corp:8080/backend The token of a Vulas workspace Workspace creation If you do not have a workspace yet, you can easily create one by going on the application frontend and clicking on the third button in the lower left corner: For a detailed description of workspaces and of the inputs you have to provide in the form that is displayed when you click that button, please see this section of the manual . Download \u00b6 Please download the latest ZIP archive vulas-cli-3.0.12.zip from GitHub Enterprise and extract it into a newly created folder. This folder will contain the following items: ./app/ Put the application code (java, class or JAR files) and all application dependencies (JAR files) into this folder. It will be searched recursively, thus, it is possible to just copy the entire installation directory of an application into the folder. ./vulas-cli-3.0.12-jar-with-dependencies.jar An executable JAR, which is the actual command-line version of the Vulas client. This is what you will use later to execute Vulas scans. ./instr/lang-java-3.0.12-jar-with-dependencies.jar This is used to instrument the Java runtime when performing dynamic analysis. ./vulas-custom.properties.sample This is a template for the configuration file required by Vulas. You will change it in order to specify an identifier for your application (see below). Setup \u00b6 Rename the file vulas-custom.properties.sample to vulas-custom.properties and edit it to specify <GROUP> , <ARTIFACT> and <VERSION> of the application to be analyzed. Those settings will be used to uniquely identify the application in the backend. Set the option vulas.core.space.token so that it is assigned your own workspace token. Put the application code (java, class or JAR files) and all application dependencies (JAR files) into this folder. Specify how Vulas can distinguish the code of your application from its dependencies, which is necessary for the call graph construction during the reachability analyses (goals a2c and t2c ). You can do so in two different ways: you can use either vulas.core.app.appPrefixes or vulas.core.app.appJarNames . # Package prefix(es) of application code (multiple values to be separated by comma), only relevant for CLI vulas.core.app.appPrefixes = # Regex that identifies JARs with application code (multiple values to be separated by comma), only relevant for CLI vulas.core.app.appJarNames = Warning In order for the static reachability analysis to be performed correctly, all application methods must be used as entry points for the call graph construction. Therefore, if the criterion to distinguish application code and dependencies is not specified correctly, the potential execution of vulnerable open-source methods may be missed. To check whether the specification is correct, you may want to inspect the application frontend and see whether there are any items in the Dependencies tab that are created by you or your organization (there should be none, only 3 rd party libraries should be there), and whether there are open-source packages at all in the table on the Dependencies tab (there should be none, only packages from your own project). IMPORTANT REMARKS You should also keep the following into account: Single java and class files are always considered as application code ( regardless of the package prefix configured with vulas.core.app.appPrefixes ). JARs are always considered application dependencies unless they only contain methods starting with the configured package prefix. Nested JARs must be manually extracted (but no need to do so for WARs). Goal execution \u00b6 See here for a description of all analysis goals. app \u00b6 java -jar vulas-cli-3.0.12-jar-with-dependencies.jar -goal app Connect to the apps Web frontend, then select your workspace and application. The table in tab Dependencies is populated. Dependencies with known vulnerabilities are shown in tab Vulnerabilities . Assess and mitigate Once app has been run, the assessment of findings can already start: Each finding shown on the Vulnerabilities tab corresponds to a dependency of an application on a component with a known security vulnerability. See here for more information on how to assess and mitigate findings. Other analysis goals can be used to collect further evidence concerning the reachability of vulnerable code. report \u00b6 java -jar vulas-cli-3.0.12-jar-with-dependencies.jar -goal report Check the console to see where the HTML, JSON and XML reports have been written to. clean \u00b6 java -jar vulas-cli-3.0.12-jar-with-dependencies.jar -goal clean All application-specific data in the Vulas backend are deleted. Run clean whenever the application changes If you already scanned your project in the past, you should run the clean goal prior to new analyses in order to delete the old analysis results in the backend. Otherwise, old analysis results will be shown together with new results. For example, if you updated a dependency from a vulnerable to a non-vulnerable version, both versions will be shown in the apps Web frontend. Useful links \u00b6 Automate with Jenkins Configure the client-side analysis Get help if you run into troubles Assess and mitigate reported vulnerabilities","title":"Scanning Java (CLI)"},{"location":"user/tutorials/java_cli/#scanning-java-apps-with-the-cli","text":"This tutorial will walk you through the steps needed to setup and use Vulas to scan a Java application that is not built with tools such as Maven or Gradle . Terminology: 'Goals' For consistency with the terminology used in Maven, the different \"commands\" available in Vulas are referred to as \" goals \".","title":"Scanning Java apps with the CLI"},{"location":"user/tutorials/java_cli/#prerequisites","text":"JDK 7 or later URLs of the backend service and apps Web frontend Apps Web frontend: http://vulas.mo.sap.corp:8080/apps Backend service: http://vulas.mo.sap.corp:8080/backend The token of a Vulas workspace Workspace creation If you do not have a workspace yet, you can easily create one by going on the application frontend and clicking on the third button in the lower left corner: For a detailed description of workspaces and of the inputs you have to provide in the form that is displayed when you click that button, please see this section of the manual .","title":"Prerequisites"},{"location":"user/tutorials/java_cli/#download","text":"Please download the latest ZIP archive vulas-cli-3.0.12.zip from GitHub Enterprise and extract it into a newly created folder. This folder will contain the following items: ./app/ Put the application code (java, class or JAR files) and all application dependencies (JAR files) into this folder. It will be searched recursively, thus, it is possible to just copy the entire installation directory of an application into the folder. ./vulas-cli-3.0.12-jar-with-dependencies.jar An executable JAR, which is the actual command-line version of the Vulas client. This is what you will use later to execute Vulas scans. ./instr/lang-java-3.0.12-jar-with-dependencies.jar This is used to instrument the Java runtime when performing dynamic analysis. ./vulas-custom.properties.sample This is a template for the configuration file required by Vulas. You will change it in order to specify an identifier for your application (see below).","title":"Download"},{"location":"user/tutorials/java_cli/#setup","text":"Rename the file vulas-custom.properties.sample to vulas-custom.properties and edit it to specify <GROUP> , <ARTIFACT> and <VERSION> of the application to be analyzed. Those settings will be used to uniquely identify the application in the backend. Set the option vulas.core.space.token so that it is assigned your own workspace token. Put the application code (java, class or JAR files) and all application dependencies (JAR files) into this folder. Specify how Vulas can distinguish the code of your application from its dependencies, which is necessary for the call graph construction during the reachability analyses (goals a2c and t2c ). You can do so in two different ways: you can use either vulas.core.app.appPrefixes or vulas.core.app.appJarNames . # Package prefix(es) of application code (multiple values to be separated by comma), only relevant for CLI vulas.core.app.appPrefixes = # Regex that identifies JARs with application code (multiple values to be separated by comma), only relevant for CLI vulas.core.app.appJarNames = Warning In order for the static reachability analysis to be performed correctly, all application methods must be used as entry points for the call graph construction. Therefore, if the criterion to distinguish application code and dependencies is not specified correctly, the potential execution of vulnerable open-source methods may be missed. To check whether the specification is correct, you may want to inspect the application frontend and see whether there are any items in the Dependencies tab that are created by you or your organization (there should be none, only 3 rd party libraries should be there), and whether there are open-source packages at all in the table on the Dependencies tab (there should be none, only packages from your own project). IMPORTANT REMARKS You should also keep the following into account: Single java and class files are always considered as application code ( regardless of the package prefix configured with vulas.core.app.appPrefixes ). JARs are always considered application dependencies unless they only contain methods starting with the configured package prefix. Nested JARs must be manually extracted (but no need to do so for WARs).","title":"Setup"},{"location":"user/tutorials/java_cli/#goal-execution","text":"See here for a description of all analysis goals.","title":"Goal execution"},{"location":"user/tutorials/java_cli/#app","text":"java -jar vulas-cli-3.0.12-jar-with-dependencies.jar -goal app Connect to the apps Web frontend, then select your workspace and application. The table in tab Dependencies is populated. Dependencies with known vulnerabilities are shown in tab Vulnerabilities . Assess and mitigate Once app has been run, the assessment of findings can already start: Each finding shown on the Vulnerabilities tab corresponds to a dependency of an application on a component with a known security vulnerability. See here for more information on how to assess and mitigate findings. Other analysis goals can be used to collect further evidence concerning the reachability of vulnerable code.","title":"app"},{"location":"user/tutorials/java_cli/#report","text":"java -jar vulas-cli-3.0.12-jar-with-dependencies.jar -goal report Check the console to see where the HTML, JSON and XML reports have been written to.","title":"report"},{"location":"user/tutorials/java_cli/#clean","text":"java -jar vulas-cli-3.0.12-jar-with-dependencies.jar -goal clean All application-specific data in the Vulas backend are deleted. Run clean whenever the application changes If you already scanned your project in the past, you should run the clean goal prior to new analyses in order to delete the old analysis results in the backend. Otherwise, old analysis results will be shown together with new results. For example, if you updated a dependency from a vulnerable to a non-vulnerable version, both versions will be shown in the apps Web frontend.","title":"clean"},{"location":"user/tutorials/java_cli/#useful-links","text":"Automate with Jenkins Configure the client-side analysis Get help if you run into troubles Assess and mitigate reported vulnerabilities","title":"Useful links"},{"location":"user/tutorials/java_gradle/","text":"Scanning Java apps built with Gradle \u00b6 Prerequisites \u00b6 JDK 7 or later URL of the package repository to download the plugin JAR ( http://nexus.wdf.sap.corp:8081/nexus/content/repositories/build.snapshots ) URLs of the backend service and apps Web frontend Apps Web frontend: http://vulas.mo.sap.corp:8080/apps Backend service: http://vulas.mo.sap.corp:8080/backend The token of a Vulas workspace Workspace creation If you do not have a workspace yet, you can easily create one by going on the application frontend and clicking on the third button in the lower left corner: For a detailed description of workspaces and of the inputs you have to provide in the form that is displayed when you click that button, please see this section of the manual . Setup \u00b6 The plugin for Gradle requires changes of the following two files: build.gradle buildscript { repositories { maven { url 'http://nexus.wdf.sap.corp:8081/nexus/content/repositories/build.snapshots' } mavenCentral() } dependencies { classpath('com.sap.research.security.vulas:plugin-gradle:3.0.12') { changing = true } } } allprojects { apply plugin: \"vulas\" } gradle.properties // Used to identify the scan in the apps Web frontend group = <GROUP> version = <VERSION> // Replace token of test space vulas.core.space.token = <WORKSPACE-TOKEN> vulas.shared.backend.serviceUrl = http://vulas.mo.sap.corp:8080/backend Note: Rather than adding configuration settings to gradle.properties , they can also be passed as project properties in the command line, e.g., -Pvulas.report.exceptionThreshold=noException . The use of -D system properties for changing configuration settings is discouraged (because of the cache of the Gradle daemon). The configuration is correct if the Vulas analysis goals app , a2c etc. are listed among Other tasks when running the following command: ./gradlew tasks -all The Gradle plugin only works with later releases of Gradle. How to upgrade is described here . Goal execution \u00b6 See here for a description of all analysis goals. app \u00b6 ./gradlew assemble vulasApp Connect to the apps Web frontend, then select your workspace and application. The table in tab Dependencies is populated. Dependencies with known vulnerabilities are shown in tab Vulnerabilities . Assess and mitigate Once app has been run, the assessment of findings can already start: Each finding shown on the Vulnerabilities tab corresponds to a dependency of an application on a component with a known security vulnerability. See here for more information on how to assess and mitigate findings. Other analysis goals can be used to collect further evidence concerning the reachability of vulnerable code. report \u00b6 ./gradlew vulasReport A summary report is written to disk (in HTML, XML and JSON format), by default into folder target/vulas/report . By default a build exception is thrown if the application includes a library subject to known vulnerabilities. clean \u00b6 ./gradlew vulasClean All application-specific data in the Vulas backend are deleted. Run clean whenever the application changes If you already scanned your project in the past, you should run the clean goal prior to new analyses in order to delete the old analysis results in the backend. Otherwise, old analysis results will be shown together with new results. For example, if you updated a dependency from a vulnerable to a non-vulnerable version, both versions will be shown in the apps Web frontend. Useful links \u00b6 Automate with Jenkins Configure the client-side analysis Get help if you run into troubles Assess and mitigate reported vulnerabilities","title":"Scanning Java (Gradle)"},{"location":"user/tutorials/java_gradle/#scanning-java-apps-built-with-gradle","text":"","title":"Scanning Java apps built with Gradle"},{"location":"user/tutorials/java_gradle/#prerequisites","text":"JDK 7 or later URL of the package repository to download the plugin JAR ( http://nexus.wdf.sap.corp:8081/nexus/content/repositories/build.snapshots ) URLs of the backend service and apps Web frontend Apps Web frontend: http://vulas.mo.sap.corp:8080/apps Backend service: http://vulas.mo.sap.corp:8080/backend The token of a Vulas workspace Workspace creation If you do not have a workspace yet, you can easily create one by going on the application frontend and clicking on the third button in the lower left corner: For a detailed description of workspaces and of the inputs you have to provide in the form that is displayed when you click that button, please see this section of the manual .","title":"Prerequisites"},{"location":"user/tutorials/java_gradle/#setup","text":"The plugin for Gradle requires changes of the following two files: build.gradle buildscript { repositories { maven { url 'http://nexus.wdf.sap.corp:8081/nexus/content/repositories/build.snapshots' } mavenCentral() } dependencies { classpath('com.sap.research.security.vulas:plugin-gradle:3.0.12') { changing = true } } } allprojects { apply plugin: \"vulas\" } gradle.properties // Used to identify the scan in the apps Web frontend group = <GROUP> version = <VERSION> // Replace token of test space vulas.core.space.token = <WORKSPACE-TOKEN> vulas.shared.backend.serviceUrl = http://vulas.mo.sap.corp:8080/backend Note: Rather than adding configuration settings to gradle.properties , they can also be passed as project properties in the command line, e.g., -Pvulas.report.exceptionThreshold=noException . The use of -D system properties for changing configuration settings is discouraged (because of the cache of the Gradle daemon). The configuration is correct if the Vulas analysis goals app , a2c etc. are listed among Other tasks when running the following command: ./gradlew tasks -all The Gradle plugin only works with later releases of Gradle. How to upgrade is described here .","title":"Setup"},{"location":"user/tutorials/java_gradle/#goal-execution","text":"See here for a description of all analysis goals.","title":"Goal execution"},{"location":"user/tutorials/java_gradle/#app","text":"./gradlew assemble vulasApp Connect to the apps Web frontend, then select your workspace and application. The table in tab Dependencies is populated. Dependencies with known vulnerabilities are shown in tab Vulnerabilities . Assess and mitigate Once app has been run, the assessment of findings can already start: Each finding shown on the Vulnerabilities tab corresponds to a dependency of an application on a component with a known security vulnerability. See here for more information on how to assess and mitigate findings. Other analysis goals can be used to collect further evidence concerning the reachability of vulnerable code.","title":"app"},{"location":"user/tutorials/java_gradle/#report","text":"./gradlew vulasReport A summary report is written to disk (in HTML, XML and JSON format), by default into folder target/vulas/report . By default a build exception is thrown if the application includes a library subject to known vulnerabilities.","title":"report"},{"location":"user/tutorials/java_gradle/#clean","text":"./gradlew vulasClean All application-specific data in the Vulas backend are deleted. Run clean whenever the application changes If you already scanned your project in the past, you should run the clean goal prior to new analyses in order to delete the old analysis results in the backend. Otherwise, old analysis results will be shown together with new results. For example, if you updated a dependency from a vulnerable to a non-vulnerable version, both versions will be shown in the apps Web frontend.","title":"clean"},{"location":"user/tutorials/java_gradle/#useful-links","text":"Automate with Jenkins Configure the client-side analysis Get help if you run into troubles Assess and mitigate reported vulnerabilities","title":"Useful links"},{"location":"user/tutorials/java_maven/","text":"Scanning Java apps built with Maven \u00b6 Prerequisites \u00b6 JDK 7 or later Apache Maven 3.x with settings.xml configured to download from the Maven repository hosting the Vulas plugin for Maven URLs of the backend service and apps Web frontend Apps Web frontend: http://vulas.mo.sap.corp:8080/apps Backend service: http://vulas.mo.sap.corp:8080/backend The token of a Vulas workspace Workspace creation If you do not have a workspace yet, you can easily create one by going on the application frontend and clicking on the third button in the lower left corner: For a detailed description of workspaces and of the inputs you have to provide in the form that is displayed when you click that button, please see this section of the manual . Setup \u00b6 The plugin for Maven can be used with or without adding a Vulas profile to the pom.xml of your application. This tutorial guides you through the setup with Vulas profile . Cannot add the Vulas profile? If possible we recommend to use the Vulas profile as the execution of goals using the command-line is more concise (readable). If you cannot paste the Vulas profile in the pom.xml of your application you can still use the Vulas plugin for Maven. Check out the Manual Java (Maven) Add the following to the <profiles> section of the pom.xml of your application project and make sure that <vulas.shared.backend.serviceUrl> points to the URL of the backend service and that <vulas.core.space.token> specifies the token of your individual workspace (see highlighted lines). <profile> <id> vulas </id> <activation> <property> <name> vulas </name> </property> </activation> <properties> <vulas.version> 3.0.12 </vulas.version> <vulas.shared.backend.serviceUrl> http://vulas.mo.sap.corp:8080/backend </vulas.shared.backend.serviceUrl> <vulas.core.space.token> WORKSPACE_TOKEN </vulas.core.space.token> <vulas.core.appContext.group> ${project.groupId} </vulas.core.appContext.group> <vulas.core.appContext.artifact> ${project.artifactId} </vulas.core.appContext.artifact> <vulas.core.appContext.version> ${project.version} </vulas.core.appContext.version> </properties> <build> <plugins> <!-- Copies Vulas JARs to ${project.build.directory}/vulas/lib and incl, which is needed for the instrumentation of JUnit tests. --> <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-dependency-plugin </artifactId> <version> 2.10 </version> <executions> <execution> <id> copy-vulas </id> <phase> generate-test-resources </phase> <goals> <goal> copy </goal> </goals> <configuration> <artifactItems> <artifactItem> <groupId> com.sap.research.security.vulas </groupId> <artifactId> lang-java </artifactId> <version> ${vulas.version} </version> <type> jar </type> <classifier> jar-with-dependencies </classifier> <outputDirectory> ${project.build.directory}/vulas/lib </outputDirectory> <destFileName> vulas-core-latest-jar-with-dependencies.jar </destFileName> </artifactItem> <artifactItem> <groupId> com.sap.research.security.vulas </groupId> <artifactId> lang-java </artifactId> <version> ${vulas.version} </version> <type> jar </type> <classifier> jar-with-dependencies </classifier> <outputDirectory> ${project.build.directory}/vulas/include </outputDirectory> <destFileName> vulas-core-latest-jar-with-dependencies.jar </destFileName> </artifactItem> </artifactItems> </configuration> </execution> </executions> </plugin> <!-- Registers the Vulas agent at JVM startup (and specifies a couple of configuration settings) --> <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-surefire-plugin </artifactId> <version> 2.21.0 </version> <configuration> <!-- If set to 0, no separate JVM process will be spawned, i.e., one can use mvnDebug and JVM params can be added to the Maven (rather than putting them in the Surefire plugin configuration) (default: 1) --> <forkCount> 1 </forkCount> <!-- Kill the forked test process after a certain number of seconds. If set to 0, wait forever for the process, never timing out. This allows Vulas to (hopefully) upload all info in its shutdown hook. More info: https://maven.apache.org/surefire/maven-surefire-plugin/test-mojo.html, https://maven.apache.org/surefire/maven-surefire-plugin/examples/shutdown.html --> <forkedProcessTimeoutInSeconds> 0 </forkedProcessTimeoutInSeconds> <!-- Available as of 2.20 (or so), default is 30 --> <forkedProcessExitTimeoutInSeconds> 300 </forkedProcessExitTimeoutInSeconds> <!-- Note: System properties cannot be set at the Maven command line, they are not passed on to the JVM spawned by Surefire (if any, see parameter forkCount) --> <argLine> -javaagent:\"${project.build.directory}/vulas/lib/vulas-core-latest-jar-with-dependencies.jar\" -Dvulas.shared.backend.serviceUrl=${vulas.shared.backend.serviceUrl} -Dvulas.shared.tmpDir=${project.build.directory}/vulas/tmp -Dvulas.core.backendConnection=READ_ONLY -Dvulas.core.uploadDir=${project.build.directory}/vulas/upload -Dvulas.core.monitor.periodicUpload.enabled=false -Dvulas.core.appContext.group=${vulas.core.appContext.group} -Dvulas.core.appContext.artifact=${vulas.core.appContext.artifact} -Dvulas.core.appContext.version=${vulas.core.appContext.version} -Dvulas.core.instr.writeCode=false -Dvulas.core.instr.maxStacktraces=10 -Dvulas.core.space.token=${vulas.core.space.token} -Dvulas.core.instr.instrumentorsChoosen=com.sap.psr.vulas.monitor.trace.SingleTraceInstrumentor -noverify <!-- Uncomment to write the heap to disk in case of memory issues --> <!-- -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=${project.build.directory}/vulas/tmp --> <!-- Uncomment to debug the test execution or the Vulas plugin --> <!-- -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000 --> </argLine> <!-- Exclude problematic tests --> <excludes> <exclude> **/doesnotexist.java </exclude> </excludes> </configuration> </plugin> <plugin> <groupId> com.sap.research.security.vulas </groupId> <artifactId> plugin-maven </artifactId> <version> ${vulas.version} </version> <configuration> <layeredConfiguration> <vulas.shared.backend.serviceUrl> ${vulas.shared.backend.serviceUrl} </vulas.shared.backend.serviceUrl> <vulas.core.space.token> ${vulas.core.space.token} </vulas.core.space.token> <vulas.core.appContext.group> ${vulas.core.appContext.group} </vulas.core.appContext.group> <vulas.core.appContext.artifact> ${vulas.core.appContext.artifact} </vulas.core.appContext.artifact> <vulas.core.appContext.version> ${vulas.core.appContext.version} </vulas.core.appContext.version> <vulas.shared.tmpDir> ${project.build.directory}/vulas/tmp </vulas.shared.tmpDir> <vulas.core.uploadDir> ${project.build.directory}/vulas/upload </vulas.core.uploadDir> <vulas.core.app.sourceDir> ${project.build.directory}/classes,${project.basedir}/src/main/java,${project.basedir}/src/main/python </vulas.core.app.sourceDir> <!-- vulas:instr : Instruments JAR/WAR files found in source dir, and writes to target dir. Files in include dir are put into /WEB-INF/lib of output WARs. Files in lib dir are part of the class path when instrumenting. --> <vulas.core.instr.sourceDir> ${project.build.directory} </vulas.core.instr.sourceDir> <vulas.core.instr.targetDir> ${project.build.directory}/vulas/target </vulas.core.instr.targetDir> <vulas.core.instr.includeDir> ${project.build.directory}/vulas/include </vulas.core.instr.includeDir> <vulas.core.instr.libDir> ${project.build.directory}/vulas/lib </vulas.core.instr.libDir> <vulas.core.instr.writeCode> false </vulas.core.instr.writeCode> <vulas.core.instr.searchRecursive> false </vulas.core.instr.searchRecursive> <!-- vulas:a2c/t2c : Performs static call graph analysis --> <vulas.reach.wala.callgraph.reflection> NO_FLOW_TO_CASTS_NO_METHOD_INVOKE </vulas.reach.wala.callgraph.reflection> <vulas.reach.timeout> 60 </vulas.reach.timeout> <!-- vulas:report --> <vulas.report.exceptionExcludeBugs></vulas.report.exceptionExcludeBugs> <vulas.report.reportDir> ${project.build.directory}/vulas/report </vulas.report.reportDir> <vulas.report.sap.scv> replace-with-PPMS-object-number </vulas.report.sap.scv> </layeredConfiguration> </configuration> </plugin> </plugins> </build> </profile> In case of aggregated, multi-module Maven projects with modules inheriting from their parent, it is sufficient to include the profile in the top-level (parent) pom.xml . If a module does not inherit from the parent, the profile has to be added to its POM file. Goal execution \u00b6 See here for a description of all analysis goals. app \u00b6 mvn -Dvulas compile vulas:app Connect to the apps Web frontend, then select your workspace and application. The table in tab Dependencies is populated. Dependencies with known vulnerabilities are shown in tab Vulnerabilities . In case your application does not follow the standard structure of Maven applications, please refer to the Manual Java (Maven) to learn how to configure the Vulas plugin accordingly. Assess and mitigate Once app has been run, the assessment of findings can already start: Each finding shown on the Vulnerabilities tab corresponds to a dependency of an application on a component with a known security vulnerability. See here for more information on how to assess and mitigate findings. Other analysis goals can be used to collect further evidence concerning the reachability of vulnerable code. report \u00b6 mvn -Dvulas vulas:report A summary report is written to disk (in HTML, XML and JSON format), by default into folder target/vulas/report . By default a build exception is thrown if the application includes a library subject to known vulnerabilities. Warning The goal report must be executed separately from the other analysis goal. Otherwise, in case of multi-module Maven projects, it may throw a build exception before all modules have been analyzed. clean \u00b6 mvn -Dvulas vulas:clean All application-specific data in the Vulas backend are deleted. Run clean whenever the application changes If you already scanned your project in the past, you should run the clean goal prior to new analyses in order to delete the old analysis results in the backend. Otherwise, old analysis results will be shown together with new results. For example, if you updated a dependency from a vulnerable to a non-vulnerable version, both versions will be shown in the apps Web frontend. Useful links \u00b6 Automate with Jenkins Configure the client-side analysis Get help if you run into troubles Assess and mitigate reported vulnerabilities","title":"Scanning Java (Maven)"},{"location":"user/tutorials/java_maven/#scanning-java-apps-built-with-maven","text":"","title":"Scanning Java apps built with Maven"},{"location":"user/tutorials/java_maven/#prerequisites","text":"JDK 7 or later Apache Maven 3.x with settings.xml configured to download from the Maven repository hosting the Vulas plugin for Maven URLs of the backend service and apps Web frontend Apps Web frontend: http://vulas.mo.sap.corp:8080/apps Backend service: http://vulas.mo.sap.corp:8080/backend The token of a Vulas workspace Workspace creation If you do not have a workspace yet, you can easily create one by going on the application frontend and clicking on the third button in the lower left corner: For a detailed description of workspaces and of the inputs you have to provide in the form that is displayed when you click that button, please see this section of the manual .","title":"Prerequisites"},{"location":"user/tutorials/java_maven/#setup","text":"The plugin for Maven can be used with or without adding a Vulas profile to the pom.xml of your application. This tutorial guides you through the setup with Vulas profile . Cannot add the Vulas profile? If possible we recommend to use the Vulas profile as the execution of goals using the command-line is more concise (readable). If you cannot paste the Vulas profile in the pom.xml of your application you can still use the Vulas plugin for Maven. Check out the Manual Java (Maven) Add the following to the <profiles> section of the pom.xml of your application project and make sure that <vulas.shared.backend.serviceUrl> points to the URL of the backend service and that <vulas.core.space.token> specifies the token of your individual workspace (see highlighted lines). <profile> <id> vulas </id> <activation> <property> <name> vulas </name> </property> </activation> <properties> <vulas.version> 3.0.12 </vulas.version> <vulas.shared.backend.serviceUrl> http://vulas.mo.sap.corp:8080/backend </vulas.shared.backend.serviceUrl> <vulas.core.space.token> WORKSPACE_TOKEN </vulas.core.space.token> <vulas.core.appContext.group> ${project.groupId} </vulas.core.appContext.group> <vulas.core.appContext.artifact> ${project.artifactId} </vulas.core.appContext.artifact> <vulas.core.appContext.version> ${project.version} </vulas.core.appContext.version> </properties> <build> <plugins> <!-- Copies Vulas JARs to ${project.build.directory}/vulas/lib and incl, which is needed for the instrumentation of JUnit tests. --> <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-dependency-plugin </artifactId> <version> 2.10 </version> <executions> <execution> <id> copy-vulas </id> <phase> generate-test-resources </phase> <goals> <goal> copy </goal> </goals> <configuration> <artifactItems> <artifactItem> <groupId> com.sap.research.security.vulas </groupId> <artifactId> lang-java </artifactId> <version> ${vulas.version} </version> <type> jar </type> <classifier> jar-with-dependencies </classifier> <outputDirectory> ${project.build.directory}/vulas/lib </outputDirectory> <destFileName> vulas-core-latest-jar-with-dependencies.jar </destFileName> </artifactItem> <artifactItem> <groupId> com.sap.research.security.vulas </groupId> <artifactId> lang-java </artifactId> <version> ${vulas.version} </version> <type> jar </type> <classifier> jar-with-dependencies </classifier> <outputDirectory> ${project.build.directory}/vulas/include </outputDirectory> <destFileName> vulas-core-latest-jar-with-dependencies.jar </destFileName> </artifactItem> </artifactItems> </configuration> </execution> </executions> </plugin> <!-- Registers the Vulas agent at JVM startup (and specifies a couple of configuration settings) --> <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-surefire-plugin </artifactId> <version> 2.21.0 </version> <configuration> <!-- If set to 0, no separate JVM process will be spawned, i.e., one can use mvnDebug and JVM params can be added to the Maven (rather than putting them in the Surefire plugin configuration) (default: 1) --> <forkCount> 1 </forkCount> <!-- Kill the forked test process after a certain number of seconds. If set to 0, wait forever for the process, never timing out. This allows Vulas to (hopefully) upload all info in its shutdown hook. More info: https://maven.apache.org/surefire/maven-surefire-plugin/test-mojo.html, https://maven.apache.org/surefire/maven-surefire-plugin/examples/shutdown.html --> <forkedProcessTimeoutInSeconds> 0 </forkedProcessTimeoutInSeconds> <!-- Available as of 2.20 (or so), default is 30 --> <forkedProcessExitTimeoutInSeconds> 300 </forkedProcessExitTimeoutInSeconds> <!-- Note: System properties cannot be set at the Maven command line, they are not passed on to the JVM spawned by Surefire (if any, see parameter forkCount) --> <argLine> -javaagent:\"${project.build.directory}/vulas/lib/vulas-core-latest-jar-with-dependencies.jar\" -Dvulas.shared.backend.serviceUrl=${vulas.shared.backend.serviceUrl} -Dvulas.shared.tmpDir=${project.build.directory}/vulas/tmp -Dvulas.core.backendConnection=READ_ONLY -Dvulas.core.uploadDir=${project.build.directory}/vulas/upload -Dvulas.core.monitor.periodicUpload.enabled=false -Dvulas.core.appContext.group=${vulas.core.appContext.group} -Dvulas.core.appContext.artifact=${vulas.core.appContext.artifact} -Dvulas.core.appContext.version=${vulas.core.appContext.version} -Dvulas.core.instr.writeCode=false -Dvulas.core.instr.maxStacktraces=10 -Dvulas.core.space.token=${vulas.core.space.token} -Dvulas.core.instr.instrumentorsChoosen=com.sap.psr.vulas.monitor.trace.SingleTraceInstrumentor -noverify <!-- Uncomment to write the heap to disk in case of memory issues --> <!-- -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=${project.build.directory}/vulas/tmp --> <!-- Uncomment to debug the test execution or the Vulas plugin --> <!-- -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000 --> </argLine> <!-- Exclude problematic tests --> <excludes> <exclude> **/doesnotexist.java </exclude> </excludes> </configuration> </plugin> <plugin> <groupId> com.sap.research.security.vulas </groupId> <artifactId> plugin-maven </artifactId> <version> ${vulas.version} </version> <configuration> <layeredConfiguration> <vulas.shared.backend.serviceUrl> ${vulas.shared.backend.serviceUrl} </vulas.shared.backend.serviceUrl> <vulas.core.space.token> ${vulas.core.space.token} </vulas.core.space.token> <vulas.core.appContext.group> ${vulas.core.appContext.group} </vulas.core.appContext.group> <vulas.core.appContext.artifact> ${vulas.core.appContext.artifact} </vulas.core.appContext.artifact> <vulas.core.appContext.version> ${vulas.core.appContext.version} </vulas.core.appContext.version> <vulas.shared.tmpDir> ${project.build.directory}/vulas/tmp </vulas.shared.tmpDir> <vulas.core.uploadDir> ${project.build.directory}/vulas/upload </vulas.core.uploadDir> <vulas.core.app.sourceDir> ${project.build.directory}/classes,${project.basedir}/src/main/java,${project.basedir}/src/main/python </vulas.core.app.sourceDir> <!-- vulas:instr : Instruments JAR/WAR files found in source dir, and writes to target dir. Files in include dir are put into /WEB-INF/lib of output WARs. Files in lib dir are part of the class path when instrumenting. --> <vulas.core.instr.sourceDir> ${project.build.directory} </vulas.core.instr.sourceDir> <vulas.core.instr.targetDir> ${project.build.directory}/vulas/target </vulas.core.instr.targetDir> <vulas.core.instr.includeDir> ${project.build.directory}/vulas/include </vulas.core.instr.includeDir> <vulas.core.instr.libDir> ${project.build.directory}/vulas/lib </vulas.core.instr.libDir> <vulas.core.instr.writeCode> false </vulas.core.instr.writeCode> <vulas.core.instr.searchRecursive> false </vulas.core.instr.searchRecursive> <!-- vulas:a2c/t2c : Performs static call graph analysis --> <vulas.reach.wala.callgraph.reflection> NO_FLOW_TO_CASTS_NO_METHOD_INVOKE </vulas.reach.wala.callgraph.reflection> <vulas.reach.timeout> 60 </vulas.reach.timeout> <!-- vulas:report --> <vulas.report.exceptionExcludeBugs></vulas.report.exceptionExcludeBugs> <vulas.report.reportDir> ${project.build.directory}/vulas/report </vulas.report.reportDir> <vulas.report.sap.scv> replace-with-PPMS-object-number </vulas.report.sap.scv> </layeredConfiguration> </configuration> </plugin> </plugins> </build> </profile> In case of aggregated, multi-module Maven projects with modules inheriting from their parent, it is sufficient to include the profile in the top-level (parent) pom.xml . If a module does not inherit from the parent, the profile has to be added to its POM file.","title":"Setup"},{"location":"user/tutorials/java_maven/#goal-execution","text":"See here for a description of all analysis goals.","title":"Goal execution"},{"location":"user/tutorials/java_maven/#app","text":"mvn -Dvulas compile vulas:app Connect to the apps Web frontend, then select your workspace and application. The table in tab Dependencies is populated. Dependencies with known vulnerabilities are shown in tab Vulnerabilities . In case your application does not follow the standard structure of Maven applications, please refer to the Manual Java (Maven) to learn how to configure the Vulas plugin accordingly. Assess and mitigate Once app has been run, the assessment of findings can already start: Each finding shown on the Vulnerabilities tab corresponds to a dependency of an application on a component with a known security vulnerability. See here for more information on how to assess and mitigate findings. Other analysis goals can be used to collect further evidence concerning the reachability of vulnerable code.","title":"app"},{"location":"user/tutorials/java_maven/#report","text":"mvn -Dvulas vulas:report A summary report is written to disk (in HTML, XML and JSON format), by default into folder target/vulas/report . By default a build exception is thrown if the application includes a library subject to known vulnerabilities. Warning The goal report must be executed separately from the other analysis goal. Otherwise, in case of multi-module Maven projects, it may throw a build exception before all modules have been analyzed.","title":"report"},{"location":"user/tutorials/java_maven/#clean","text":"mvn -Dvulas vulas:clean All application-specific data in the Vulas backend are deleted. Run clean whenever the application changes If you already scanned your project in the past, you should run the clean goal prior to new analyses in order to delete the old analysis results in the backend. Otherwise, old analysis results will be shown together with new results. For example, if you updated a dependency from a vulnerable to a non-vulnerable version, both versions will be shown in the apps Web frontend.","title":"clean"},{"location":"user/tutorials/java_maven/#useful-links","text":"Automate with Jenkins Configure the client-side analysis Get help if you run into troubles Assess and mitigate reported vulnerabilities","title":"Useful links"},{"location":"user/tutorials/java_maven_advanced/","text":"Scanning Java apps built with Maven \u00b6 Beginner? Read here This tutorial is the second part of the introductory tutorial that you can find here . If you have not done so yet, you are warmly encouraged to follow that one first, and then come back here. This document will assume you already have a working configuration and have successfully executed the steps described in the basic tutorial. Prerequisites \u00b6 The same prerequisites as in the introductory tutorial also apply here. Goal execution \u00b6 The introductory tutorial explained how to use the app analysis goal in order to establish whether an application projects depends on open-source libraries that contain vulnerable code . This tutorial explains how to perform the static and dynamic analyses in order to collect evidence regarding the reachability or execution of vulnerable code in the context of a given application project. The reachability of vulnerable code is an important pre-requisite for the vulnerability to be exploitable. a2c \u00b6 mvn -Dvulas compile vulas:a2c Connect to the apps Web frontend, then select your workspace and application. In the tab Vulnerabilities , the column Static Analysis is populated for all libraries subject to known vulnerabilities reachable from application code. By selecting a single row of this table and the one of the detailed page, one can get more information up until the paths of potential executions (if any). test \u00b6 mvn -Dvulas test vulas:upload Connect to the apps Web frontend, then select your workspace and application. In the tab Vulnerabilities , the column Dynamic Analysis is populated for all libraries subject to known vulnerabilities whose vulnerable code is executed during tests. By selecting single row of this table and the one of the detailed page, one can get more information up until the paths of actual executions (if any). In the tab Statistics , the number of traced vs. the number of total executable constructs (e.g., Java methods) is shown per application package. t2c \u00b6 mvn -Dvulas compile vulas:t2c Connect to the apps Web frontend, then select your workspace and application. In the tab Vulnerabilities , the column Static Analysis is populated for all libraries subject to known vulnerabilities reachable from code executed during tests. By selecting single row of this table and the one of the detailed page, one can get more information up until the paths of potential executions (if any). report \u00b6 mvn -Dvulas vulas:report A summary report is written to disk (in HTML, XML and JSON format), by default into folder target/vulas/report . By default a build exception is thrown if the application includes a library subject to known vulnerabilities. Warning The goal report must be executed separately from the other analysis goal. Otherwise, in case of multi-module Maven projects, it may throw a build exception before all modules have been analyzed. clean \u00b6 mvn -Dvulas vulas:clean All application-specific data in the Vulas backend are deleted. Run clean whenever the application changes If you already scanned your project in the past, you should run the clean goal prior to new analyses in order to delete the old analysis results in the backend. Otherwise, old analysis results will be shown together with new results. For example, if you updated a dependency from a vulnerable to a non-vulnerable version, both versions will be shown in the apps Web frontend. Useful links \u00b6 Automate with Jenkins Configure the client-side analysis Get help if you run into troubles Assess and mitigate reported vulnerabilities","title":"Reachability analysis (Java/Maven)"},{"location":"user/tutorials/java_maven_advanced/#scanning-java-apps-built-with-maven","text":"Beginner? Read here This tutorial is the second part of the introductory tutorial that you can find here . If you have not done so yet, you are warmly encouraged to follow that one first, and then come back here. This document will assume you already have a working configuration and have successfully executed the steps described in the basic tutorial.","title":"Scanning Java apps built with Maven"},{"location":"user/tutorials/java_maven_advanced/#prerequisites","text":"The same prerequisites as in the introductory tutorial also apply here.","title":"Prerequisites"},{"location":"user/tutorials/java_maven_advanced/#goal-execution","text":"The introductory tutorial explained how to use the app analysis goal in order to establish whether an application projects depends on open-source libraries that contain vulnerable code . This tutorial explains how to perform the static and dynamic analyses in order to collect evidence regarding the reachability or execution of vulnerable code in the context of a given application project. The reachability of vulnerable code is an important pre-requisite for the vulnerability to be exploitable.","title":"Goal execution"},{"location":"user/tutorials/java_maven_advanced/#a2c","text":"mvn -Dvulas compile vulas:a2c Connect to the apps Web frontend, then select your workspace and application. In the tab Vulnerabilities , the column Static Analysis is populated for all libraries subject to known vulnerabilities reachable from application code. By selecting a single row of this table and the one of the detailed page, one can get more information up until the paths of potential executions (if any).","title":"a2c"},{"location":"user/tutorials/java_maven_advanced/#test","text":"mvn -Dvulas test vulas:upload Connect to the apps Web frontend, then select your workspace and application. In the tab Vulnerabilities , the column Dynamic Analysis is populated for all libraries subject to known vulnerabilities whose vulnerable code is executed during tests. By selecting single row of this table and the one of the detailed page, one can get more information up until the paths of actual executions (if any). In the tab Statistics , the number of traced vs. the number of total executable constructs (e.g., Java methods) is shown per application package.","title":"test"},{"location":"user/tutorials/java_maven_advanced/#t2c","text":"mvn -Dvulas compile vulas:t2c Connect to the apps Web frontend, then select your workspace and application. In the tab Vulnerabilities , the column Static Analysis is populated for all libraries subject to known vulnerabilities reachable from code executed during tests. By selecting single row of this table and the one of the detailed page, one can get more information up until the paths of potential executions (if any).","title":"t2c"},{"location":"user/tutorials/java_maven_advanced/#report","text":"mvn -Dvulas vulas:report A summary report is written to disk (in HTML, XML and JSON format), by default into folder target/vulas/report . By default a build exception is thrown if the application includes a library subject to known vulnerabilities. Warning The goal report must be executed separately from the other analysis goal. Otherwise, in case of multi-module Maven projects, it may throw a build exception before all modules have been analyzed.","title":"report"},{"location":"user/tutorials/java_maven_advanced/#clean","text":"mvn -Dvulas vulas:clean All application-specific data in the Vulas backend are deleted. Run clean whenever the application changes If you already scanned your project in the past, you should run the clean goal prior to new analyses in order to delete the old analysis results in the backend. Otherwise, old analysis results will be shown together with new results. For example, if you updated a dependency from a vulnerable to a non-vulnerable version, both versions will be shown in the apps Web frontend.","title":"clean"},{"location":"user/tutorials/java_maven_advanced/#useful-links","text":"Automate with Jenkins Configure the client-side analysis Get help if you run into troubles Assess and mitigate reported vulnerabilities","title":"Useful links"},{"location":"user/tutorials/jenkins_howto/","text":"Jenkins automation \u00b6 Vulas was build from the outset with automation in mind, and in particular to integrate well with CI/CD systems. In order to take the most out of it and to ensure that your build process is efficient, it is important to understand which features of Vulas are useful for what type of automated checks. Quick vs. deep scans \u00b6 CI/CD jobs configured with Jenkins or Travis can be triggered in many different ways, e.g., on-commit or periodically, which decides about the frequency of scan jobs. Quick scans (without reachability analysis): If scan jobs are expected to run very frequently, e.g., after every commit in the application's source code repository, it is preferable to only execute the app analysis goal, which typically does not take more than a couple of minutes (at most). Such a quick scan detects the very same number of vulnerabilities than a deep scan, but does not collect any information about the reachability of vulnerable code. Maven mvn -Dvulas clean compile vulas:clean vulas:app Deep scans (with reachability analysis): Scan jobs that run once a day or less can include analysis goals such as a2c , test and t2c . The static analysis goals a2c and t2c , in particular, can take a considerable amount of time until completion (up to several hours), depending on the complexity of the application project under analysis (number of modules, number of application constructs, etc.): Maven mvn -Dvulas clean compile vulas:clean vulas:app vulas:a2c package vulas:upload vulas:t2c See here for more information on Vulas goals. SAP build pipelines \u00b6 SAP application projects can easily enable Vulas scans using the following SAP build pipelines. They do not require to setup an individual Jenkins job, as they support Vulas out-of-the-box. Piper \u00b6 Piper documentation Pipeline step executeVulasScan Important: Please note that parameters specified for the Piper pipeline step override Vulas settings specified in the pom.xml . For instance, the Piper parameter vulasSpaceToken determines the Vulas workspace into which the scan results will be uploaded, no matter what has been specified in the pom.xml of the application under analysis. See here for a list of all Piper parameter for the executeVulasScan pipelines step. Please read through the detailed instructions provided in the documentation of the Piper pipelines step to clarify configuration-related questions. Codepipes \u00b6 Codepipes documentation Task type Vulas Jenkins \u00b6 A typical Jenkins job configuration using the Vulas plugin for Maven comprises the following two build steps and one post-build action (see screenshot below): Build step for a quick scan or deep scan , depending on the expected run frequency. Build step -Dvulas vulas:report to create result reports (per default in folder target/vulas/result ). Post-build action with HTML Publisher Plugin to copy the Html report created by report into the Jenkins dashboard. As such, Vulas results can be consumed w/o the need to scroll through the verbose console output. Additional notes : The above assumes that the Vulas Maven profile is present in the project's pom.xml . The report goal should always be run in a separate Maven invocation. Otherwise, in case of multi-module Maven projects, report may throw a build exception before all of the modules have been analyzed.","title":"Jenkins automation"},{"location":"user/tutorials/jenkins_howto/#jenkins-automation","text":"Vulas was build from the outset with automation in mind, and in particular to integrate well with CI/CD systems. In order to take the most out of it and to ensure that your build process is efficient, it is important to understand which features of Vulas are useful for what type of automated checks.","title":"Jenkins automation"},{"location":"user/tutorials/jenkins_howto/#quick-vs-deep-scans","text":"CI/CD jobs configured with Jenkins or Travis can be triggered in many different ways, e.g., on-commit or periodically, which decides about the frequency of scan jobs. Quick scans (without reachability analysis): If scan jobs are expected to run very frequently, e.g., after every commit in the application's source code repository, it is preferable to only execute the app analysis goal, which typically does not take more than a couple of minutes (at most). Such a quick scan detects the very same number of vulnerabilities than a deep scan, but does not collect any information about the reachability of vulnerable code. Maven mvn -Dvulas clean compile vulas:clean vulas:app Deep scans (with reachability analysis): Scan jobs that run once a day or less can include analysis goals such as a2c , test and t2c . The static analysis goals a2c and t2c , in particular, can take a considerable amount of time until completion (up to several hours), depending on the complexity of the application project under analysis (number of modules, number of application constructs, etc.): Maven mvn -Dvulas clean compile vulas:clean vulas:app vulas:a2c package vulas:upload vulas:t2c See here for more information on Vulas goals.","title":"Quick vs. deep scans"},{"location":"user/tutorials/jenkins_howto/#sap-build-pipelines","text":"SAP application projects can easily enable Vulas scans using the following SAP build pipelines. They do not require to setup an individual Jenkins job, as they support Vulas out-of-the-box.","title":"SAP build pipelines"},{"location":"user/tutorials/jenkins_howto/#piper","text":"Piper documentation Pipeline step executeVulasScan Important: Please note that parameters specified for the Piper pipeline step override Vulas settings specified in the pom.xml . For instance, the Piper parameter vulasSpaceToken determines the Vulas workspace into which the scan results will be uploaded, no matter what has been specified in the pom.xml of the application under analysis. See here for a list of all Piper parameter for the executeVulasScan pipelines step. Please read through the detailed instructions provided in the documentation of the Piper pipelines step to clarify configuration-related questions.","title":"Piper"},{"location":"user/tutorials/jenkins_howto/#codepipes","text":"Codepipes documentation Task type Vulas","title":"Codepipes"},{"location":"user/tutorials/jenkins_howto/#jenkins","text":"A typical Jenkins job configuration using the Vulas plugin for Maven comprises the following two build steps and one post-build action (see screenshot below): Build step for a quick scan or deep scan , depending on the expected run frequency. Build step -Dvulas vulas:report to create result reports (per default in folder target/vulas/result ). Post-build action with HTML Publisher Plugin to copy the Html report created by report into the Jenkins dashboard. As such, Vulas results can be consumed w/o the need to scroll through the verbose console output. Additional notes : The above assumes that the Vulas Maven profile is present in the project's pom.xml . The report goal should always be run in a separate Maven invocation. Otherwise, in case of multi-module Maven projects, report may throw a build exception before all of the modules have been analyzed.","title":"Jenkins"},{"location":"user/tutorials/python_cli/","text":"Scanning Python apps with the CLI \u00b6 Using Vulas for Python applications not built with SetupTools Prerequisites \u00b6 JDK 7 or later pip is installed and \"knows\" all application dependencies (check with pip list ) URLs of the backend service and apps Web frontend Apps Web frontend: http://vulas.mo.sap.corp:8080/apps Backend service: http://vulas.mo.sap.corp:8080/backend The token of a Vulas workspace Workspace creation If you do not have a workspace yet, you can easily create one by going on the application frontend and clicking on the third button in the lower left corner: For a detailed description of workspaces and of the inputs you have to provide in the form that is displayed when you click that button, please see this section of the manual . Download \u00b6 Please download the latest ZIP archive vulas-cli-<VERSION>.zip from GitHub Enterprise and extract it into a newly created folder. This folder will contain the following items: ./app/ Put the application code (python files) into this folder. It will be searched recursively, thus, it is possible to just copy the entire installation directory of an application into the folder. ./vulas-cli-<version>-jar-with-dependencies.jar An executable JAR, which is the actual command-line version of the Vulas client. This is what you will use later to execute Vulas scans. ./vulas-custom.properties.sample This is a template for the configuration file required by Vulas. You will change it in order to specify an identifier for your application (see below). Setup \u00b6 Rename the file vulas-custom.properties.sample to vulas-custom.properties and edit it to specify <GROUP> , <ARTIFACT> and <VERSION> of the application to be analyzed. Those settings will be used to uniquely identify the application in the backend. For Python applications, feel free to use the same value for both <GROUP> and <ARTIFACT> . Set the option vulas.core.space.token so that it is assigned your own workspace token. Put the application code (python files) into the folder ./app/ . Specify the setting vulas.core.bom.python.pip such that it points to a pip binary (not only the path in which the binary is located, but the binary itself, e.g., /foor/bar/pip ). pip will be used to determine the dependencies of your Python application. You can either use the global pip or one installed in a virtual environment ( virtualenv , Anaconda, etc.). # Full path to PIP binary (e.g., global installation, virtual environment or Anaconda) #vulas.core.bom.python.pip = <PATH-TO-PIP-BINARY>/pip Additional notes: Java resources contained in folder ./app/ will also be added as application code or dependencies. For the above reason, make sure that the Vulas CLI is not contained in ./app/ or other folders specified by setting vulas.core.app.sourceDir , if any. Goal execution \u00b6 See here for a description of all analysis goals. app \u00b6 java -jar vulas-cli-3.0.12-jar-with-dependencies.jar -goal app Connect to the apps Web frontend, then select your workspace and application. The table in tab Dependencies is populated. Dependencies with known vulnerabilities are shown in tab Vulnerabilities . Assess and mitigate Once app has been run, the assessment of findings can already start: Each finding shown on the Vulnerabilities tab corresponds to a dependency of an application on a component with a known security vulnerability. See here for more information on how to assess and mitigate findings. Other analysis goals can be used to collect further evidence concerning the reachability of vulnerable code. report \u00b6 java -jar vulas-cli-3.0.12-jar-with-dependencies.jar -goal report Check the console to see where the HTML, JSON and XML reports have been written to. clean \u00b6 java -jar vulas-cli-3.0.12-jar-with-dependencies.jar -goal clean All application-specific data in the Vulas backend are deleted. Run clean whenever the application changes If you already scanned your project in the past, you should run the clean goal prior to new analyses in order to delete the old analysis results in the backend. Otherwise, old analysis results will be shown together with new results. For example, if you updated a dependency from a vulnerable to a non-vulnerable version, both versions will be shown in the apps Web frontend. Useful links \u00b6 Automate with Jenkins Configure the client-side analysis Get help if you run into troubles Assess and mitigate reported vulnerabilities","title":"Scanning Python (CLI)"},{"location":"user/tutorials/python_cli/#scanning-python-apps-with-the-cli","text":"Using Vulas for Python applications not built with SetupTools","title":"Scanning Python apps with the CLI"},{"location":"user/tutorials/python_cli/#prerequisites","text":"JDK 7 or later pip is installed and \"knows\" all application dependencies (check with pip list ) URLs of the backend service and apps Web frontend Apps Web frontend: http://vulas.mo.sap.corp:8080/apps Backend service: http://vulas.mo.sap.corp:8080/backend The token of a Vulas workspace Workspace creation If you do not have a workspace yet, you can easily create one by going on the application frontend and clicking on the third button in the lower left corner: For a detailed description of workspaces and of the inputs you have to provide in the form that is displayed when you click that button, please see this section of the manual .","title":"Prerequisites"},{"location":"user/tutorials/python_cli/#download","text":"Please download the latest ZIP archive vulas-cli-<VERSION>.zip from GitHub Enterprise and extract it into a newly created folder. This folder will contain the following items: ./app/ Put the application code (python files) into this folder. It will be searched recursively, thus, it is possible to just copy the entire installation directory of an application into the folder. ./vulas-cli-<version>-jar-with-dependencies.jar An executable JAR, which is the actual command-line version of the Vulas client. This is what you will use later to execute Vulas scans. ./vulas-custom.properties.sample This is a template for the configuration file required by Vulas. You will change it in order to specify an identifier for your application (see below).","title":"Download"},{"location":"user/tutorials/python_cli/#setup","text":"Rename the file vulas-custom.properties.sample to vulas-custom.properties and edit it to specify <GROUP> , <ARTIFACT> and <VERSION> of the application to be analyzed. Those settings will be used to uniquely identify the application in the backend. For Python applications, feel free to use the same value for both <GROUP> and <ARTIFACT> . Set the option vulas.core.space.token so that it is assigned your own workspace token. Put the application code (python files) into the folder ./app/ . Specify the setting vulas.core.bom.python.pip such that it points to a pip binary (not only the path in which the binary is located, but the binary itself, e.g., /foor/bar/pip ). pip will be used to determine the dependencies of your Python application. You can either use the global pip or one installed in a virtual environment ( virtualenv , Anaconda, etc.). # Full path to PIP binary (e.g., global installation, virtual environment or Anaconda) #vulas.core.bom.python.pip = <PATH-TO-PIP-BINARY>/pip Additional notes: Java resources contained in folder ./app/ will also be added as application code or dependencies. For the above reason, make sure that the Vulas CLI is not contained in ./app/ or other folders specified by setting vulas.core.app.sourceDir , if any.","title":"Setup"},{"location":"user/tutorials/python_cli/#goal-execution","text":"See here for a description of all analysis goals.","title":"Goal execution"},{"location":"user/tutorials/python_cli/#app","text":"java -jar vulas-cli-3.0.12-jar-with-dependencies.jar -goal app Connect to the apps Web frontend, then select your workspace and application. The table in tab Dependencies is populated. Dependencies with known vulnerabilities are shown in tab Vulnerabilities . Assess and mitigate Once app has been run, the assessment of findings can already start: Each finding shown on the Vulnerabilities tab corresponds to a dependency of an application on a component with a known security vulnerability. See here for more information on how to assess and mitigate findings. Other analysis goals can be used to collect further evidence concerning the reachability of vulnerable code.","title":"app"},{"location":"user/tutorials/python_cli/#report","text":"java -jar vulas-cli-3.0.12-jar-with-dependencies.jar -goal report Check the console to see where the HTML, JSON and XML reports have been written to.","title":"report"},{"location":"user/tutorials/python_cli/#clean","text":"java -jar vulas-cli-3.0.12-jar-with-dependencies.jar -goal clean All application-specific data in the Vulas backend are deleted. Run clean whenever the application changes If you already scanned your project in the past, you should run the clean goal prior to new analyses in order to delete the old analysis results in the backend. Otherwise, old analysis results will be shown together with new results. For example, if you updated a dependency from a vulnerable to a non-vulnerable version, both versions will be shown in the apps Web frontend.","title":"clean"},{"location":"user/tutorials/python_cli/#useful-links","text":"Automate with Jenkins Configure the client-side analysis Get help if you run into troubles Assess and mitigate reported vulnerabilities","title":"Useful links"},{"location":"user/tutorials/python_setuptools_sap/","text":"Scanning Python apps packaged with Setuptools \u00b6 Using Vulas for Python applications (packaged/managed with Setuptools) Prerequisites \u00b6 JDK 7 or later pip and virtualenv are installed URLs of the backend service and apps Web frontend Apps Web frontend: http://vulas.mo.sap.corp:8080/apps Backend service: http://vulas.mo.sap.corp:8080/backend The token of a Vulas workspace setup.py in the root of the project to scan Workspace creation If you do not have a workspace yet, you can easily create one by going on the application frontend and clicking on the third button in the lower left corner: For a detailed description of workspaces and of the inputs you have to provide in the form that is displayed when you click that button, please see this section of the manual . Limitations \u00b6 As of today, the plugin supports the goals app , clean and report . The static and dynamic analyses ( a2c , test , t2c ) will be added in future. The deletion of workspaces ( cleanSpace ) can be done using the CLI. Setup \u00b6 Create a file vulas-python.cfg in the root directory of your Python project. It should contain at least the following configuration settings: vulas.core.space.token = WORKSPACE_TOKEN vulas.shared.backend.serviceUrl = http://vulas.mo.sap.corp:8080/backend vulas.core.backendConnection = READ_WRITE Install the Setuptools plugin for Vulas: python -m pip install --upgrade vulas-plugin-setuptools . Goal execution \u00b6 See here for a description of all analysis goals. app \u00b6 python setup.py app Connect to the apps Web frontend, then select your workspace and application. The table in tab Dependencies is populated. Dependencies with known vulnerabilities are shown in tab Vulnerabilities . Assess and mitigate Once app has been run, the assessment of findings can already start: Each finding shown on the Vulnerabilities tab corresponds to a dependency of an application on a component with a known security vulnerability. See here for more information on how to assess and mitigate findings. Other analysis goals can be used to collect further evidence concerning the reachability of vulnerable code. report \u00b6 python setup.py report Check the console to see where the HTML, JSON and XML reports have been written to. clean \u00b6 python setup.py clean All application-specific data in the Vulas backend are deleted. Run clean whenever the application changes If you already scanned your project in the past, you should run the clean goal prior to new analyses in order to delete the old analysis results in the backend. Otherwise, old analysis results will be shown together with new results. For example, if you updated a dependency from a vulnerable to a non-vulnerable version, both versions will be shown in the apps Web frontend. Useful links \u00b6 Automate with Jenkins Configure the client-side analysis Get help if you run into troubles Assess and mitigate reported vulnerabilities","title":"Scanning Python (Setuptools)"},{"location":"user/tutorials/python_setuptools_sap/#scanning-python-apps-packaged-with-setuptools","text":"Using Vulas for Python applications (packaged/managed with Setuptools)","title":"Scanning Python apps packaged with Setuptools"},{"location":"user/tutorials/python_setuptools_sap/#prerequisites","text":"JDK 7 or later pip and virtualenv are installed URLs of the backend service and apps Web frontend Apps Web frontend: http://vulas.mo.sap.corp:8080/apps Backend service: http://vulas.mo.sap.corp:8080/backend The token of a Vulas workspace setup.py in the root of the project to scan Workspace creation If you do not have a workspace yet, you can easily create one by going on the application frontend and clicking on the third button in the lower left corner: For a detailed description of workspaces and of the inputs you have to provide in the form that is displayed when you click that button, please see this section of the manual .","title":"Prerequisites"},{"location":"user/tutorials/python_setuptools_sap/#limitations","text":"As of today, the plugin supports the goals app , clean and report . The static and dynamic analyses ( a2c , test , t2c ) will be added in future. The deletion of workspaces ( cleanSpace ) can be done using the CLI.","title":"Limitations"},{"location":"user/tutorials/python_setuptools_sap/#setup","text":"Create a file vulas-python.cfg in the root directory of your Python project. It should contain at least the following configuration settings: vulas.core.space.token = WORKSPACE_TOKEN vulas.shared.backend.serviceUrl = http://vulas.mo.sap.corp:8080/backend vulas.core.backendConnection = READ_WRITE Install the Setuptools plugin for Vulas: python -m pip install --upgrade vulas-plugin-setuptools .","title":"Setup"},{"location":"user/tutorials/python_setuptools_sap/#goal-execution","text":"See here for a description of all analysis goals.","title":"Goal execution"},{"location":"user/tutorials/python_setuptools_sap/#app","text":"python setup.py app Connect to the apps Web frontend, then select your workspace and application. The table in tab Dependencies is populated. Dependencies with known vulnerabilities are shown in tab Vulnerabilities . Assess and mitigate Once app has been run, the assessment of findings can already start: Each finding shown on the Vulnerabilities tab corresponds to a dependency of an application on a component with a known security vulnerability. See here for more information on how to assess and mitigate findings. Other analysis goals can be used to collect further evidence concerning the reachability of vulnerable code.","title":"app"},{"location":"user/tutorials/python_setuptools_sap/#report","text":"python setup.py report Check the console to see where the HTML, JSON and XML reports have been written to.","title":"report"},{"location":"user/tutorials/python_setuptools_sap/#clean","text":"python setup.py clean All application-specific data in the Vulas backend are deleted. Run clean whenever the application changes If you already scanned your project in the past, you should run the clean goal prior to new analyses in order to delete the old analysis results in the backend. Otherwise, old analysis results will be shown together with new results. For example, if you updated a dependency from a vulnerable to a non-vulnerable version, both versions will be shown in the apps Web frontend.","title":"clean"},{"location":"user/tutorials/python_setuptools_sap/#useful-links","text":"Automate with Jenkins Configure the client-side analysis Get help if you run into troubles Assess and mitigate reported vulnerabilities","title":"Useful links"},{"location":"user/tutorials/reports/","text":"Reports comprehension \u00b6 Coming soon This is being written, please come back later.","title":"Understanding reports"},{"location":"user/tutorials/reports/#reports-comprehension","text":"Coming soon This is being written, please come back later.","title":"Reports comprehension"},{"location":"user/tutorials/vulas-migration-2-to-3_sap/","text":"Migrate from version 2 to 3 \u00b6 Please notice that as starting of Feb,2019 Vulas 2.x will no longer be supported/usable. The usage of the public workspace which is used as default workspace for Vulas 2.x users will also be discontinued. Vulas users must migrate to 3.0.12 3.0.12 and use the workspace feature before this date. In case you are using Vulas 2.x and you would like to nove to Vulas 3.x (which is strongly recommanded), the followings steps should be considered: Vulas 3.x came with a plugin renaming. Vulas 3.x came with a new feature called \"workspace\". Workspaces \u00b6 When using Vulas 2.x, the results of all the scans of all the users are ending on the Vulas frontend in the same \"bucket\", e.g. it means that all the scanned modules of all the projects were listed on the left part of the Vulas Frontend screen. With the increasing number of Vulas users, and in order to allow users to only view all their related projects and modules at glance, Vulas 3.x now offers the possibility to create workspaces. In order to use a workspace, you first need to create a workspace using the Vulas Frontend. Workspace creation If you do not have a workspace yet, you can easily create one by going on the application frontend and clicking on the third button in the lower left corner: For a detailed description of workspaces and of the inputs you have to provide in the form that is displayed when you click that button, please see this section of the manual . Once the workspace is created, you should use the token received in step 1. and use it as a property in his pom.xml file as follow for java project: <vulas.core.space.token> WORKSPACE_TOKEN </vulas.core.space.token> Once the scans have been performed, you can see the results by going to the Vulas Frontend, clicking the \"settings\" button on the bottom left tool bar. Once the menu is open, enter your workspace token into the \"Space\" field and then press the \"Save\" button. The application will then load all the data related to your workspace and all your modules will be listed on the left of the screen. Note: It is strongly recommended to use workspaces as they allow to associate a PPMS object version to the workspace itself. These PPMS information are then used by the security entity to check security check coverage for SAP applications. Note 2: When saving your settings, they are locally stored as a cooky. It means that these settings will still be used on the next time you open the Vulas frontend. Once the workspace has been created and referenced in the properties of Vulas, each scan result for the user project will end in this dedicated workspace. Plugin remaning and general settings \u00b6 As mentioned before, you need to update your settings to use Vulas 3.x instead of Vulas 2.x when using the Maven plugin. The Vulas plugin was renamed in Vulas 3.x: it was changed from vulas-maven-plugin to plugin-maven . You will need to update your settings accordingly. Basically you should change the lines of your pom.xml file from: <plugin> <groupId> com.sap.research.security.vulas </groupId> <artifactId> vulas-maven-plugin </artifactId> <version> ${vulas.version} </version> <configuration> ... to <plugin> <groupId> com.sap.research.security.vulas </groupId> <artifactId> plugin-maven </artifactId> <version> ${vulas.version} </version> <configuration> <layeredConfiguration> <vulas.core.space.token> ${vulas.core.space.token} </vulas.core.space.token> See here for more details about how to setup you environment to use Vulas 3.x plugin. There you will find the complete xml section to copy/paste into your pom.xml file.","title":"Migrate from version 2 to 3"},{"location":"user/tutorials/vulas-migration-2-to-3_sap/#migrate-from-version-2-to-3","text":"Please notice that as starting of Feb,2019 Vulas 2.x will no longer be supported/usable. The usage of the public workspace which is used as default workspace for Vulas 2.x users will also be discontinued. Vulas users must migrate to 3.0.12 3.0.12 and use the workspace feature before this date. In case you are using Vulas 2.x and you would like to nove to Vulas 3.x (which is strongly recommanded), the followings steps should be considered: Vulas 3.x came with a plugin renaming. Vulas 3.x came with a new feature called \"workspace\".","title":"Migrate from version 2 to 3"},{"location":"user/tutorials/vulas-migration-2-to-3_sap/#workspaces","text":"When using Vulas 2.x, the results of all the scans of all the users are ending on the Vulas frontend in the same \"bucket\", e.g. it means that all the scanned modules of all the projects were listed on the left part of the Vulas Frontend screen. With the increasing number of Vulas users, and in order to allow users to only view all their related projects and modules at glance, Vulas 3.x now offers the possibility to create workspaces. In order to use a workspace, you first need to create a workspace using the Vulas Frontend. Workspace creation If you do not have a workspace yet, you can easily create one by going on the application frontend and clicking on the third button in the lower left corner: For a detailed description of workspaces and of the inputs you have to provide in the form that is displayed when you click that button, please see this section of the manual . Once the workspace is created, you should use the token received in step 1. and use it as a property in his pom.xml file as follow for java project: <vulas.core.space.token> WORKSPACE_TOKEN </vulas.core.space.token> Once the scans have been performed, you can see the results by going to the Vulas Frontend, clicking the \"settings\" button on the bottom left tool bar. Once the menu is open, enter your workspace token into the \"Space\" field and then press the \"Save\" button. The application will then load all the data related to your workspace and all your modules will be listed on the left of the screen. Note: It is strongly recommended to use workspaces as they allow to associate a PPMS object version to the workspace itself. These PPMS information are then used by the security entity to check security check coverage for SAP applications. Note 2: When saving your settings, they are locally stored as a cooky. It means that these settings will still be used on the next time you open the Vulas frontend. Once the workspace has been created and referenced in the properties of Vulas, each scan result for the user project will end in this dedicated workspace.","title":"Workspaces"},{"location":"user/tutorials/vulas-migration-2-to-3_sap/#plugin-remaning-and-general-settings","text":"As mentioned before, you need to update your settings to use Vulas 3.x instead of Vulas 2.x when using the Maven plugin. The Vulas plugin was renamed in Vulas 3.x: it was changed from vulas-maven-plugin to plugin-maven . You will need to update your settings accordingly. Basically you should change the lines of your pom.xml file from: <plugin> <groupId> com.sap.research.security.vulas </groupId> <artifactId> vulas-maven-plugin </artifactId> <version> ${vulas.version} </version> <configuration> ... to <plugin> <groupId> com.sap.research.security.vulas </groupId> <artifactId> plugin-maven </artifactId> <version> ${vulas.version} </version> <configuration> <layeredConfiguration> <vulas.core.space.token> ${vulas.core.space.token} </vulas.core.space.token> See here for more details about how to setup you environment to use Vulas 3.x plugin. There you will find the complete xml section to copy/paste into your pom.xml file.","title":"Plugin remaning and general settings"},{"location":"user/tutorials/workspace_howto/","text":"Workspaces \u00b6 A workspace acts as a container to group the results of several application analyses. Prerequisites \u00b6 URL of the apps Web frontend: https://vulas.mo.sap.corp/apps Create workspace \u00b6 Proceed as follows to create a workspace. Note that by creating a workspace, you will also generate a token to be used when performing actual application scans. Connect to the apps Web frontend: https://vulas.mo.sap.corp/apps Click on the third button in the lower left corner: Enter the following workspace properties: Name : Must be provided. Note that the name is not unique, thus, there can be several workspaces having the same name. Description : Must be provided. Contact : Please provide the email address of a distribution list (DL) matching the regex DL_[0-9A-Fa-f]*@exchange.sap.corp . Important : Either contact or PPMS object number must be provided when creating a workspace. Export results : AGGREGATED: Findings are aggregated on workspace-level, one item for the entire workspace will be exported (to Sirius/Security Hub) DETAILED: Findings are aggregated on application-level, one item for every application of the workspace will be exported OFF: No export of findings Public : A public workspace appears in the drop-down box of the apps Web frontend, a private one does not. Important: It will not be possible to retrieve the token of a private space at later points in time, thus, note it down when it is shown right after workspace creation. PPMS Object Number : If possible, provide the object number (not the name) of the PPMS Software Component Version (SCV), Product Version (PV) or Build Version (BV) corresponding to the application(s) scanned in the context of this workspace. No alphanumeric characters are allowed. The provision of the object number makes tool adoption (coverage) at SAP transparent, and allows reaching out to development teams in case of high-profile vulnerabilities (discussed in mainstream media). Example: In order to specify the PPMS object number of SAP NETWEAVER AS JAVA 7.2 (cf. screenshot), one should enter 01200314690900001979 when creating a workspace. Once the fields have been filled, press the \"Save\" button. The system then returns with a pop-up containing the random token generated upon workspace creation. Do not forget to note down this token, it will be needed later on for each scan of your application(s). Use workspace \u00b6 To use a workspace, you need to pass the token as configuration parameter vulas.core.space.token . See here for more information on how-to configure the scans clients or continue with the scan tutorials .","title":"Workspaces"},{"location":"user/tutorials/workspace_howto/#workspaces","text":"A workspace acts as a container to group the results of several application analyses.","title":"Workspaces"},{"location":"user/tutorials/workspace_howto/#prerequisites","text":"URL of the apps Web frontend: https://vulas.mo.sap.corp/apps","title":"Prerequisites"},{"location":"user/tutorials/workspace_howto/#create-workspace","text":"Proceed as follows to create a workspace. Note that by creating a workspace, you will also generate a token to be used when performing actual application scans. Connect to the apps Web frontend: https://vulas.mo.sap.corp/apps Click on the third button in the lower left corner: Enter the following workspace properties: Name : Must be provided. Note that the name is not unique, thus, there can be several workspaces having the same name. Description : Must be provided. Contact : Please provide the email address of a distribution list (DL) matching the regex DL_[0-9A-Fa-f]*@exchange.sap.corp . Important : Either contact or PPMS object number must be provided when creating a workspace. Export results : AGGREGATED: Findings are aggregated on workspace-level, one item for the entire workspace will be exported (to Sirius/Security Hub) DETAILED: Findings are aggregated on application-level, one item for every application of the workspace will be exported OFF: No export of findings Public : A public workspace appears in the drop-down box of the apps Web frontend, a private one does not. Important: It will not be possible to retrieve the token of a private space at later points in time, thus, note it down when it is shown right after workspace creation. PPMS Object Number : If possible, provide the object number (not the name) of the PPMS Software Component Version (SCV), Product Version (PV) or Build Version (BV) corresponding to the application(s) scanned in the context of this workspace. No alphanumeric characters are allowed. The provision of the object number makes tool adoption (coverage) at SAP transparent, and allows reaching out to development teams in case of high-profile vulnerabilities (discussed in mainstream media). Example: In order to specify the PPMS object number of SAP NETWEAVER AS JAVA 7.2 (cf. screenshot), one should enter 01200314690900001979 when creating a workspace. Once the fields have been filled, press the \"Save\" button. The system then returns with a pop-up containing the random token generated upon workspace creation. Do not forget to note down this token, it will be needed later on for each scan of your application(s).","title":"Create workspace"},{"location":"user/tutorials/workspace_howto/#use-workspace","text":"To use a workspace, you need to pass the token as configuration parameter vulas.core.space.token . See here for more information on how-to configure the scans clients or continue with the scan tutorials .","title":"Use workspace"},{"location":"user/tutorials/workspace_howto_advanced/","text":"Workspaces \u00b6 If an application has been already released to customers and, at the same time, new releases are under development, you may want to setup workspaces as follows: One workspace for the development branch, to prevent that vulnerable dependencies are introduced at development time One workspace for every release branch, to monitor whether there are new vulnerabilities for dependencies of production releases","title":"Workspaces"},{"location":"user/tutorials/workspace_howto_advanced/#workspaces","text":"If an application has been already released to customers and, at the same time, new releases are under development, you may want to setup workspaces as follows: One workspace for the development branch, to prevent that vulnerable dependencies are introduced at development time One workspace for every release branch, to monitor whether there are new vulnerabilities for dependencies of production releases","title":"Workspaces"},{"location":"user/tutorials/partials/create_workspace/","text":"Workspace creation If you do not have a workspace yet, you can easily create one by going on the application frontend and clicking on the third button in the lower left corner: For a detailed description of workspaces and of the inputs you have to provide in the form that is displayed when you click that button, please see this section of the manual .","title":"Create workspace"},{"location":"user/tutorials/partials/vulas_profile/","text":"<profile> <id> vulas </id> <activation> <property> <name> vulas </name> </property> </activation> <properties> <vulas.version> 3.0.12 </vulas.version> <vulas.shared.backend.serviceUrl> http://vulas.mo.sap.corp:8080/backend </vulas.shared.backend.serviceUrl> <vulas.core.space.token> WORKSPACE_TOKEN </vulas.core.space.token> <vulas.core.appContext.group> ${project.groupId} </vulas.core.appContext.group> <vulas.core.appContext.artifact> ${project.artifactId} </vulas.core.appContext.artifact> <vulas.core.appContext.version> ${project.version} </vulas.core.appContext.version> </properties> <build> <plugins> <!-- Copies Vulas JARs to ${project.build.directory}/vulas/lib and incl, which is needed for the instrumentation of JUnit tests. --> <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-dependency-plugin </artifactId> <version> 2.10 </version> <executions> <execution> <id> copy-vulas </id> <phase> generate-test-resources </phase> <goals> <goal> copy </goal> </goals> <configuration> <artifactItems> <artifactItem> <groupId> com.sap.research.security.vulas </groupId> <artifactId> lang-java </artifactId> <version> ${vulas.version} </version> <type> jar </type> <classifier> jar-with-dependencies </classifier> <outputDirectory> ${project.build.directory}/vulas/lib </outputDirectory> <destFileName> vulas-core-latest-jar-with-dependencies.jar </destFileName> </artifactItem> <artifactItem> <groupId> com.sap.research.security.vulas </groupId> <artifactId> lang-java </artifactId> <version> ${vulas.version} </version> <type> jar </type> <classifier> jar-with-dependencies </classifier> <outputDirectory> ${project.build.directory}/vulas/include </outputDirectory> <destFileName> vulas-core-latest-jar-with-dependencies.jar </destFileName> </artifactItem> </artifactItems> </configuration> </execution> </executions> </plugin> <!-- Registers the Vulas agent at JVM startup (and specifies a couple of configuration settings) --> <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-surefire-plugin </artifactId> <version> 2.21.0 </version> <configuration> <!-- If set to 0, no separate JVM process will be spawned, i.e., one can use mvnDebug and JVM params can be added to the Maven (rather than putting them in the Surefire plugin configuration) (default: 1) --> <forkCount> 1 </forkCount> <!-- Kill the forked test process after a certain number of seconds. If set to 0, wait forever for the process, never timing out. This allows Vulas to (hopefully) upload all info in its shutdown hook. More info: https://maven.apache.org/surefire/maven-surefire-plugin/test-mojo.html, https://maven.apache.org/surefire/maven-surefire-plugin/examples/shutdown.html --> <forkedProcessTimeoutInSeconds> 0 </forkedProcessTimeoutInSeconds> <!-- Available as of 2.20 (or so), default is 30 --> <forkedProcessExitTimeoutInSeconds> 300 </forkedProcessExitTimeoutInSeconds> <!-- Note: System properties cannot be set at the Maven command line, they are not passed on to the JVM spawned by Surefire (if any, see parameter forkCount) --> <argLine> -javaagent:\"${project.build.directory}/vulas/lib/vulas-core-latest-jar-with-dependencies.jar\" -Dvulas.shared.backend.serviceUrl=${vulas.shared.backend.serviceUrl} -Dvulas.shared.tmpDir=${project.build.directory}/vulas/tmp -Dvulas.core.backendConnection=READ_ONLY -Dvulas.core.uploadDir=${project.build.directory}/vulas/upload -Dvulas.core.monitor.periodicUpload.enabled=false -Dvulas.core.appContext.group=${vulas.core.appContext.group} -Dvulas.core.appContext.artifact=${vulas.core.appContext.artifact} -Dvulas.core.appContext.version=${vulas.core.appContext.version} -Dvulas.core.instr.writeCode=false -Dvulas.core.instr.maxStacktraces=10 -Dvulas.core.space.token=${vulas.core.space.token} -Dvulas.core.instr.instrumentorsChoosen=com.sap.psr.vulas.monitor.trace.SingleTraceInstrumentor -noverify <!-- Uncomment to write the heap to disk in case of memory issues --> <!-- -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=${project.build.directory}/vulas/tmp --> <!-- Uncomment to debug the test execution or the Vulas plugin --> <!-- -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000 --> </argLine> <!-- Exclude problematic tests --> <excludes> <exclude> **/doesnotexist.java </exclude> </excludes> </configuration> </plugin> <plugin> <groupId> com.sap.research.security.vulas </groupId> <artifactId> plugin-maven </artifactId> <version> ${vulas.version} </version> <configuration> <layeredConfiguration> <vulas.shared.backend.serviceUrl> ${vulas.shared.backend.serviceUrl} </vulas.shared.backend.serviceUrl> <vulas.core.space.token> ${vulas.core.space.token} </vulas.core.space.token> <vulas.core.appContext.group> ${vulas.core.appContext.group} </vulas.core.appContext.group> <vulas.core.appContext.artifact> ${vulas.core.appContext.artifact} </vulas.core.appContext.artifact> <vulas.core.appContext.version> ${vulas.core.appContext.version} </vulas.core.appContext.version> <vulas.shared.tmpDir> ${project.build.directory}/vulas/tmp </vulas.shared.tmpDir> <vulas.core.uploadDir> ${project.build.directory}/vulas/upload </vulas.core.uploadDir> <vulas.core.app.sourceDir> ${project.build.directory}/classes,${project.basedir}/src/main/java,${project.basedir}/src/main/python </vulas.core.app.sourceDir> <!-- vulas:instr : Instruments JAR/WAR files found in source dir, and writes to target dir. Files in include dir are put into /WEB-INF/lib of output WARs. Files in lib dir are part of the class path when instrumenting. --> <vulas.core.instr.sourceDir> ${project.build.directory} </vulas.core.instr.sourceDir> <vulas.core.instr.targetDir> ${project.build.directory}/vulas/target </vulas.core.instr.targetDir> <vulas.core.instr.includeDir> ${project.build.directory}/vulas/include </vulas.core.instr.includeDir> <vulas.core.instr.libDir> ${project.build.directory}/vulas/lib </vulas.core.instr.libDir> <vulas.core.instr.writeCode> false </vulas.core.instr.writeCode> <vulas.core.instr.searchRecursive> false </vulas.core.instr.searchRecursive> <!-- vulas:a2c/t2c : Performs static call graph analysis --> <vulas.reach.wala.callgraph.reflection> NO_FLOW_TO_CASTS_NO_METHOD_INVOKE </vulas.reach.wala.callgraph.reflection> <vulas.reach.timeout> 60 </vulas.reach.timeout> <!-- vulas:report --> <vulas.report.exceptionExcludeBugs></vulas.report.exceptionExcludeBugs> <vulas.report.reportDir> ${project.build.directory}/vulas/report </vulas.report.reportDir> <vulas.report.sap.scv> replace-with-PPMS-object-number </vulas.report.sap.scv> </layeredConfiguration> </configuration> </plugin> </plugins> </build> </profile>","title":"Vulas profile"},{"location":"vuln_db/","text":"Vulnerability database \u00b6 The vulnerability database is the knowledge base of the vulnerability assessment tool. The tool is able to detect and assess all and only the vulnerabilities present in the knowledge base. Step by step tutorial Here you can find the steps to populate your vulnerability database with five known vulnerabilities. Go to the Tutorials page Manual Here you can find a description of the main activities and tool around the vulnerability database. Go to the Vulnerability Database Manual Contribute to the vulnerability database Here you can find information about how to contribute new known vulnerabilities Go to the Contribute page Orange Hourglass Whenever an application library contains the signature of a construct that was changed to fix a vulnerability, but the patch lib analyzer didn't yet (or could not) establish whether it contains the vulnerable or fixed version of the construct, then the tool reports the vulnerability in the web frontend with an ORANGE hourglass in the column \"Inclusion of vulnerable code\". To resolve orange hourglasses it's necessary to feed the tool with the information whether the library contains the vulnerable or fixed version of the construct changed in the vulnerability fix. This can be done either manually or automatically with the patch-lib-analyzer (for a subset of cases).","title":"Vulnerability database"},{"location":"vuln_db/#vulnerability-database","text":"The vulnerability database is the knowledge base of the vulnerability assessment tool. The tool is able to detect and assess all and only the vulnerabilities present in the knowledge base. Step by step tutorial Here you can find the steps to populate your vulnerability database with five known vulnerabilities. Go to the Tutorials page Manual Here you can find a description of the main activities and tool around the vulnerability database. Go to the Vulnerability Database Manual Contribute to the vulnerability database Here you can find information about how to contribute new known vulnerabilities Go to the Contribute page Orange Hourglass Whenever an application library contains the signature of a construct that was changed to fix a vulnerability, but the patch lib analyzer didn't yet (or could not) establish whether it contains the vulnerable or fixed version of the construct, then the tool reports the vulnerability in the web frontend with an ORANGE hourglass in the column \"Inclusion of vulnerable code\". To resolve orange hourglasses it's necessary to feed the tool with the information whether the library contains the vulnerable or fixed version of the construct changed in the vulnerability fix. This can be done either manually or automatically with the patch-lib-analyzer (for a subset of cases).","title":"Vulnerability database"},{"location":"vuln_db/browser_ext_sap/","text":"Extension for Chrome and Firefox \u00b6 Imagine you come across yet another blog post or security advisory that mentions one or more critical vulnerabilities having cryptic CVE identifiers. Yet another time you wonder whether this vulnerability is new, or whether it is the one you already looked at 2 weeks ago. And is it possible to use 3.0.12 to check whether your application is affected? If only the CVE identifiers were more speaking... This browser extension comes to your rescue: It can be activated on any Web page in order to highlight whether CVEs mentioned thereon are covered by 3.0.12 or not. If not, you can use the extension to open or create tickets in the 3.0.12 Jira in order to suggest us to update the 3.0.12 Vulnerability Database. Install Firefox Chrome Use Install \u00b6 The extension is available both for Chrome and Firefox. Note, however, that the Chrome extension requires the developer mode to be enabled. Moreover, upon every restart of Chrome, you need to confirm that you want to keep the extension. All of this is required because the extension is not available in the public Chrome Web Store. Firefox \u00b6 Download the following file to your computer: vulas_vulnerability_database_coverage_info-2.3.6-an+fx.xpi Open Firefox and enter \"about:addons\" Click on the configuration wheel , and \"Install Add-on From File...\" Select the file downloaded before and confirm the following dialogs After successful installation, you should see the following new icon: Chrome \u00b6 Download the following file to your computer: 3.0.12-Coverage-Info-2.3.1.crx Open it with WinRar and unzip it somewhere on your computer Open Chrome and enter \"chrome://extensions/\" Enable \"Developer mode\" Click on \"Load unpacked extension...\", and select the directory of the unzipped archive Important: Upon every restart of Chrome, you will need to click on \"Cancel\" in the following dialog in order to keep the extension. This is required since we do not want to upload the plugin to the Chrome Web Store. Use \u00b6 In order to identify and check all CVEs on a given Web page, click on the Vulas icon. Once the extension got activated for the current page, a colored circle will be shown behind every CVE identifier mentioned on the current Web page (cf. the example screenshot of https://www.cloudfoundry.org/category/security/ ). The color code is as follows, hovering over the circle will provide some context information and a link: Green: The vulnerability is part of the 3.0.12 Vulnerability Database, i.e., you can use 3.0.12 to check whether your application is affected. (Link open the Vulas documentation) Orange: The vulnerability is not part of the database, but there exists a related JIRA ticket (status: open) that is used to discuss its analysis. (Link opens the respective ticket) Purple: The vulnerability is out of scope for 3.0.12, and there exists a related JIRA ticket (status: closed) that explains why that is so. (Link opens the respective ticket) Grey: The vulnerability is not part of the database, nor is it discussed in JIRA. (Link creates a new ticket to discuss whether the vulnerability is to be added to the database)","title":"Browser extensions"},{"location":"vuln_db/browser_ext_sap/#extension-for-chrome-and-firefox","text":"Imagine you come across yet another blog post or security advisory that mentions one or more critical vulnerabilities having cryptic CVE identifiers. Yet another time you wonder whether this vulnerability is new, or whether it is the one you already looked at 2 weeks ago. And is it possible to use 3.0.12 to check whether your application is affected? If only the CVE identifiers were more speaking... This browser extension comes to your rescue: It can be activated on any Web page in order to highlight whether CVEs mentioned thereon are covered by 3.0.12 or not. If not, you can use the extension to open or create tickets in the 3.0.12 Jira in order to suggest us to update the 3.0.12 Vulnerability Database. Install Firefox Chrome Use","title":"Extension for Chrome and Firefox"},{"location":"vuln_db/browser_ext_sap/#install","text":"The extension is available both for Chrome and Firefox. Note, however, that the Chrome extension requires the developer mode to be enabled. Moreover, upon every restart of Chrome, you need to confirm that you want to keep the extension. All of this is required because the extension is not available in the public Chrome Web Store.","title":"Install"},{"location":"vuln_db/browser_ext_sap/#firefox","text":"Download the following file to your computer: vulas_vulnerability_database_coverage_info-2.3.6-an+fx.xpi Open Firefox and enter \"about:addons\" Click on the configuration wheel , and \"Install Add-on From File...\" Select the file downloaded before and confirm the following dialogs After successful installation, you should see the following new icon:","title":"Firefox"},{"location":"vuln_db/browser_ext_sap/#chrome","text":"Download the following file to your computer: 3.0.12-Coverage-Info-2.3.1.crx Open it with WinRar and unzip it somewhere on your computer Open Chrome and enter \"chrome://extensions/\" Enable \"Developer mode\" Click on \"Load unpacked extension...\", and select the directory of the unzipped archive Important: Upon every restart of Chrome, you will need to click on \"Cancel\" in the following dialog in order to keep the extension. This is required since we do not want to upload the plugin to the Chrome Web Store.","title":"Chrome"},{"location":"vuln_db/browser_ext_sap/#use","text":"In order to identify and check all CVEs on a given Web page, click on the Vulas icon. Once the extension got activated for the current page, a colored circle will be shown behind every CVE identifier mentioned on the current Web page (cf. the example screenshot of https://www.cloudfoundry.org/category/security/ ). The color code is as follows, hovering over the circle will provide some context information and a link: Green: The vulnerability is part of the 3.0.12 Vulnerability Database, i.e., you can use 3.0.12 to check whether your application is affected. (Link open the Vulas documentation) Orange: The vulnerability is not part of the database, but there exists a related JIRA ticket (status: open) that is used to discuss its analysis. (Link opens the respective ticket) Purple: The vulnerability is out of scope for 3.0.12, and there exists a related JIRA ticket (status: closed) that explains why that is so. (Link opens the respective ticket) Grey: The vulnerability is not part of the database, nor is it discussed in JIRA. (Link creates a new ticket to discuss whether the vulnerability is to be added to the database)","title":"Use"},{"location":"vuln_db/vuln_db_sap/","text":"Keeping up with new disclosures \u00b6 The process established to maintain the Vulas vulnerability database is as follows: In short: The Vulas team monitors several information sources, general and component-specific, in order to learn about the disclosure of new security vulnerabilities. This is done using a nightly cron job that fetches the content of the respective URL and compares it to the content of the previous run. Within a few working days after its disclosure, the Vulas teams creates the corresponding change list in the Vulas vulnerability databases. This is done by identifying and analyzing the source code commits that fixed the problem in the respective code repository. General information sources \u00b6 The following general information sources provide vulnerability information for all kinds of components and programming languages. NVD https://nvd.nist.gov/vuln/search/results?adv_search=false&form_type=basic&results_type=overview&search_type=last3months&query=java Cloud Foundry https://www.cloudfoundry.org/category/security/ Snyk https://snyk.io Specific Java projects \u00b6 The below-mentioned open-source components are considered to be of special importance to SAP because one or more of the following holds true: The component is among the Top 20 components used by SAP applications (according to Black Duck @ SAP, from 29.05.2017) It has been identified by the AIS security team It is among the 20 most-used direct dependencies in the Vulas database (excluding scopes TEST and PROVIDED, from 29.05.2017) For those, component-specific security advisory page are monitored.","title":"SAP-specific content"},{"location":"vuln_db/vuln_db_sap/#keeping-up-with-new-disclosures","text":"The process established to maintain the Vulas vulnerability database is as follows: In short: The Vulas team monitors several information sources, general and component-specific, in order to learn about the disclosure of new security vulnerabilities. This is done using a nightly cron job that fetches the content of the respective URL and compares it to the content of the previous run. Within a few working days after its disclosure, the Vulas teams creates the corresponding change list in the Vulas vulnerability databases. This is done by identifying and analyzing the source code commits that fixed the problem in the respective code repository.","title":"Keeping up with new disclosures"},{"location":"vuln_db/vuln_db_sap/#general-information-sources","text":"The following general information sources provide vulnerability information for all kinds of components and programming languages. NVD https://nvd.nist.gov/vuln/search/results?adv_search=false&form_type=basic&results_type=overview&search_type=last3months&query=java Cloud Foundry https://www.cloudfoundry.org/category/security/ Snyk https://snyk.io","title":"General information sources"},{"location":"vuln_db/vuln_db_sap/#specific-java-projects","text":"The below-mentioned open-source components are considered to be of special importance to SAP because one or more of the following holds true: The component is among the Top 20 components used by SAP applications (according to Black Duck @ SAP, from 29.05.2017) It has been identified by the AIS security team It is among the 20 most-used direct dependencies in the Vulas database (excluding scopes TEST and PROVIDED, from 29.05.2017) For those, component-specific security advisory page are monitored.","title":"Specific Java projects"},{"location":"vuln_db/manuals/","text":"Vulnerability Database Manual \u00b6 The code-level vulnerability analysis performed by Vulas is based on the so-called change list, which is a set of constructs (e.g., Java methods) changed to fix a given security vulnerability. Vulnerability detection is based on construct containment: a library is affected by a vulnerability if it contains the constructs that were changed to fix a vulnerability. Once a vulnerability's change list has been created and added to the database, every application analyzed in the past is automatically assessed with regard to the new vulnerability. In other words, application owners see immediately whether their application is affected or not, without the need to re-run the analysis. An up-to-date list of all vulnerabilities currently comprised in the database can be obtained using the following link: http://vulas.mo.sap.corp:8080/backend/bugs Detailed information for a given vulnerability can be obtained using the following link, whereby <foo> has to be replaced by the vulnerability identifier: http://vulas.mo.sap.corp:8080/backend/bugs/<foo> The Patch Analyzer module can be used to add vulnerabilities to the knowledge base. In the current implementation, the vulnerability detection is based on the containment of the fully-qualified name of a construct changed to fix a vulnerability in a library. The information whether the library contains the vulnerable or fixed version of the construct is computed asynchronously by the Patch Lib Analyzer .","title":"Intro"},{"location":"vuln_db/manuals/#vulnerability-database-manual","text":"The code-level vulnerability analysis performed by Vulas is based on the so-called change list, which is a set of constructs (e.g., Java methods) changed to fix a given security vulnerability. Vulnerability detection is based on construct containment: a library is affected by a vulnerability if it contains the constructs that were changed to fix a vulnerability. Once a vulnerability's change list has been created and added to the database, every application analyzed in the past is automatically assessed with regard to the new vulnerability. In other words, application owners see immediately whether their application is affected or not, without the need to re-run the analysis. An up-to-date list of all vulnerabilities currently comprised in the database can be obtained using the following link: http://vulas.mo.sap.corp:8080/backend/bugs Detailed information for a given vulnerability can be obtained using the following link, whereby <foo> has to be replaced by the vulnerability identifier: http://vulas.mo.sap.corp:8080/backend/bugs/<foo> The Patch Analyzer module can be used to add vulnerabilities to the knowledge base. In the current implementation, the vulnerability detection is based on the containment of the fully-qualified name of a construct changed to fix a vulnerability in a library. The information whether the library contains the vulnerable or fixed version of the construct is computed asynchronously by the Patch Lib Analyzer .","title":"Vulnerability Database Manual"},{"location":"vuln_db/manuals/manual_assessment/","text":"Manual Assessment \u00b6 The manual assessment can be done from the bugs frontend https://vulas.mo.sap.corp/bugs , by setting the assessment to the appropriate value in the \"Assessment (Manual)\" column and clicking the \"Save\" button. Our recommendation is to always rely on code (manually inspecting it in the worst case) in order to take a decision. The versions indicated in the vulnerability's description were proved wrong in multiple cases. The column \"Patch eval\" shows information about the results (if any) of the patch lib analyzer. By clicking on the cell the results obtained by code comparison for each elements of the bug change list are shown. If available, it is recommended to use them in order to take a decision about the vulnerability of the corresponding library version.","title":"Manual Assessment"},{"location":"vuln_db/manuals/manual_assessment/#manual-assessment","text":"The manual assessment can be done from the bugs frontend https://vulas.mo.sap.corp/bugs , by setting the assessment to the appropriate value in the \"Assessment (Manual)\" column and clicking the \"Save\" button. Our recommendation is to always rely on code (manually inspecting it in the worst case) in order to take a decision. The versions indicated in the vulnerability's description were proved wrong in multiple cases. The column \"Patch eval\" shows information about the results (if any) of the patch lib analyzer. By clicking on the cell the results obtained by code comparison for each elements of the bug change list are shown. If available, it is recommended to use them in order to take a decision about the vulnerability of the corresponding library version.","title":"Manual Assessment"},{"location":"vuln_db/manuals/patch_analyzer/","text":"Patch Analyzer \u00b6 The vulnerability database contains known vulnerabilities for which a fix (aka patch) exists. In fact, the fix (commit fix in the vulnerable library project) of the vulnerability must be provided in order to add a vulnerability to the database. Each vulnerability in the database is characterized by the set of program constructs that were changed in order to fix it. Program Construct A program construct (or simply construct) is a structural element of the source code characterized by a type (e.g., package , class , constructor , method ), a language (e.g., Java, Python), and a unique identifier (e.g., the fully-qualified name). Construct Change A construct change is characterized by a change operation (i.e., addition, deletion or modification) on a construct. In case of modifications the vulnerability database also contains the abstract syntax tree (AST) of the construct before and after the fix, i.e., the AST of the vulnerable and fixed construct. The analysis can be done using the patch-analyzer module. Configuration \u00b6 To add a new vulnerability fixed in a given library repository, the following fields need to be provided as input: bug (-b) <arg> : vulnerability identifier repo (-r) <arg> : URL of the VCS repository hosting the library project revision (-e) <arg> : One or multiple revisions (multiple ones must be comma-separated w/o blanks). In the case of Git repositories, the revision can be optionally concatenated with ':' with the branch information. description (-descr) <arg> : Textual vulnerability description (optional, it must be provided for vulnerabilities not available from the NVD) links (-links) <arg> : Comma-separated list of links to comprehensive vulnerability information (optional, it must be provided for vulnerabilities not available from the NVD) skip-if-existing (-sie) : Skips the analysis of a vulnerability if it already exists in the backend upload (-u) : Upload construct changes Additionally the Vulas backend service URL must be configured (see here for instructions). Info In case you want to be sure about the analysis result before uploading it to the backend, you can run the analysis without the -u option so that the resulting JSON will be saved to file for you to review (e.g., to check that the list of construct changes is not empty). The options -descr and -links can be used to add a custom description and/or link url. This is of utmost importance in case the vulnerability is not available in the NVD. Such information can also be provided from the bugs frontend after the bug has been created (both fields must be provided when saving). Critical If a vulnerability fix is applied in multiple repositories, it must be analysed as two separate vulnerabilities with different identifiers. Vulnerabilities without change list \u00b6 In case a vulnerability fix does not include any code change (e.g., only changes configuration parameters), it is still possible to add it to the vulnerability database by manually creating and POSTing the initial JSON. Also the initial affected versions have to be POSTed as JSON and then assessed via the bug frontend, see [Manual Assessments] (../../vuln_db/manual_assessment). The first POST request creates the entry into the vulnerabilities database (in the following example we create and entry for CVE \"S2-043\"): POST http://http://vulas.mo.sap.corp:8080/backend/bugs { \"bugId\" : \"S2-043\" , \"constructChanges\" : [], \"createdBy\" : \"sp\" , \"description\" : \"Usage of the Config Browser in a production environment can lead to exposing vunerable information of the application.\" , \"source\" : \"StrutsSecBulletin\" , \"reference\" : [ \"https://struts.apache.org/docs/s2-043.htm\" ] } The second POST request defines which versions to be marked as affected or not. Please notice that the id of the CVE to update (\"S2-403\" in the following example) has to be used/replaced in the following POST request. POST http://http://vulas.mo.sap.corp:8080/backend/bugs/S2-043/affectedLibIds?source=MANUAL [ { \"libraryId\" :{ \"artifact\" : \"struts2-core\" , \"version\" : \"2.0.11\" , \"group\" : \"org.apache.struts\" }, \"lib\" : null , \"affectedcc\" : [], \"source\" : \"MANUAL\" , \"affected\" : true } ] Vulnerabilities of proprietary libraries \u00b6 Vulas can also handle undisclosed vulnerabilities and proprietary components. This allows to make company-internal users of proprietary libraries aware and update to non-vulnerable versions. Send an email to DL VULAS in order to request the addition of such vulnerabilities to the database, and include the following info: Brief description of the vulnerability (max 2-3 lines) using the NVD vulnerability description style and phrasing (e.g. including the type of vulnerability, the affected software component). URL of the code repository of the affected component. Commit(s) used to the fix the vulnerability in the component. Links with additional information about the vulnerability (if available). Once this information is received by the Vulas team, an ID will be attributed to the vulnerability and a new entry will be created in the Vulas Database. All company-internal users will be notified in the same way as for publicly disclosed vulnerabilities in open-source components.","title":"Patch Analyzer"},{"location":"vuln_db/manuals/patch_analyzer/#patch-analyzer","text":"The vulnerability database contains known vulnerabilities for which a fix (aka patch) exists. In fact, the fix (commit fix in the vulnerable library project) of the vulnerability must be provided in order to add a vulnerability to the database. Each vulnerability in the database is characterized by the set of program constructs that were changed in order to fix it. Program Construct A program construct (or simply construct) is a structural element of the source code characterized by a type (e.g., package , class , constructor , method ), a language (e.g., Java, Python), and a unique identifier (e.g., the fully-qualified name). Construct Change A construct change is characterized by a change operation (i.e., addition, deletion or modification) on a construct. In case of modifications the vulnerability database also contains the abstract syntax tree (AST) of the construct before and after the fix, i.e., the AST of the vulnerable and fixed construct. The analysis can be done using the patch-analyzer module.","title":"Patch Analyzer"},{"location":"vuln_db/manuals/patch_analyzer/#configuration","text":"To add a new vulnerability fixed in a given library repository, the following fields need to be provided as input: bug (-b) <arg> : vulnerability identifier repo (-r) <arg> : URL of the VCS repository hosting the library project revision (-e) <arg> : One or multiple revisions (multiple ones must be comma-separated w/o blanks). In the case of Git repositories, the revision can be optionally concatenated with ':' with the branch information. description (-descr) <arg> : Textual vulnerability description (optional, it must be provided for vulnerabilities not available from the NVD) links (-links) <arg> : Comma-separated list of links to comprehensive vulnerability information (optional, it must be provided for vulnerabilities not available from the NVD) skip-if-existing (-sie) : Skips the analysis of a vulnerability if it already exists in the backend upload (-u) : Upload construct changes Additionally the Vulas backend service URL must be configured (see here for instructions). Info In case you want to be sure about the analysis result before uploading it to the backend, you can run the analysis without the -u option so that the resulting JSON will be saved to file for you to review (e.g., to check that the list of construct changes is not empty). The options -descr and -links can be used to add a custom description and/or link url. This is of utmost importance in case the vulnerability is not available in the NVD. Such information can also be provided from the bugs frontend after the bug has been created (both fields must be provided when saving). Critical If a vulnerability fix is applied in multiple repositories, it must be analysed as two separate vulnerabilities with different identifiers.","title":"Configuration"},{"location":"vuln_db/manuals/patch_analyzer/#vulnerabilities-without-change-list","text":"In case a vulnerability fix does not include any code change (e.g., only changes configuration parameters), it is still possible to add it to the vulnerability database by manually creating and POSTing the initial JSON. Also the initial affected versions have to be POSTed as JSON and then assessed via the bug frontend, see [Manual Assessments] (../../vuln_db/manual_assessment). The first POST request creates the entry into the vulnerabilities database (in the following example we create and entry for CVE \"S2-043\"): POST http://http://vulas.mo.sap.corp:8080/backend/bugs { \"bugId\" : \"S2-043\" , \"constructChanges\" : [], \"createdBy\" : \"sp\" , \"description\" : \"Usage of the Config Browser in a production environment can lead to exposing vunerable information of the application.\" , \"source\" : \"StrutsSecBulletin\" , \"reference\" : [ \"https://struts.apache.org/docs/s2-043.htm\" ] } The second POST request defines which versions to be marked as affected or not. Please notice that the id of the CVE to update (\"S2-403\" in the following example) has to be used/replaced in the following POST request. POST http://http://vulas.mo.sap.corp:8080/backend/bugs/S2-043/affectedLibIds?source=MANUAL [ { \"libraryId\" :{ \"artifact\" : \"struts2-core\" , \"version\" : \"2.0.11\" , \"group\" : \"org.apache.struts\" }, \"lib\" : null , \"affectedcc\" : [], \"source\" : \"MANUAL\" , \"affected\" : true } ]","title":"Vulnerabilities without change list"},{"location":"vuln_db/manuals/patch_analyzer/#vulnerabilities-of-proprietary-libraries","text":"Vulas can also handle undisclosed vulnerabilities and proprietary components. This allows to make company-internal users of proprietary libraries aware and update to non-vulnerable versions. Send an email to DL VULAS in order to request the addition of such vulnerabilities to the database, and include the following info: Brief description of the vulnerability (max 2-3 lines) using the NVD vulnerability description style and phrasing (e.g. including the type of vulnerability, the affected software component). URL of the code repository of the affected component. Commit(s) used to the fix the vulnerability in the component. Links with additional information about the vulnerability (if available). Once this information is received by the Vulas team, an ID will be attributed to the vulnerability and a new entry will be created in the Vulas Database. All company-internal users will be notified in the same way as for publicly disclosed vulnerabilities in open-source components.","title":"Vulnerabilities of proprietary libraries"},{"location":"vuln_db/manuals/patch_lib_analyzer/","text":"Patch Library Analyzer \u00b6 The patch library analyzer is a Java application that establishes whether a library contains a construct modified to fix a vulnerability (aka changed-construct) in its vulnerable or fixed version. The core idea of the patch lib analyzer is to compare the abstract syntax tree (AST) of the body of the changed-construct contained in a library with the AST of its vulnerable and fixed version. However, the biggest obstacle is that vulnerability fixes are applied on source code whereas library releases imported within applications are binaries. The patch lib analyzer overcomes this issue by retrieving the source code of binaries (if available) from Maven repositories (e.g. Maven Central or organization's specific Nexus repositories). Warning The current implementation only assesses libraries having a GAV known to Maven Central or configured Nexus repositories. The assessment of python artifacts available in Pypi will soon be covered. If the sources of a given library are available, the patch lib analyzer compares the ASTs of the changed-constructs with the AST of their vulnerable and fixed version. Once equalities are found in source code, they are also used to conclude--wherever possible--for cases where the source code is not available or equalities are not found. The patch lib analyzer may conclude that a library is fixed or vulnerable based on the following criteria: AST EQUALITY vulnerable: if the abstract syntax tree (AST) of at least one construct of the library, is equal to the AST of a construct before it was modified to fix the vulnerability (and none is equal to the fixed version) fixed: if the abstract syntax tree (AST) of at least one construct of the library, is equal to the AST of a construct after it was modified to fix the vulnerability (and none is equal to the vulnerable version) MINOR EQUALITY : The library version is minor of another one in the same minor release (i.e., both starting with x.y.) which has an AST equality to vulnerable MAJOR EQUALITY : The library version is major of another one in the same minor release (i.e., both starting with x.y.) which has an AST equality to fixed INTERSECTION vulnerable: if the abstract syntax tree (AST) of all construct of the library, are \"closer\" (i.e., requires a smaller amount of changes) to the AST of a construct before it was modified to fix the vulnerability than to the one after the change fixed: if the abstract syntax tree (AST) of all construct of the library, are \"closer\" (i.e., requires a smaller amount of changes) to the AST of a construct after it was modified to fix the vulnerability than to the one before the change GREATER RELEASE : the library is in a minor release which was released after the most recent fix of the vulnerability. E.g., 3.4.0 release on Jan 2017 is a greater release for bug CVE-2016-1234 if its latest fix was applied on release 3.3.y before 2016, Dec 31 st . Even in cases where the automated approach cannot conclude, the data computed over the libraries are stored in the Vulas backend under the source TO_REVIEW . The key data used to assess the libraries and always available for review are: sourceAvailable : whether the sources for the library are available in external repositories construct in jar : whether a construct changed to fix a vulnerability is part of the library archive (Jar) dTv (distance to vulnerable): the number of changes to be applied to the AST of a construct in the library, to become equal to the AST of the construct before the fix (computer with ChangeDistiller) dTf (distance to fixed): the number of changes to be applied to the AST of a construct in the library, to become equal to the AST of the construct after the fix (computer with ChangeDistiller) The results are visible in the column \"Patch eval\" of the bugs frontend. Clicking on the cell, all the information computed (based on which the assessment result was taken - if any) are available. Usage \u00b6 The patch lib analyzer can be run as a periodic job or a single run. Configuration: j (-jib) : Run patch Eval as cron job (optional) h (-hour) <arg> : Delay for starting the job (hours) (optional, only relevant if -job is specified, Default: 0 ) p (-period) <arg> : The period between successive executions (in hours) (optional, only relevant if -job is specified, Default: 6) bug (-bug) : Comma separated list of bugs to analyze (optional, all bugs analyzed if config not provided) f (-toFile) : Save JSON results to file; otherwise upload to backend (optional, default: false) o (-overrideResults) : Delete all existing results before upload; otherwise only upload results for AffectedLibraries not already existing in the backend (optional, default: false) Other useful/required configurations: vulas.shared.cia.serviceUrl : url of the deployed rest-lib-util service (Mandatory) vulas.shared.backend.serviceUrl : Url of the deployed rest-backend service (Mandatory) vulas.patchEval.uploadResults : whether to upload the results to vulas.shared.backend.serviceUrl or save the JSON to file (equivalent to -file ) vulas.patchEval.onlyAddNewResults : only upload results for AffectedLibraries not already existing in the backend; otherwise all existing results are deleted before the upload (equivalent to -overrideResults ) vulas.patchEval.basefolder : filesystem path where to save and look for the csv files with the computed data per library vulas.patchEval.bugId : comma separated list of bug identifiers to analyze (equivalent to -bug ) Run as cron job java -Dvulas.patchEval.uploadResults = true -Dvulas.patchEval.onlyAddNewResults = true -Dvulas.patchEval.basefolder = <csv_folder> -j -p 6 -Dvulas.shared.cia.serviceUrl = http://vulas.mo.sap.corp:8080/cia -Dvulas.shared.backend.serviceUrl = http://vulas.mo.sap.corp:8080/backend -Xmx6G -Xms6G -jar patch-lib-analyzer-3.0.12-jar-with-dependencies.jar Run for all bugs java -Dvulas.patchEval.uploadResults = true -Dvulas.patchEval.onlyAddNewResults = true -Dvulas.patchEval.basefolder = <csv_folder> -Dvulas.patchEval.bugId = <comma_separated_list_of_bugs> -Dvulas.shared.cia.serviceUrl = http://vulas.mo.sap.corp:8080/cia -Dvulas.shared.backend.serviceUrl = http://vulas.mo.sap.corp:8080/backend -Xmx6G -Xms6G -jar patch-lib-analyzer-3.0.12-jar-with-dependencies.jar Run for CVE-2018-1111,CVE-2018-2222 java -Dvulas.patchEval.uploadResults = true -Dvulas.patchEval.onlyAddNewResults = true -Dvulas.patchEval.basefolder = <csv_folder> -Dvulas.patchEval.bugId = CVE-2018-1111,CVE-2018-2222 -Dvulas.shared.cia.serviceUrl = http://vulas.mo.sap.corp:8080/cia -Dvulas.shared.backend.serviceUrl = http://vulas.mo.sap.corp:8080/backend -Xmx6G -Xms6G -jar patch-lib-analyzer-3.0.12-jar-with-dependencies.jar","title":"Patch Lib Analyzer"},{"location":"vuln_db/manuals/patch_lib_analyzer/#patch-library-analyzer","text":"The patch library analyzer is a Java application that establishes whether a library contains a construct modified to fix a vulnerability (aka changed-construct) in its vulnerable or fixed version. The core idea of the patch lib analyzer is to compare the abstract syntax tree (AST) of the body of the changed-construct contained in a library with the AST of its vulnerable and fixed version. However, the biggest obstacle is that vulnerability fixes are applied on source code whereas library releases imported within applications are binaries. The patch lib analyzer overcomes this issue by retrieving the source code of binaries (if available) from Maven repositories (e.g. Maven Central or organization's specific Nexus repositories). Warning The current implementation only assesses libraries having a GAV known to Maven Central or configured Nexus repositories. The assessment of python artifacts available in Pypi will soon be covered. If the sources of a given library are available, the patch lib analyzer compares the ASTs of the changed-constructs with the AST of their vulnerable and fixed version. Once equalities are found in source code, they are also used to conclude--wherever possible--for cases where the source code is not available or equalities are not found. The patch lib analyzer may conclude that a library is fixed or vulnerable based on the following criteria: AST EQUALITY vulnerable: if the abstract syntax tree (AST) of at least one construct of the library, is equal to the AST of a construct before it was modified to fix the vulnerability (and none is equal to the fixed version) fixed: if the abstract syntax tree (AST) of at least one construct of the library, is equal to the AST of a construct after it was modified to fix the vulnerability (and none is equal to the vulnerable version) MINOR EQUALITY : The library version is minor of another one in the same minor release (i.e., both starting with x.y.) which has an AST equality to vulnerable MAJOR EQUALITY : The library version is major of another one in the same minor release (i.e., both starting with x.y.) which has an AST equality to fixed INTERSECTION vulnerable: if the abstract syntax tree (AST) of all construct of the library, are \"closer\" (i.e., requires a smaller amount of changes) to the AST of a construct before it was modified to fix the vulnerability than to the one after the change fixed: if the abstract syntax tree (AST) of all construct of the library, are \"closer\" (i.e., requires a smaller amount of changes) to the AST of a construct after it was modified to fix the vulnerability than to the one before the change GREATER RELEASE : the library is in a minor release which was released after the most recent fix of the vulnerability. E.g., 3.4.0 release on Jan 2017 is a greater release for bug CVE-2016-1234 if its latest fix was applied on release 3.3.y before 2016, Dec 31 st . Even in cases where the automated approach cannot conclude, the data computed over the libraries are stored in the Vulas backend under the source TO_REVIEW . The key data used to assess the libraries and always available for review are: sourceAvailable : whether the sources for the library are available in external repositories construct in jar : whether a construct changed to fix a vulnerability is part of the library archive (Jar) dTv (distance to vulnerable): the number of changes to be applied to the AST of a construct in the library, to become equal to the AST of the construct before the fix (computer with ChangeDistiller) dTf (distance to fixed): the number of changes to be applied to the AST of a construct in the library, to become equal to the AST of the construct after the fix (computer with ChangeDistiller) The results are visible in the column \"Patch eval\" of the bugs frontend. Clicking on the cell, all the information computed (based on which the assessment result was taken - if any) are available.","title":"Patch Library Analyzer"},{"location":"vuln_db/manuals/patch_lib_analyzer/#usage","text":"The patch lib analyzer can be run as a periodic job or a single run. Configuration: j (-jib) : Run patch Eval as cron job (optional) h (-hour) <arg> : Delay for starting the job (hours) (optional, only relevant if -job is specified, Default: 0 ) p (-period) <arg> : The period between successive executions (in hours) (optional, only relevant if -job is specified, Default: 6) bug (-bug) : Comma separated list of bugs to analyze (optional, all bugs analyzed if config not provided) f (-toFile) : Save JSON results to file; otherwise upload to backend (optional, default: false) o (-overrideResults) : Delete all existing results before upload; otherwise only upload results for AffectedLibraries not already existing in the backend (optional, default: false) Other useful/required configurations: vulas.shared.cia.serviceUrl : url of the deployed rest-lib-util service (Mandatory) vulas.shared.backend.serviceUrl : Url of the deployed rest-backend service (Mandatory) vulas.patchEval.uploadResults : whether to upload the results to vulas.shared.backend.serviceUrl or save the JSON to file (equivalent to -file ) vulas.patchEval.onlyAddNewResults : only upload results for AffectedLibraries not already existing in the backend; otherwise all existing results are deleted before the upload (equivalent to -overrideResults ) vulas.patchEval.basefolder : filesystem path where to save and look for the csv files with the computed data per library vulas.patchEval.bugId : comma separated list of bug identifiers to analyze (equivalent to -bug ) Run as cron job java -Dvulas.patchEval.uploadResults = true -Dvulas.patchEval.onlyAddNewResults = true -Dvulas.patchEval.basefolder = <csv_folder> -j -p 6 -Dvulas.shared.cia.serviceUrl = http://vulas.mo.sap.corp:8080/cia -Dvulas.shared.backend.serviceUrl = http://vulas.mo.sap.corp:8080/backend -Xmx6G -Xms6G -jar patch-lib-analyzer-3.0.12-jar-with-dependencies.jar Run for all bugs java -Dvulas.patchEval.uploadResults = true -Dvulas.patchEval.onlyAddNewResults = true -Dvulas.patchEval.basefolder = <csv_folder> -Dvulas.patchEval.bugId = <comma_separated_list_of_bugs> -Dvulas.shared.cia.serviceUrl = http://vulas.mo.sap.corp:8080/cia -Dvulas.shared.backend.serviceUrl = http://vulas.mo.sap.corp:8080/backend -Xmx6G -Xms6G -jar patch-lib-analyzer-3.0.12-jar-with-dependencies.jar Run for CVE-2018-1111,CVE-2018-2222 java -Dvulas.patchEval.uploadResults = true -Dvulas.patchEval.onlyAddNewResults = true -Dvulas.patchEval.basefolder = <csv_folder> -Dvulas.patchEval.bugId = CVE-2018-1111,CVE-2018-2222 -Dvulas.shared.cia.serviceUrl = http://vulas.mo.sap.corp:8080/cia -Dvulas.shared.backend.serviceUrl = http://vulas.mo.sap.corp:8080/backend -Xmx6G -Xms6G -jar patch-lib-analyzer-3.0.12-jar-with-dependencies.jar","title":"Usage"},{"location":"vuln_db/tutorials/vuln_db_tutorial/","text":"Getting started with the Vulnerability Database \u00b6 Vulnerabilities in Vulas are represented at code level. This tutorial will guide you through the creation of the following vulnerabilities in the vulnerability database: CVE-2017-7525 (Jackson Databind) CVE-2018-5382 (BouncyCastle) CVE-2018-11039 (Spring) CVE-2014-0050 (Apache Commons FileUpload) COLLECTIONS-580 (Apache Commons Collections) If you have a working installation of the Vulas backend services you will need to import vulnerability data before you can actually perform scans. Installing the Vulas backend services Instructions on how to setup backend services are available here . It is possible to add new vulnerabilities to the database using the patch-analyzer module of the Vulas project. Patch Analyzer \u00b6 Run the following commands to create the change list for the vulnerability and upload it to the backend java -Dvulas.shared.backend.serviceUrl = http://vulas.mo.sap.corp:8080/backend -jar ./patch-analyzer/target/patch-analyzer-3.0.12-jar-with-dependencies.jar com.sap.psr.vulas.PatchAnalyzer -r https://github.com/FasterXML/jackson-databind -b CVE-2017-7525 -e e8f043d1aac9b82eee907e0f0c3abbdea723a935,ddfddfba6414adbecaff99684ef66eebd3a92e92,60d459cedcf079c6106ae7da2ac562bc32dcabe1 -links https://github.com/FasterXML/jackson-databind/issues/1599,https://github.com/FasterXML/jackson-databind/issues/1680,https://github.com/FasterXML/jackson-databind/issues/1737 -descr \"When configured to enable default typing, Jackson contained a deserialization vulnerability that could lead to arbitrary code execution. Jackson fixed this vulnerability by blacklisting known 'deserialization gadgets'. This vulnerability solves an incomplete fix for CVE-2017-4995-JK (main description at: https://github.com/FasterXML/jackson-databind/issues/1599 Issues not addressed by the incomplete fix of CVE-2017-4995-JK: https://github.com/FasterXML/jackson-databind/issues/1680 and https://github.com/FasterXML/jackson-databind/issues/1737) \" -u java -Dvulas.shared.backend.serviceUrl = http://vulas.mo.sap.corp:8080/backend -jar ./patch-analyzer/target/patch-analyzer-3.0.12-jar-with-dependencies.jar com.sap.psr.vulas.PatchAnalyzer -r https://github.com/bcgit/bc-java/ -b CVE-2018-5382 -e 81b00861cd5711e85fe8dce2a0e119f684120255 -links https://snyk.io/vuln/SNYK-JAVA-ORGBOUNCYCASTLE-31659,https://www.kb.cert.org/vuls/id/306792 -u java -Dvulas.shared.backend.serviceUrl = http://vulas.mo.sap.corp:8080/backend -jar ./patch-analyzer/target/patch-analyzer-3.0.12-jar-with-dependencies.jar com.sap.psr.vulas.patcha.PatchAnalyzer -r https://github.com/spring-projects/spring-framework/ -b CVE-2018-11039 -e dac97f1b7dac3e70ff603fb6fc9f205b95dd6b01,f2694a8ed93f1f63f87ce45d0bb638478b426acd -links https://pivotal.io/security/cve-2018-11039,https://jira.spring.io/browse/SPR-16836 -descr \"Cross Site Tracing (XST) with Spring Framework. Description: Spring Framework (versions 5.0.x prior to 5.0.7, versions 4.3.x prior to 4.3.18, and older unsupported versions) allow web applications to change the HTTP request method to any HTTP method (including TRACE) using the HiddenHttpMethodFilter in Spring MVC. If an application has a pre-existing XSS vulnerability, a malicious user (or attacker) can use this filter to escalate to an XST (Cross Site Tracing) attack. Affected Pivotal Products and Versions: Spring Framework 5.0 to 5.0.6, Spring Framework 4.3 to 4.3.17, Older unsupported versions are also affected. Mitigation: Users of affected versions should apply the following mitigation: \\n 5.0.x users should upgrade to 5.0.7. \\n- 4.3.x users should upgrade to 4.3.18. - Older versions should upgrade to a supported branch. \\nThere are no other mitigation steps necessary. This attack applies to applications that: \\n1/ Use the HiddenHttpMethodFilter (it is enabled by default in Spring Boot). \\n2/ Allow HTTP TRACE requests to be handled by the application server. \\nThis attack is not exploitable directly because an attacker would have to make a cross-domain request via HTTP POST, which is forbidden by the Same Origin Policy. This is why a pre-existing XSS (Cross Site Scripting) vulnerability in the web application itself is necessary to enable an escalation to XST.\" -u java -Dvulas.shared.backend.serviceUrl = http://vulas.mo.sap.corp:8080/backend -jar ./patch-analyzer/target/patch-analyzer-3.0.12-jar-with-dependencies.jar com.sap.psr.vulas.PatchAnalyzer -r https://github.com/apache/commons-fileupload -b CVE-2014-0050 -e c61ff05b3241cb14d989b67209e57aa71540417a -u java -Dvulas.shared.backend.serviceUrl = http://vulas.mo.sap.corp:8080/backend -jar ./patch-analyzer/target/patch-analyzer-3.0.12-jar-with-dependencies.jar com.sap.psr.vulas.PatchAnalyzer -r https://github.com/apache/commons-collections -b COLLECTIONS-580 -e 3eee44cf63b1ebb0da6925e98b3dcc6ef1e4d610,78d47d4d098ab814a7a00a0b1c81646b27f050cf,e585cd0433ae4cfbc56e58572b9869bd0c86b611,b2b8f4adc557e4ef1ee2fe5e0ab46866c06ec55b,da1a5fe00d79e1840b7e52317933e9eb56e88246,1642b00d67b96de87cad44223efb9ab5b4fb7be5:3_2_X,5ec476b0b756852db865b2e442180f091f8209ee:3_2_X,bce4d022f27a723fa0e0b7484dcbf0afa2dd210a:3_2_X,d9a00134f16d685bea11b2b12de824845e6473e3:3_2_X -descr \"Arbitrary remote code execution with InvokerTransformer. With InvokerTransformer serializable collections can be build that execute arbitrary Java code. sun.reflect.annotation.AnnotationInvocationHandler#readObject invokes #entrySet and #get on a deserialized collection. If you have an endpoint that accepts serialized Java objects (JMX, RMI, remote EJB, ...) you can combine the two to create arbitrary remote code execution vulnerability. Fixed in versions 3.2.2, 4.1\" -links https://issues.apache.org/jira/browse/COLLECTIONS-580,https://commons.apache.org/proper/commons-collections/security-reports.html -u To run such commands in your own environment, you may need to adapt: the path to the patch analyzer artifact and the artifact version, '-jar ./patch-analyzer/target/patch-analyzer-3.0.12-jar-with-dependencies.jar' the url of the Vulas backend, -Dvulas.shared.backend.serviceUrl=http://vulas.mo.sap.corp:8080/backend the proxy settings; the proxy is not configured in the example but you can do so using the following configurations: -Dhttp.proxyHost = -Dhttp.proxyPort = -Dhttps.proxyHost = -Dhttps.proxyPort = -Dhttp.nonProxyHosts = Patch Lib Analyzer \u00b6 Once vulnerabilities are created in the vulnerability database, the patch lib analyzer must run periodically to assess whether all versions of the library known by the backend contain the vulnerable or fixed version of the construct. Info To get the best of the tutorial, we recommend to proceed to the next step only after having analyzed at least one application (see tutorial page ). Run for all bugs java -Dvulas.patchEval.uploadResults = true -Dvulas.patchEval.onlyAddNewResults = true -Dvulas.patchEval.basefolder = <csv_folder> -Dvulas.patchEval.bugId = <comma_separated_list_of_bugs> -Dvulas.shared.cia.serviceUrl = http://vulas.mo.sap.corp:8080/cia -Dvulas.shared.backend.serviceUrl = http://vulas.mo.sap.corp:8080/backend -Xmx6G -Xms6G -jar patch-lib-analyzer-3.0.10-jar-with-dependencies.jar To check how to run it as a job, check here Info In case the application results still shows orange hourglasses after running the patch lib analyser, the manual assessment is required, see here","title":"Tutorial"},{"location":"vuln_db/tutorials/vuln_db_tutorial/#getting-started-with-the-vulnerability-database","text":"Vulnerabilities in Vulas are represented at code level. This tutorial will guide you through the creation of the following vulnerabilities in the vulnerability database: CVE-2017-7525 (Jackson Databind) CVE-2018-5382 (BouncyCastle) CVE-2018-11039 (Spring) CVE-2014-0050 (Apache Commons FileUpload) COLLECTIONS-580 (Apache Commons Collections) If you have a working installation of the Vulas backend services you will need to import vulnerability data before you can actually perform scans. Installing the Vulas backend services Instructions on how to setup backend services are available here . It is possible to add new vulnerabilities to the database using the patch-analyzer module of the Vulas project.","title":"Getting started with the Vulnerability Database"},{"location":"vuln_db/tutorials/vuln_db_tutorial/#patch-analyzer","text":"Run the following commands to create the change list for the vulnerability and upload it to the backend java -Dvulas.shared.backend.serviceUrl = http://vulas.mo.sap.corp:8080/backend -jar ./patch-analyzer/target/patch-analyzer-3.0.12-jar-with-dependencies.jar com.sap.psr.vulas.PatchAnalyzer -r https://github.com/FasterXML/jackson-databind -b CVE-2017-7525 -e e8f043d1aac9b82eee907e0f0c3abbdea723a935,ddfddfba6414adbecaff99684ef66eebd3a92e92,60d459cedcf079c6106ae7da2ac562bc32dcabe1 -links https://github.com/FasterXML/jackson-databind/issues/1599,https://github.com/FasterXML/jackson-databind/issues/1680,https://github.com/FasterXML/jackson-databind/issues/1737 -descr \"When configured to enable default typing, Jackson contained a deserialization vulnerability that could lead to arbitrary code execution. Jackson fixed this vulnerability by blacklisting known 'deserialization gadgets'. This vulnerability solves an incomplete fix for CVE-2017-4995-JK (main description at: https://github.com/FasterXML/jackson-databind/issues/1599 Issues not addressed by the incomplete fix of CVE-2017-4995-JK: https://github.com/FasterXML/jackson-databind/issues/1680 and https://github.com/FasterXML/jackson-databind/issues/1737) \" -u java -Dvulas.shared.backend.serviceUrl = http://vulas.mo.sap.corp:8080/backend -jar ./patch-analyzer/target/patch-analyzer-3.0.12-jar-with-dependencies.jar com.sap.psr.vulas.PatchAnalyzer -r https://github.com/bcgit/bc-java/ -b CVE-2018-5382 -e 81b00861cd5711e85fe8dce2a0e119f684120255 -links https://snyk.io/vuln/SNYK-JAVA-ORGBOUNCYCASTLE-31659,https://www.kb.cert.org/vuls/id/306792 -u java -Dvulas.shared.backend.serviceUrl = http://vulas.mo.sap.corp:8080/backend -jar ./patch-analyzer/target/patch-analyzer-3.0.12-jar-with-dependencies.jar com.sap.psr.vulas.patcha.PatchAnalyzer -r https://github.com/spring-projects/spring-framework/ -b CVE-2018-11039 -e dac97f1b7dac3e70ff603fb6fc9f205b95dd6b01,f2694a8ed93f1f63f87ce45d0bb638478b426acd -links https://pivotal.io/security/cve-2018-11039,https://jira.spring.io/browse/SPR-16836 -descr \"Cross Site Tracing (XST) with Spring Framework. Description: Spring Framework (versions 5.0.x prior to 5.0.7, versions 4.3.x prior to 4.3.18, and older unsupported versions) allow web applications to change the HTTP request method to any HTTP method (including TRACE) using the HiddenHttpMethodFilter in Spring MVC. If an application has a pre-existing XSS vulnerability, a malicious user (or attacker) can use this filter to escalate to an XST (Cross Site Tracing) attack. Affected Pivotal Products and Versions: Spring Framework 5.0 to 5.0.6, Spring Framework 4.3 to 4.3.17, Older unsupported versions are also affected. Mitigation: Users of affected versions should apply the following mitigation: \\n 5.0.x users should upgrade to 5.0.7. \\n- 4.3.x users should upgrade to 4.3.18. - Older versions should upgrade to a supported branch. \\nThere are no other mitigation steps necessary. This attack applies to applications that: \\n1/ Use the HiddenHttpMethodFilter (it is enabled by default in Spring Boot). \\n2/ Allow HTTP TRACE requests to be handled by the application server. \\nThis attack is not exploitable directly because an attacker would have to make a cross-domain request via HTTP POST, which is forbidden by the Same Origin Policy. This is why a pre-existing XSS (Cross Site Scripting) vulnerability in the web application itself is necessary to enable an escalation to XST.\" -u java -Dvulas.shared.backend.serviceUrl = http://vulas.mo.sap.corp:8080/backend -jar ./patch-analyzer/target/patch-analyzer-3.0.12-jar-with-dependencies.jar com.sap.psr.vulas.PatchAnalyzer -r https://github.com/apache/commons-fileupload -b CVE-2014-0050 -e c61ff05b3241cb14d989b67209e57aa71540417a -u java -Dvulas.shared.backend.serviceUrl = http://vulas.mo.sap.corp:8080/backend -jar ./patch-analyzer/target/patch-analyzer-3.0.12-jar-with-dependencies.jar com.sap.psr.vulas.PatchAnalyzer -r https://github.com/apache/commons-collections -b COLLECTIONS-580 -e 3eee44cf63b1ebb0da6925e98b3dcc6ef1e4d610,78d47d4d098ab814a7a00a0b1c81646b27f050cf,e585cd0433ae4cfbc56e58572b9869bd0c86b611,b2b8f4adc557e4ef1ee2fe5e0ab46866c06ec55b,da1a5fe00d79e1840b7e52317933e9eb56e88246,1642b00d67b96de87cad44223efb9ab5b4fb7be5:3_2_X,5ec476b0b756852db865b2e442180f091f8209ee:3_2_X,bce4d022f27a723fa0e0b7484dcbf0afa2dd210a:3_2_X,d9a00134f16d685bea11b2b12de824845e6473e3:3_2_X -descr \"Arbitrary remote code execution with InvokerTransformer. With InvokerTransformer serializable collections can be build that execute arbitrary Java code. sun.reflect.annotation.AnnotationInvocationHandler#readObject invokes #entrySet and #get on a deserialized collection. If you have an endpoint that accepts serialized Java objects (JMX, RMI, remote EJB, ...) you can combine the two to create arbitrary remote code execution vulnerability. Fixed in versions 3.2.2, 4.1\" -links https://issues.apache.org/jira/browse/COLLECTIONS-580,https://commons.apache.org/proper/commons-collections/security-reports.html -u To run such commands in your own environment, you may need to adapt: the path to the patch analyzer artifact and the artifact version, '-jar ./patch-analyzer/target/patch-analyzer-3.0.12-jar-with-dependencies.jar' the url of the Vulas backend, -Dvulas.shared.backend.serviceUrl=http://vulas.mo.sap.corp:8080/backend the proxy settings; the proxy is not configured in the example but you can do so using the following configurations: -Dhttp.proxyHost = -Dhttp.proxyPort = -Dhttps.proxyHost = -Dhttps.proxyPort = -Dhttp.nonProxyHosts =","title":"Patch Analyzer"},{"location":"vuln_db/tutorials/vuln_db_tutorial/#patch-lib-analyzer","text":"Once vulnerabilities are created in the vulnerability database, the patch lib analyzer must run periodically to assess whether all versions of the library known by the backend contain the vulnerable or fixed version of the construct. Info To get the best of the tutorial, we recommend to proceed to the next step only after having analyzed at least one application (see tutorial page ). Run for all bugs java -Dvulas.patchEval.uploadResults = true -Dvulas.patchEval.onlyAddNewResults = true -Dvulas.patchEval.basefolder = <csv_folder> -Dvulas.patchEval.bugId = <comma_separated_list_of_bugs> -Dvulas.shared.cia.serviceUrl = http://vulas.mo.sap.corp:8080/cia -Dvulas.shared.backend.serviceUrl = http://vulas.mo.sap.corp:8080/backend -Xmx6G -Xms6G -jar patch-lib-analyzer-3.0.10-jar-with-dependencies.jar To check how to run it as a job, check here Info In case the application results still shows orange hourglasses after running the patch lib analyser, the manual assessment is required, see here","title":"Patch Lib Analyzer"}]}